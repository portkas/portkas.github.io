---
title: 进程抽象
categories:
	- OperatingSystem
---
# 进程抽象

## 1.进程API内容

* 创建（create）
* 销毁（destroy）
* 等待（wait）
* 其他控制（miscellaneous control）
* 状态（statu）

<!-- more -->

## 2.进程创建

1.操作系统运行程序的**第一件事**是将代码和所有的静态数据加载（load）到内存中，加载到进程的地址空间中。
2.为程序的运行时栈，分配一些内存。C程序使用栈存放局部变量，函数参数，返回值。操作系统分配这些内存，并提供给进程。
3.操作系统也可能为程序的堆分配一些内存。
4.操作系统还将执行一些其他初始化任务，比如输入\输出相关的任务。

## 3.进程的状态

* 运行：该进程正在执行指令
  1.运行态不会一直持续，进程的CPU时间片用完之后，再次失去CPU，从运行态转为就绪态。
* 就绪：进程准备好运行，但是操作系统在运行其他进程
  1.进程被创建出来了，有运行的资格，但是还没有运行，需要抢占CPU时间片；
  2.得到CPU时间片，进程开始运行，从就绪态转换为运行态；
  3.进程的CPU时间片用完之后，再次失去CPU，从运行态转为就绪态。
* 阻塞：进程被强制放弃CPU，并且没有抢占CPU时间片的资格
  1.比如当进程向磁盘发起I/O请求
  2.当阻塞任务完成，进程从阻塞态转换为就绪态

## 4.进程API

1.fork()系统调用

> 用于创建新进程，创建出来的进程被称为子进程，子进程与父进程几乎一样。子进程不会从main函数开始执行，而是直接从fork系统调用中返回。
> 子进程拥有自己的地址空间（即私有内存），寄存器，程序计数器等，但是它从fork返回的值是不同的。父进程获得的返回值是新创建子进程的PID，子进程获得的返回值是0.

子进程和父进程的**相同点**：
1.拷贝完成后，两个地址空间的用户区数据是相同的。用户数据主要包括：

* 代码区
* 全局数据区
* 堆区
* 动态库加载区（内存映射区）
* 栈区
* 环境变量
* 文件描述符：父进程中被分配的文件描述符都会被拷贝到子进程中，在子进程中可以使用他们打开对应的文件。

子进程和父进程的**区别**：
1.父子进程各自的虚拟地址是相互独立的，不会互相影响和干扰。
2.父子进程的代码区虽然相同，但是执行的代码逻辑可能是不同的。一些情况下会用if判断父子进程，分别执行不同的代码块。
3.内核区存储的父子进程ID是不同的。
4.fork调用成功之后，会返回两个值，父子进程的返回值是不同的。
