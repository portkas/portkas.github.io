---
title: Jetson-Windows通信框架代码
categories:
    - 嵌入式结构光三维重建项目
---
# 功能

## 光机

1. 装载投影条纹
   * 格雷码条纹
   * 相移条纹
2. 读取led电流值
3. 设置led电流值
4. 读取投影仪分辨率
5. 开始投影
   * 单次投影
   * 连续投影

<!-- more -->

## 相机

1. 读取曝光时间
2. 读取相机分辨率
3. 读取相机帧率
4. 设置曝光时间
5. 设置相机帧率
6. 设置触发方式
7. 预览模式（如何预览从而用于调整曝光）

## 其他

1. 图像转存
2. 点云转存
3. 点云平滑程度选择（强，中，弱，无）
4. Z轴区间选择
5. 点云的伪彩色可视化
6. 不同画幅的选择
   * 预置不同画幅的标定文件，根据不同画幅选择对应的标定文件
7. 

# Jetson端

1. 处理客户端发送来控制码
2. strtok()函数分割字符串
3. strcmp()函数比较字符串

# Windows端

1. 发送控制码
2. getline()函数获取输入的控制码

# 框架代码

## Jestson服务器

```C++
#include <arpa/inet.h>
#include <stdio.h>
#include <sys/socket.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <vector>
#include <iostream>

const int PORT = 27015;

int main(){
    // 创建监听的套接字
    int lfd = socket(AF_INET, SOCK_STREAM, 0);
    if(lfd == -1){
        perror("socket");
        exit(0);
    }

    // 绑定本机IP端口
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(PORT);
    int ret = bind(lfd, (struct sockaddr*)&addr, sizeof(addr));
    if(ret == -1){
        perror("bind");
        exit(0);
    }

    // 开始监听
    ret = listen(lfd, 100);
    if(ret == -1){
        perror("listen");
        exit(0);
    }

    // 建立连接
    struct sockaddr_in cliaddr;
    socklen_t clilen = sizeof(cliaddr);
    int cfd = accept(lfd, (struct sockaddr*)&cliaddr, &clilen);
    if(cfd == -1){
        perror("accept");
        exit(0);
    }
    char ip[24] = {0};
    printf("Windows IP:%s, Port:%d\n", inet_ntop(AF_INET, &cliaddr.sin_addr.s_addr, ip, sizeof(ip)), ntohs(cliaddr.sin_port));

    // 数据传输
    while(1){
        char buf[1024];
        char answer[4] = "ok";
        memset(buf, 0, sizeof(buf));
        int len = recv(cfd, buf, sizeof(buf), 0);
        if(len > 0){
            printf("Windows say:%s\n", buf);
            send(cfd, answer, sizeof(answer), 0);

            std::vector<char*> parts;
            char* token = strtok(buf, " ");
            while(token != nullptr){
                parts.push_back(token);
                token = strtok(nullptr, " ");
            }
            if (parts.size() >= 2) {
                if (strcmp(parts[0], "read") == 0) {
                    if (strcmp(parts[1], "exposure") == 0) {
                        printf("执行--读取相机曝光函数--\n");
                    } else if (strcmp(parts[1], "led") == 0) {
                        printf("执行--读取投影仪led电流值函数--\n");
                    } else {
                        printf("读取错误，请重新读取\n");
                    }
                } else if (strcmp(parts[0], "set") == 0) {
                    if (parts.size() >= 3) {
                        if (strcmp(parts[1], "exposure") == 0) {
                            printf("曝光时间被设置为：%d\n", std::stoi(parts[2]));
                        } else if (strcmp(parts[1], "led") == 0) {
                            printf("led电流值被设置为：%d\n", std::stoi(parts[2]));
                        } else {
                            printf("设置错误，请重新设置\n");
                        }
                    } else {
                        printf("缺少设定值\n");
                    }
                }
            } else {
                printf("命令格式错误\n");
            }
        }else if(len == 0){
            printf("Windows break...\n");
            break;
        }else{
            perror("read");
            break;
        }
    }

    // 关闭
    close(cfd);
    close(lfd);
    return 0;
}
```

## Windows客户端

```C++
#include <iostream>
#include <string>
#include <winsock2.h>

#pragma comment(lib, "Ws2_32.lib")
const int PORT = 27015;
const char* SERVER_ADDRESS = "192.168.152.232";

int main(){
    WSADATA wsaDate;
    SOCKET sock = INVALID_SOCKET;
    struct sockaddr_in server;

    // 1.初始化winsock
    int iResult = WSAStartup(MAKEWORD(2,2), &wsaDate);
    if(iResult != 0){
        std::cout << "WSAStartup failed: " << WSAGetLastError() << std::endl;
        return 1;
    }

    // 2.创建通信的套接字
    sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sock == INVALID_SOCKET){
        std::cout << "Socket creation failed: " << WSAGetLastError() << std::endl;
        WSACleanup();
        return 1;

    }

    // 3.连接服务器
    server.sin_family = AF_INET;
    server.sin_port = htons(PORT);
    server.sin_addr.s_addr = inet_addr(SERVER_ADDRESS);
    if (connect(sock, (struct sockaddr*)&server, sizeof(server)) < 0) {
        std::cout << "Connection failed: " << WSAGetLastError() << std::endl;
        closesocket(sock);
        WSACleanup();
        return 1;
    }

    // 4.和服务器通信
    std::string input;
    while(1){
        std::cout<<"Enter a word and a number (e.g., 'read exposure or set exposure 1000'):\n";
        std::getline(std::cin, input);
        if(input.empty()){
            std::cout<<"please enter again.\n"<<std::endl;
        }
        send(sock, input.c_str(), input.length(), 0);
    }

    closesocket(sock);
    iResult = WSACleanup();
    if (iResult != 0) {
        printf("WSACleanup failed: %d\n", iResult);
        return 1;
    }
    return 0;
}
```

# 函数用法

## 字符串比较

使用 `std::vector<char*>` 和 `strtok` 处理字符串时，可能遇到两个常见问题：

1. **字符串比较问题**：`parts[i]` 是一个 `char*`，不能直接使用 `==` 进行比较。这将比较指针的地址，而不是内容。需要使用 `strcmp` 来比较C风格字符串。
2. **访问越界问题**：在访问 `parts[2]` 时（如 `std::stoi(parts[2])`），需要确保 `parts` 的大小足够，否则会导致访问越界。

## strtok()

头文件：string.h

函数功能：根据指定的分割符来分割一个字符串，并在连续的调用中返回分割后的每一个字串（会破坏原始字符串）。

```C++
char *strtok(char *str, const char *delim);
```

参数：

- str：指向要分割的字符串的指针
- delim：分割符

返回值：

- strtok()在第一次调用时，返回第一次找到的不包含分割符的子串的指针。在后续调用中，返回后续的子串。当没有子串可以返回时，返回NULL。

示例用法：

```C++
#include <stdio.h>
#include <string.h>

int main() {
    char str[] = "one,two,three";
    char *token;
    const char *delim = ",";
    token = strtok(str, delim);
    while (token != NULL) {
        printf("%s\n", token);
        token = strtok(NULL, delim);
    }
    return 0;
}
```

注意事项：

- `strtok()` 是非线程安全的，因为它使用了静态缓冲区来保存数据。如果需要线程安全，可以使用 `strtok_r()`。
- `strtok()` 会修改原始字符串，通过在每个分隔符的位置插入空字符（`'\0'`）来终止当前返回的子串。
- 在C++中也可以使用 `std::istringstream` 和 `std::getline` 来分割字符串。

## getline()

头文件：string

函数功能：用于从输入流读取一行文本。可以读取包含空格在内的整行内容，直到遇到换行符为止。

```C++
std::istream& getline(std::istream& is, std::string& str);
```

参数：

- is：输入流的引用，可以是std::cin
- str：用于存储读取的行

getline()和 `>>`的区别：

- `>>`是输入流的提取运算符，用于从输入流中提取数据并将其存储在变量中。
- `>>`与std::cin一起使用时，会在遇到空白（空格，制表符，换行符）时停止读取。
- `>>`不包含空白字符在内，因此不适合读取包含空格的整行文本。当只需要读取单个单词或者值的时候使用 `>>`。
