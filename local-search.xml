<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>argv[]参数转int型</title>
    <link href="/2025/02/22/Cpp/argv%5B%5D%E5%8F%82%E6%95%B0%E8%BD%ACint%E5%9E%8B/"/>
    <url>/2025/02/22/Cpp/argv%5B%5D%E5%8F%82%E6%95%B0%E8%BD%ACint%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>在C&#x2F;C++中，argv[]是一个字符数组（char*），保存了从命令行传递该程序的阐述。</p><span id="more"></span><h1 id="使用atoi-函数"><a href="#使用atoi-函数" class="headerlink" title="使用atoi()函数"></a>使用atoi()函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>  <span class="hljs-keyword">if</span>(argc &gt; <span class="hljs-number">1</span>)&#123;<br>     <span class="hljs-type">int</span> num = atoi(argv[<span class="hljs-number">1</span>]);<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, num);<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;please input one argv!\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="使用strtol-函数"><a href="#使用strtol-函数" class="headerlink" title="使用strtol()函数"></a>使用strtol()函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>  <span class="hljs-comment">// 包含 strtol 函数</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">long</span> num = strtol(argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">10</span>);  <span class="hljs-comment">// 将 argv[1] 转换为 long 类型，基数为10</span><br>        <span class="hljs-keyword">if</span> (*end == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入的数字是: %ld\n&quot;</span>, num);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入的参数不是有效的数字！\n&quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请提供一个数字参数！\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="使用sscanf-函数"><a href="#使用sscanf-函数" class="headerlink" title="使用sscanf()函数"></a>使用sscanf()函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> num;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sscanf</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;%d&quot;</span>, &amp;num) == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 将 argv[1] 转换为 int 类型</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入的数字是: %d\n&quot;</span>, num);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入的参数不是有效的数字！\n&quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请提供一个数字参数！\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三种方法对比"><a href="#三种方法对比" class="headerlink" title="三种方法对比"></a>三种方法对比</h1><p>atoi()：简单快捷，但无法检测错误输入，使用时需要确保输入是有效的数字，否则返回 0。<br>strtol()：推荐用于更加健壮的转换，它允许处理错误输入并支持不同进制数。<br>sscanf()：灵活性较高，可以处理多种格式，适用于需要从字符串中解析多个值的场景。</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cpp-2-类</title>
    <link href="/2025/02/22/Cpp/cpp-2/"/>
    <url>/2025/02/22/Cpp/cpp-2/</url>
    
    <content type="html"><![CDATA[<ol><li>类</li><li>构造和析构函数</li><li>const成员函数</li><li>this指针</li></ol><span id="more"></span><h1 id="抽象和类"><a href="#抽象和类" class="headerlink" title="抽象和类"></a>抽象和类</h1><p>类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操纵数据的方法组合成一个整洁的包；</p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>使用类对象的程序都可以直接访问公有部分，但只能通过公有成员函数或友元函数来访问对象的私有成员；</p><p>公有成员函数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口；</p>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>EffectiveC++笔记</title>
    <link href="/2025/02/22/Cpp/EffectiveCpp/"/>
    <url>/2025/02/22/Cpp/EffectiveCpp/</url>
    
    <content type="html"><![CDATA[<ol><li>宏</li><li>符号表</li><li>定义式和声明式</li></ol><span id="more"></span><h2 id="宏函数"><a href="#宏函数" class="headerlink" title="宏函数"></a>宏函数</h2><h3 id="p16问题"><a href="#p16问题" class="headerlink" title="p16问题"></a>p16问题</h3><blockquote><p>#define CALL_WITH_MAX(a,b) f((a)&gt;(b)?(a):(b))<br>int a&#x3D;5,b&#x3D;0;<br>CALL_WITH_MAX(++a,b);<br>CALL_WITH_MAX(++a,b+10);<br>为什么前者a被累加两次，后者a被累加一次？？？</p></blockquote><p>对上述进行展开，可以得到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 第一个调用</span><br><span class="hljs-built_in">f</span>((++a)&gt;(b)?(++a):(b))<br><br><span class="hljs-comment">// 第二个调用</span><br><span class="hljs-built_in">f</span>((++a)&gt;(b<span class="hljs-number">+10</span>)?(++a):(b<span class="hljs-number">+10</span>))<br></code></pre></td></tr></table></figure><ol><li>当条件为真的时候，会执行f(++a)<ol><li>在第一个调用中++a已经被调用一次当条件为真的时候，在后面又会调用一次</li><li>在第二个调用中条件为假，所以在后面不会再次执行++a</li><li>所以最终执行的是f(7)</li></ol></li><li>当条件为假的时候，会执行f(b+10)<ol><li>这里最终执行的是f(10)</li><li>为什么是f(10)而不是f(20)?因为从始至终b的值都是0，所以最终执行的f(b+10)即f(10)</li></ol></li></ol><h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 定义宏</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span><br><br><span class="hljs-comment">// 定义一个简单的函数f，用于打印参数值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;f(%d)\n&quot;</span>, value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>, b = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before first CALL_WITH_MAX: a = %d, b = %d\n&quot;</span>, a, b);<br>    <span class="hljs-built_in">CALL_WITH_MAX</span>(++a, b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After first CALL_WITH_MAX: a = %d, b = %d\n&quot;</span>, a, b);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before second CALL_WITH_MAX: a = %d, b = %d\n&quot;</span>, a, b);<br>    <span class="hljs-built_in">CALL_WITH_MAX</span>(++a, b + <span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After second CALL_WITH_MAX: a = %d, b = %d\n&quot;</span>, a, b);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./app<br>Before first CALL_WITH_MAX: a = 5, b = 0<br>f(7)<br>After first CALL_WITH_MAX: a = 7, b = 0<br>Before second CALL_WITH_MAX: a = 7, b = 0<br>f(10)<br>After second CALL_WITH_MAX: a = 8, b = 0<br></code></pre></td></tr></table></figure><h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><h3 id="符号表是什么？"><a href="#符号表是什么？" class="headerlink" title="符号表是什么？"></a>符号表是什么？</h3><p>符号表是编程语言编译过程中使用的一种数据结构，用于存储源代码中各种标识符（如变量、函数、类型等）的信息。它在编译器的多个阶段中发挥重要作用，例如帮助编译器识别和解析标识符、进行类型检查、分配内存以及生成代码。</p><h3 id="符号表是如何生成的？"><a href="#符号表是如何生成的？" class="headerlink" title="符号表是如何生成的？"></a>符号表是如何生成的？</h3><p>符号表的生成通常在编译器的词法分析和语法分析阶段完成。词法分析器会识别源代码中的标识符，并将其传递给语法分析器。语法分析器在构建抽象语法树（AST）的同时，会将标识符及其相关信息插入到符号表中。例如，当遇到一个变量声明时，语法分析器会创建一个符号表条目，记录该变量的名称、类型、作用域等信息。</p><h3 id="符号表长什么样子？"><a href="#符号表长什么样子？" class="headerlink" title="符号表长什么样子？"></a>符号表长什么样子？</h3><p>符号表通常由多个条目组成，每个条目代表一个标识符。每个条目包含以下信息：</p><ul><li><strong>名称</strong> ：标识符的名称。</li><li><strong>类型</strong> ：标识符的数据类型。</li><li><strong>作用域</strong> ：标识符的作用域，例如全局作用域或局部作用域。</li><li><strong>存储位置</strong> ：标识符在内存中的位置。</li><li><strong>其他属性</strong> ：根据标识符的类型，可能还会包含其他属性，如函数的参数列表、变量的初始值等。</li></ul><p>例如，对于以下C代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">float</span> b = <span class="hljs-number">3.14</span>;<br>    <span class="hljs-type">int</span> c;<br>    c = a + b;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其符号表可能如下所示：</p><table><thead><tr><th>名称</th><th>类型</th><th>作用域</th><th>存储位置</th></tr></thead><tbody><tr><td>a</td><td>int</td><td>main()</td><td>0x1000</td></tr><tr><td>b</td><td>float</td><td>main()</td><td>0x1004</td></tr><tr><td>c</td><td>int</td><td>main()</td><td>0x1008</td></tr></tbody></table><h3 id="符号表的底层原理是什么？"><a href="#符号表的底层原理是什么？" class="headerlink" title="符号表的底层原理是什么？"></a>符号表的底层原理是什么？</h3><p>符号表的底层原理主要涉及以下几个方面：</p><ul><li><strong>数据结构</strong> ：符号表通常使用哈希表、平衡二叉搜索树等数据结构来存储和管理符号。哈希表可以提供快速的查找和插入操作，而平衡二叉搜索树则可以保证操作的时间复杂度。</li><li><strong>作用域管理</strong> ：符号表需要支持嵌套作用域。当进入一个新的作用域（如函数或代码块）时，符号表会创建一个新的作用域层，并在该层中存储局部符号。当退出作用域时，局部符号会被移除。</li><li><strong>符号解析</strong> ：在代码生成阶段，编译器需要根据符号表中的信息来分配内存和生成指令。例如，变量的地址可以通过其在符号表中的存储位置属性来确定。</li></ul><h2 id="定义式和声明式"><a href="#定义式和声明式" class="headerlink" title="定义式和声明式"></a>定义式和声明式</h2><h3 id="定义式（Definition）"><a href="#定义式（Definition）" class="headerlink" title="定义式（Definition）"></a>定义式（Definition）</h3><p>定义式是指在编程语言中，为一个变量、函数、类型等分配存储空间，并且可以初始化的过程。定义式不仅声明了标识符的存在，还分配了内存，并且可以为变量赋初值。</p><h3 id="声明式（Declaration）"><a href="#声明式（Declaration）" class="headerlink" title="声明式（Declaration）"></a>声明式（Declaration）</h3><p>声明式是指在编程语言中，声明一个变量、函数、类型等的存在，但不分配存储空间。声明式的主要目的是让编译器知道标识符的类型、作用域等信息，以便在后续的代码中正确地使用它。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="1-存储空间"><a href="#1-存储空间" class="headerlink" title="1. 存储空间"></a>1. <strong>存储空间</strong></h4><ul><li><strong>定义式</strong> ：会分配存储空间。</li><li><strong>声明式</strong> ：不会分配存储空间。</li></ul><h4 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. <strong>初始化</strong></h4><ul><li><strong>定义式</strong> ：可以初始化变量。</li><li><strong>声明式</strong> ：不能初始化变量。</li></ul><h4 id="3-作用域和链接"><a href="#3-作用域和链接" class="headerlink" title="3. 作用域和链接"></a>3. <strong>作用域和链接</strong></h4><ul><li><strong>定义式</strong> ：定义的变量或函数在当前作用域中可用，并且可以被链接到其他作用域。</li><li><strong>声明式</strong> ：声明的变量或函数在当前作用域中可用，但不会分配存储空间，通常用于声明外部变量或函数。</li></ul><h4 id="4-编译器处理"><a href="#4-编译器处理" class="headerlink" title="4. 编译器处理"></a>4. <strong>编译器处理</strong></h4><ul><li><strong>定义式</strong> ：编译器会为定义的变量或函数分配内存，并且可以进行初始化。</li><li><strong>声明式</strong> ：编译器只会记录声明的变量或函数的类型和作用域信息，不会分配内存。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义式</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// 定义了一个整型变量a，并初始化为10</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 定义了一个函数func</span><br>    <span class="hljs-comment">// 函数体</span><br>&#125;<br><br><span class="hljs-comment">// 声明式</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> b; <span class="hljs-comment">// 声明了一个外部变量b，但不分配存储空间</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 声明了一个函数func，但不定义函数体</span><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>定义式</strong> ：分配存储空间，可以初始化，是声明式的一种特殊情况。</li><li><strong>声明式</strong> ：不分配存储空间，只声明标识符的存在，通常用于跨文件或跨作用域的引用。</li></ul><h2 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a>常量指针和指针常量</h2><ol><li>const修饰*：表示这个指针的指向是不能改变的；指向的内容可以改变；</li><li>const修饰类型：表示这个指针指向的内容是不能改变的；指针的指向可以改变；</li></ol><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><blockquote><p>为免除“跨编译单元之初始化次序”问题，请以local static对象替代non-local static对象。</p></blockquote><h3 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1.问题背景"></a>1.问题背景</h3><p>在C++中，non-local static对象（非局部静态对象）是指定义在函数外部的全局静态对象，它们在程序启动时初始化，但在不同编译单元（.cpp文件）中定义的全局静态对象的初始化顺序是未定义的。这意味着如果一个全局静态对象依赖于另一个全局静态对象，可能会出现未初始化的依赖对象被访问的情况，从而导致未定义行为。</p><h4 id="静态对象初始化顺序问题"><a href="#静态对象初始化顺序问题" class="headerlink" title="静态对象初始化顺序问题"></a>静态对象初始化顺序问题</h4><p>在C++中，全局静态对象（non-local static objects）的初始化顺序是未定义的，特别是在多个编译单元（.cpp文件）中定义的全局静态对象。这意味着如果一个全局静态对象依赖于另一个全局静态对象，可能会出现未初始化的依赖对象被访问的情况，从而导致未定义行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// File1.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;File2.h&quot;</span></span><br>A a;<br><br><span class="hljs-comment">// File2.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;File1.h&quot;</span></span><br>B b;<br></code></pre></td></tr></table></figure><p>如果 <code>A</code>的构造函数依赖于 <code>B</code>，而 <code>B</code>尚未初始化，就会导致问题。</p><h3 id="2-解决方案：使用Local-Static对象"><a href="#2-解决方案：使用Local-Static对象" class="headerlink" title="2. 解决方案：使用Local Static对象"></a>2. 解决方案：使用Local Static对象</h3><h4 id="局部静态对象的优势"><a href="#局部静态对象的优势" class="headerlink" title="局部静态对象的优势"></a>局部静态对象的优势</h4><p>局部静态对象（local static objects）是指在函数内部定义的静态对象。它们在第一次调用该函数时初始化，并且只初始化一次。由于局部静态对象的初始化时机是明确的（即在第一次调用时），因此可以避免跨编译单元的初始化顺序问题。</p><h3 id="3-具体示例"><a href="#3-具体示例" class="headerlink" title="3. 具体示例"></a>3. 具体示例</h3><h4 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h4><p>假设有一个全局静态对象 <code>FileSystem</code>，它被另一个全局静态对象 <code>Directory</code>使用。为了避免初始化顺序问题，可以将 <code>FileSystem</code>改为局部静态对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// FileSystem.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystem</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">numDisks</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><span class="hljs-keyword">extern</span> FileSystem tfs;  <span class="hljs-comment">// 全局静态对象</span><br><br><span class="hljs-comment">// Directory.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Directory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Directory</span>();<br>&#125;;<br><br><span class="hljs-comment">// Directory.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;FileSystem.h&quot;</span></span><br>Directory::<span class="hljs-built_in">Directory</span>() &#123;<br>    std::<span class="hljs-type">size_t</span> disks = tfs.<span class="hljs-built_in">numDisks</span>();  <span class="hljs-comment">// 使用全局静态对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>tfs</code>和 <code>Directory</code>的初始化顺序是不确定的。</p><h4 id="改进代码"><a href="#改进代码" class="headerlink" title="改进代码"></a>改进代码</h4><p>将 <code>FileSystem</code>改为局部静态对象：</p><p><strong>cpp</strong>Copy</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// FileSystem.h</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystem</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">numDisks</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br><span class="hljs-function">FileSystem&amp; <span class="hljs-title">tfs</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 返回局部静态对象的引用</span><br>    <span class="hljs-type">static</span> FileSystem fs;<br>    <span class="hljs-keyword">return</span> fs;<br>&#125;<br><br><span class="hljs-comment">// Directory.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;FileSystem.h&quot;</span></span><br>Directory::<span class="hljs-built_in">Directory</span>() &#123;<br>    std::<span class="hljs-type">size_t</span> disks = <span class="hljs-built_in">tfs</span>().<span class="hljs-built_in">numDisks</span>();  <span class="hljs-comment">// 调用函数获取局部静态对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过这种方式，<code>FileSystem</code>对象 <code>fs</code>会在第一次调用 <code>tfs()</code>时初始化，从而避免了初始化顺序问题。</p><h3 id="4-多线程环境下的安全性"><a href="#4-多线程环境下的安全性" class="headerlink" title="4. 多线程环境下的安全性"></a>4. 多线程环境下的安全性</h3><h4 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h4><p>在多线程环境中，局部静态对象的初始化是线程安全的（C++11及之后的标准保证了这一点）。这意味着即使多个线程同时调用 <code>tfs()</code>，<code>FileSystem</code>对象 <code>fs</code>也只会被初始化一次。</p><p>但如果需要在多线程启动阶段初始化多个对象，建议在程序的单线程启动阶段手工调用这些对象的初始化函数，以避免潜在的线程安全问题。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><ul><li><strong>Non-local static对象</strong> ：初始化顺序是不确定的，容易导致跨编译单元的初始化问题。</li><li><strong>Local static对象</strong> ：在第一次调用时初始化，初始化顺序明确，可以避免上述问题。</li><li><strong>多线程安全性</strong> ：C++11及之后的标准保证了局部静态对象的线程安全性，但在多线程启动阶段初始化多个对象时，建议在单线程启动阶段手工调用初始化函数。</li></ul><h3 id="6-其他注意事项"><a href="#6-其他注意事项" class="headerlink" title="6. 其他注意事项"></a>6. 其他注意事项</h3><h4 id="避免使用全局静态对象"><a href="#避免使用全局静态对象" class="headerlink" title="避免使用全局静态对象"></a>避免使用全局静态对象</h4><p>如果可能，尽量避免使用全局静态对象，因为它们不仅存在初始化顺序问题，还可能导致其他问题，如线程安全问题和资源管理问题。</p><h4 id="使用单例模式"><a href="#使用单例模式" class="headerlink" title="使用单例模式"></a>使用单例模式</h4><p>如果确实需要全局对象，可以考虑使用单例模式，结合局部静态对象来实现线程安全的全局对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">static</span> Singleton instance;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;  <span class="hljs-comment">// 私有构造函数</span><br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;  <span class="hljs-comment">// 禁止拷贝构造</span><br>    Singleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&amp;) = <span class="hljs-keyword">delete</span>;  <span class="hljs-comment">// 禁止赋值</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h2><p>局部静态对象（Local Static Object）的初始化顺序是明确的，原因在于其初始化时机是由语言标准明确定义的：局部静态对象在第一次进入其作用域时被初始化。这种机制确保了初始化的顺序与代码的执行流程一致，从而避免了全局静态对象（Non-local Static Object）初始化顺序不确定的问题。</p><h3 id="1-局部静态对象的初始化机制"><a href="#1-局部静态对象的初始化机制" class="headerlink" title="1.局部静态对象的初始化机制"></a>1.局部静态对象的初始化机制</h3><p>局部静态对象是定义在函数内部的静态变量。它们的生命周期从第一次进入作用域开始，直到程序结束，但其初始化时机是延迟到第一次使用时。这种机制被称为“延迟初始化”（Lazy Initialization）。</p><p>根据C++标准（C++11及之后版本），局部静态对象的初始化是线程安全的，并且只会在第一次进入其作用域时发生。具体来说：</p><ul><li>如果多个线程同时首次进入该局部静态对象的作用域，C++标准库会确保只有一个线程执行初始化操作，其他线程会等待初始化完成</li><li>初始化完成后，后续的所有访问都会直接使用已经初始化的对象</li></ul><h3 id="2-为什么初始化顺序明确"><a href="#2-为什么初始化顺序明确" class="headerlink" title="2.为什么初始化顺序明确"></a>2.为什么初始化顺序明确</h3><p>局部静态对象的初始化顺序明确，是因为它们的初始化时机与代码的执行流程直接相关。具体来说：</p><ul><li>延迟初始化：局部静态对象只有在第一次进入其作用域时才会被初始化。这意味着它们的初始化顺序完全取决于代码的执行路径</li><li>作用域限制：局部静态对象的作用域是函数内部，因此它们的初始化顺序不会受到其他编译单元中全局静态对象的影响。</li><li>线程安全：在多线程环境中，C++标准确保局部静态对象的初始化是线程安全的。即使多个线程同时首次进入该作用域，初始化也只会发生一次</li></ul><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 局部静态变量</span><br>    counter++;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Counter: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func)</span></span>;<br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Counter: 1<br>Counter: 2<br></code></pre></td></tr></table></figure><p>解释：</p><ul><li><code>counter</code> 是一个局部静态变量，它在第一次调用 <code>func()</code> 时被初始化为 <code>0</code>。</li><li>在多线程环境中，即使 <code>t1</code> 和 <code>t2</code> 同时调用 <code>func()</code>，<code>counter</code> 的初始化也只会发生一次（线程安全）。</li><li>第一次调用 <code>func()</code> 时，<code>counter</code> 被初始化为 <code>0</code>，然后递增为 <code>1</code>。</li><li>第二次调用 <code>func()</code> 时，<code>counter</code> 已经初始化，直接递增为 <code>2</code>。</li></ul><h3 id="4-为什么全局静态对象的初始化顺序不确定？"><a href="#4-为什么全局静态对象的初始化顺序不确定？" class="headerlink" title="4. 为什么全局静态对象的初始化顺序不确定？"></a>4. 为什么全局静态对象的初始化顺序不确定？</h3><p>与局部静态对象不同，全局静态对象（Non-local Static Object）的初始化顺序是不确定的，原因在于：</p><ul><li>跨编译单元初始化：全局静态对象的初始化顺序取决于它们在不同编译单元中的定义顺序。</li><li>编译器限制：编译器无法保证不同编译单元中全局静态对象的初始化顺序。</li><li>依赖关系：如果一个全局静态对象依赖于另一个全局静态对象，而后者尚未初始化，就会导致未定义行为。</li></ul><h3 id="5-总结-1"><a href="#5-总结-1" class="headerlink" title="5. 总结"></a>5. 总结</h3><ul><li>局部静态对象的初始化顺序是明确的，因为它们的初始化时机与代码的执行流程直接相关，且初始化只发生在第一次进入作用域时。</li><li>全局静态对象的初始化顺序是不确定的，因为它们的初始化顺序取决于编译单元的定义顺序，且编译器无法保证跨编译单元的初始化顺序。</li><li>使用局部静态对象可以有效避免全局静态对象初始化顺序不确定的问题。</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://kimi.moonshot.cn/chat/cundehcupvno1tud2j90#">Effective C++：条款4：确定对象被使用前已先被初始化</a></li><li><a href="https://kimi.moonshot.cn/chat/cundehcupvno1tud2j90#">Effective C++：使用局部静态对象替代全局静态对象</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cpp-4-回调函数</title>
    <link href="/2025/02/22/Cpp/cpp-4/"/>
    <url>/2025/02/22/Cpp/cpp-4/</url>
    
    <content type="html"><![CDATA[<ol><li>什么是回调函数</li><li>回调函数用法</li></ol><span id="more"></span><h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>回调函数，是计算机编程中对某一段可执行代码的引用，它被作为参数传递给另一段代码；</p><p>回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应；</p><ol><li>普通函数的回调</li><li>类成员函数的回调</li><li>基于std::function和std::bind的回调</li><li>Lambda表达式的回调</li></ol><h1 id="普通函数的回调"><a href="#普通函数的回调" class="headerlink" title="普通函数的回调"></a>普通函数的回调</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span>  <span class="hljs-title">int</span> <span class="hljs-params">(*callBackFunc)</span><span class="hljs-params">(<span class="hljs-type">char</span>* name)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">playBegin</span><span class="hljs-params">(<span class="hljs-type">char</span>* name)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;视频开始解码，即将出现画面....\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">playEnd</span><span class="hljs-params">(<span class="hljs-type">char</span>* name)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;视频播放结束....\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">play</span><span class="hljs-params">(callBackFunc fn, <span class="hljs-type">char</span>* name)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (*fn)(name);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">char</span> pName[<span class="hljs-number">1024</span>] = <span class="hljs-string">&quot;色即是空&quot;</span>;<br>   <span class="hljs-comment">//视频播放开始....</span><br>   <span class="hljs-built_in">play</span>(playBegin,pName);<span class="hljs-comment">//playBegin函数指针作为参数传递</span><br>   <span class="hljs-comment">//视频播放中....</span><br>   <span class="hljs-comment">//视频播放结束....</span><br>   <span class="hljs-built_in">play</span>(playEnd,pName);<span class="hljs-comment">//playEnd函数指针作为参数传递</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>playBegin(),playEnd()是普通函数，定义了回调函数的逻辑；</li><li>play()函数是一个高阶函数，接收函数指针作为参数，并在内部调用回调函数；</li><li>在main()中，将函数playBegin(),playEnd()的地址传递给play()实现回调；</li></ol><p>需要注意的是：</p><p>在 <code>play</code> 函数中，<code>fn</code> 是一个 <code>callBackFunc</code> 类型的参数，即它是一个指向函数的指针。因此，<code>(*fn)(name)</code> 和 <code>fn(name)</code> 都是合法的函数调用方式，它们都表示通过函数指针 <code>fn</code> 调用指向的函数，并传递 <code>name</code> 作为参数。</p><ul><li><code>(*fn)(name)</code> 是显式地通过解引用函数指针来调用函数。<code>*fn</code> 获取函数指针指向的函数，然后调用该函数。</li><li><code>fn(name)</code> 是更简洁的写法，直接通过函数指针调用函数。在 C 语言中，当函数指针用于调用函数时，可以省略解引用操作符 <code>*</code>，因为上下文已经明确了这是一个函数调用操作.</li></ul><h1 id="类成员函数的回调"><a href="#类成员函数的回调" class="headerlink" title="类成员函数的回调"></a>类成员函数的回调</h1><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>由于普通成员函数必须依赖具体对象才能调用，因此在回调时需要传递对象指针和成员函数指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CallbackHandler</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 成员函数作为回调函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">memberCallback</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;成员函数回调，被调用时传入的值是:&quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 一个执行回调的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">executableMemberCallback</span><span class="hljs-params">(CallbackHandler* obj, <span class="hljs-type">void</span> (CallbackHandler::*callback)(<span class="hljs-type">int</span>), <span class="hljs-type">int</span> value)</span></span>&#123;<br>    <span class="hljs-comment">// 通过对象指针和成员函数指针调用成员函数</span><br>    (obj-&gt;*callback)(value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 传递对象和成员函数指针进行回调</span><br>    CallbackHandler handler;<br>    <span class="hljs-built_in">executableMemberCallback</span>(&amp;handler, &amp;CallbackHandler::memberCallback, <span class="hljs-number">42</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>CallbackHandler类中定义了一个成员函数memberCallback;</li><li>executeMemberCallback接收对象指针CallbackHandler* obj和成员函数指针void (CallbackHandler::*callback)(int)</li><li>通过(obj-&gt;*callback)(value)调用成员函数；</li><li>在main函数中，通过对象handler和成员函数指针&amp;CallbackHandler::memberCallback实现回调；</li></ol><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>在c++面向对象里面，回调函数是成员函数的情况更常见，这样的好处是，一个类A的一个函数生成一个结果之后，可以调用另一个类B的成员函数。而不必类A拥有B的实例。</p><p>尤其是在B中有了A的实例的情况下，A中如果再包含B的实例会出现循环引用的问题 ，这也是可以解决的，但是这种耦合还是容易让逻辑变得混乱。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> std::function&lt;<span class="hljs-type">void</span> (string)&gt; CaptureCallback;  <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CaptureController</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    CaptureCallback callback;<br>    <span class="hljs-built_in">CaptureController</span>(CaptureCallback callback):<span class="hljs-built_in">callback</span>(callback)&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">capturePic</span><span class="hljs-params">(CaptureCallback callback)</span></span>&#123;<br>        string t = <span class="hljs-string">&quot;a pic&quot;</span>;<br>        <span class="hljs-built_in">callback</span>(t);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UI</span>&#123;<br>    <span class="hljs-comment">//开始捕捉图像</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">startCapture</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-function">CaptureController <span class="hljs-title">c</span><span class="hljs-params">(std::bind(&amp;UI::renderPic,<span class="hljs-keyword">this</span>,_1))</span></span>; <br>        c.<span class="hljs-built_in">capturePic</span>();<br>    &#125;<br>  <br>    <span class="hljs-comment">//渲染图片作为回调函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">renderPic</span><span class="hljs-params">(string t)</span></span>&#123;<br>        <span class="hljs-built_in">print</span>(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//main.cpp</span><br>UI ui;<br>ui.<span class="hljs-built_in">startCapture</span>();<br></code></pre></td></tr></table></figure><h1 id="std-function-std-bind"><a href="#std-function-std-bind" class="headerlink" title="std::function&#x2F;std::bind"></a>std::function&#x2F;std::bind</h1><ol><li>std::function可以存储任意可调用对象（普通函数，成员函数，Lambda表达式)</li><li>std::bind可以绑定成员函数和对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; CallBackFunc;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">executeCallback</span><span class="hljs-params">(CallBackFunc callback, <span class="hljs-type">int</span> value)</span></span>&#123;<br>    <span class="hljs-built_in">callback</span>(value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">freeFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;普通函数回调，传入的参数为：&quot;</span> &lt;&lt; value &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CallbackHandler</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">memberCallback</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;成员函数回调，传入的参数为：&quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    CallbackHandler handler;<br>    <span class="hljs-comment">// 1. 传递普通函数作为回调</span><br>    <span class="hljs-built_in">executeCallback</span>(freeFunction, <span class="hljs-number">42</span>);<br><br>    <span class="hljs-comment">// 2. 传递Lambda表达式作为回调</span><br>    <span class="hljs-built_in">executeCallback</span>([](<span class="hljs-type">int</span> value)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Lambda 回调，传入的参数为：&quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;, <span class="hljs-number">43</span>);<br><br>    <span class="hljs-comment">// 3. 传递成员函数作为回调</span><br>    <span class="hljs-built_in">executeCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;CallbackHandler::memberCallback, &amp;handler, std::placeholders::_1), <span class="hljs-number">44</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><code>function&lt;void(int)&gt;</code>可以存储普通函数，Lambda表达式或绑定后的成员函数；</li><li>使用std::bind将成员函数和对象绑定，并通过std::placeholder::_1占位符传递参数；</li></ol>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cpp-5-类和动态内存分配</title>
    <link href="/2025/02/22/Cpp/cpp-5/"/>
    <url>/2025/02/22/Cpp/cpp-5/</url>
    
    <content type="html"><![CDATA[<ol><li>对类成员使用动态内存分配</li><li>复制构造函数</li><li>静态类成员</li></ol><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cpp-3-内存模型</title>
    <link href="/2025/02/22/Cpp/cpp-3/"/>
    <url>/2025/02/22/Cpp/cpp-3/</url>
    
    <content type="html"><![CDATA[<ul><li>单独编译</li><li>存储持续性，作用域和链接性</li><li>定位new运算符</li><li>名称空间</li></ul><span id="more"></span><h1 id="单独编译"><a href="#单独编译" class="headerlink" title="单独编译"></a>单独编译</h1><ol><li>通常大型程序由多个源代码文件组成，这些文件可能共享一些数据，这样的程序涉及到文件的单独编译。</li></ol><ul><li>头文件：包含结构声明和使用这些结构的函数的原型；</li><li>源代码文件：包含与结构有关的函数的代码；</li><li>源代码文件：包含调用与结构有关的函数的代码；</li></ul><ol start="2"><li>禁止将函数定义或变量声明放到头文件中：如果在头文件包含一个函数定义，然后在其他两个文件中包含该头文件，则同一个程序中将包含同一个函数的两个定义，除非函数是内联的，否则会报错重复定义；</li><li>头文件通常包含的内容：</li></ol><ul><li>函数原型</li><li>使用#define或const定义的符号常量</li><li>结构声明</li><li>类声明</li><li>模板声明</li><li>内联函数</li></ul><ol start="4"><li>将结构声明放在头文件中是可以的，因为它们不创建变量；</li><li>在同一个文件中只能将同一个头文件包含一次；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> HEAD_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;head.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ol start="6"><li>多个库的链接：在链接编译模块的时候，确保所有对象文件或库是由同一个编译器生成的，避免链接错误。</li></ol><h1 id="存储持续性，作用域和链接性"><a href="#存储持续性，作用域和链接性" class="headerlink" title="存储持续性，作用域和链接性"></a>存储持续性，作用域和链接性</h1><p>C++使用三种（在C++11中是四种)不同的方案来存储数据，这些方案的区别在于数据保留在内存中的时间：</p><ul><li>自动存储持续性：在函数定义中声明的变量（包括函数参数)的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，他们使用的内存被释放；</li><li>静态存储持续性：在函数定义外定义的变量和使用关键字static定义的变量的存储持续性为静态。它们在程序整个运行过程中都存在；</li><li>线程存储持续性（C++11)：在多核处理器中很常见，如果变量是使用thread_local声明的，则其生命周期与所属的线程一样长；</li><li>动态存储持续性：用new运算符分配的内存将一直存在，直到delete运算符将其释放或程序结束为止。这种内存的存储持续性为动态，有时被称为自由存储或堆；</li></ul><h3 id="作用域和链接"><a href="#作用域和链接" class="headerlink" title="作用域和链接"></a>作用域和链接</h3><p>链接性：描述了名称如何在不同单元间共享，链接性为外部的名称可以在文件间共享，链接性为内部的名称只能由一个文件中的函数共享，自动变量的名称没有链接性，因为他们不能共享；</p><p>C++函数的作用于可以是整个类或整个名称空间，但不能是局部的（因为它们不能在代码块内定义函数)；</p><h3 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h3><p>在C++中，<code>register</code>关键字用于建议编译器将变量存储在寄存器中，以提高变量访问的速度。然而，这只是对编译器的一个提示，编译器可以忽略这个关键字。使用 <code>register</code>关键字的变量通常用于频繁访问的变量，以减少内存访问的开销。</p><p>使用示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">register</span> <span class="hljs-type">int</span> counter = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (counter = <span class="hljs-number">0</span>; counter &lt; <span class="hljs-number">10</span>; ++counter) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Counter: &quot;</span> &lt;&lt; counter &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>counter</code>变量被声明为寄存器变量，这意味着编译器会尝试将其存储在寄存器中，以便在循环中快速访问和修改.</p><p>注意事项：</p><ol><li><strong>作用域限制</strong>：<code>register</code>变量必须是局部变量，不能是全局变量或静态变量.</li><li><strong>存储限制</strong>：由于寄存器的数量有限，编译器可能会根据实际情况选择是否将变量存储在寄存器中.</li><li><strong>C++11及以后</strong>：在C++11标准中，<code>register</code>关键字被标记为弃用（deprecated），但仍然可以使用。C++17标准中，<code>register</code>关键字被正式移除。因此，在现代C++代码中，建议避免使用 <code>register</code>关键字，而是依赖编译器的优化能力来决定变量的存储位置.</li></ol><p>现代编译器通常具有高度优化的能力，能够自动识别并优化频繁访问的变量，因此在大多数情况下，显式使用 <code>register</code>关键字并不会带来显著的性能提升。</p><p>关键字register用于在声明中指示寄存器存储，而在C++11中，它只是显式地指出变量是自动的。</p><h3 id="静态持续变量"><a href="#静态持续变量" class="headerlink" title="静态持续变量"></a>静态持续变量</h3><p>C++为静态存储持续性变量提供了三种链接性：</p><ul><li>外部链接性（可在其他文件中访问)</li><li>内部链接性（只能在当前文件中访问)</li><li>无链接性（只能在当前函数或代码块中访问)</li></ul><p>这三种链接性在整个程序执行期间都存在，与自动变量相比，他们的寿命更长。静态变量的数目在程序运行期间是不变的，编译器将分配固定的内存块来存储所有的静态变量；</p><ul><li>要创建链接性为外部的静态持续变量，必须在代码块的外面声明它；</li><li>要创建链接性为内部的静态持续变量，必须在代码块的外面声明它，并使用static限定符；</li><li>要创建没有链接性的静态持续变量，必须在代码块的内部声明它，并使用static限定符；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 外部链接性静态持续变量</span><br><span class="hljs-type">int</span> global = <span class="hljs-number">1000</span>;<br><br><span class="hljs-comment">// 内部链接性静态持续变量</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> one_file = <span class="hljs-number">50</span>;<br><br><span class="hljs-comment">// 无链接性静态持续变量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所有的静态持续变量在整个程序执行期间都存在。在func()中声明的变量count的作用于为局部，没有链接性，这意味着只能在func()函数中使用它，但是与自动变量不同的是，即使在func()函数没有被执行时，count也留在内存中，并且其只会被初始化一次，具有记忆性；</p><p>globle和one_file变量的作用于都为整个文件，即从声明位置到文件结尾的范围内都可以被使用，由于one_file的链接性为内部，因此只能在包含该变量的单个文件中使用；由于global的链接性为外部，因此可以在程序的其他文件中使用它。</p><h3 id="静态持续性，外部链接性"><a href="#静态持续性，外部链接性" class="headerlink" title="静态持续性，外部链接性"></a>静态持续性，外部链接性</h3><h4 id="单定义规则"><a href="#单定义规则" class="headerlink" title="单定义规则"></a>单定义规则</h4><p>一方面，在每个使用外部变量的文件中都必须声明它；另一方面，C++中有单定义原则，即变量只能有一次定义。为了满足这种需求，C++中有两种变量声明方式：</p><ul><li>定义声明：给变量分配存储空间</li><li>引用声明（extern)：不给变量分配存储空间，引用已有的变量</li></ul><p>引用声明使用关键字extern且不进行初始化，如果初始化的话声明为定义，会导致分配空间；</p><p>如果要在多个文件中使用外部变量，只需要在一个文件中包含该变量的定义（单定义规则)，但在使用该变量的其他所有文件中，都必须使用关键字extern声明它；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// external.cpp -- external variable</span><br><span class="hljs-comment">// compile with support.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// external variable</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">double</span> warming = <span class="hljs-number">0.3</span>;       <span class="hljs-comment">// warming defined</span><br><br><span class="hljs-comment">// function prototypes</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">double</span> dt)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">local</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>                  <span class="hljs-comment">// uses global variable</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Global warming is &quot;</span> &lt;&lt; warming &lt;&lt; <span class="hljs-string">&quot; degrees.\n&quot;</span>;<br>    <span class="hljs-built_in">update</span>(<span class="hljs-number">0.1</span>);            <span class="hljs-comment">// call function to change warming</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Global warming is &quot;</span> &lt;&lt; warming &lt;&lt; <span class="hljs-string">&quot; degrees.\n&quot;</span>;<br>    <span class="hljs-built_in">local</span>();                <span class="hljs-comment">// call function with local warming</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Global warming is &quot;</span> &lt;&lt; warming &lt;&lt; <span class="hljs-string">&quot; degrees.\n&quot;</span>;<br>    <span class="hljs-comment">// cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里在定义声明的时候使用了extern关键字（错误的行为)，编译器会给出警告：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ 33%] Building CXX object CMakeFiles/app.dir/external.cpp.o<br>/home/zhm/Desktop/test/extern/external.cpp:5:15: warning: ‘warming’ initialized and declared ‘extern’<br>    5 | extern double warming = 0.3;       // warming defined<br>      |               ^~~~~~~<br>[ 66%] Building CXX object CMakeFiles/app.dir/support.cpp.o<br>[100%] Linking CXX executable /home/zhm/Desktop/test/extern/bin/app<br>[100%] Built target app<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// support.cpp -- use external variable</span><br><span class="hljs-comment">// compile with external.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">double</span> warming;  <span class="hljs-comment">// use warming from another file</span><br><br><span class="hljs-comment">// function prototypes</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">double</span> dt)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">local</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">double</span> dt)</span>      <span class="hljs-comment">// modifies global variable</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">extern</span> <span class="hljs-type">double</span> warming;  <span class="hljs-comment">// optional redeclaration</span><br>    warming += dt;          <span class="hljs-comment">// uses global warming</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Updating global warming to &quot;</span> &lt;&lt; warming;<br>    cout &lt;&lt; <span class="hljs-string">&quot; degrees.\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">local</span><span class="hljs-params">()</span>                <span class="hljs-comment">// uses local variable</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> warming = <span class="hljs-number">0.8</span>;   <span class="hljs-comment">// new variable hides external one</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Local warming = &quot;</span> &lt;&lt; warming &lt;&lt; <span class="hljs-string">&quot; degrees.\n&quot;</span>;<br>        <span class="hljs-comment">// Access global variable with the</span><br>        <span class="hljs-comment">// scope resolution operator</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;But global warming = &quot;</span> &lt;&lt; ::warming;<br>    cout &lt;&lt; <span class="hljs-string">&quot; degrees.\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="作用域解析运算符"><a href="#作用域解析运算符" class="headerlink" title="作用域解析运算符"></a>作用域解析运算符</h4><p>在C++中，<code>::</code>是作用域解析运算符（scope resolution operator），用于访问全局作用域中的变量或函数，即使在局部作用域中存在同名的变量或函数时也能明确地指定要访问的是全局作用域中的那个.</p><p>在你提供的代码中，<code>::warming</code>表示访问的是全局作用域中的 <code>warming</code>变量，而不是局部作用域中可能存在的同名变量.例如，在 <code>local()</code>函数中，虽然有一个局部变量 <code>warming</code>，但通过 <code>::warming</code>可以访问到全局作用域中的 <code>warming</code>变量。</p><p>作用域解析运算符的用途：</p><ol><li><strong>访问全局变量</strong>：当局部作用域中有与全局变量同名的变量时，使用 <code>::</code>可以明确地访问全局变量.</li><li><strong>访问类的静态成员</strong>：用于访问类的静态成员变量或静态成员函数.</li><li><strong>访问命名空间中的成员</strong>：用于访问命名空间中的变量或函数，尤其是在命名空间中存在同名的局部变量时.</li></ol><p>例如，假设有一个全局变量 <code>int x = 10;</code>，在某个函数中有一个局部变量 <code>int x = 20;</code>，那么在该函数中使用 <code>x</code>会访问局部变量，而使用 <code>::x</code>则会访问全局变量.</p><h3 id="静态持续性，内部链接性"><a href="#静态持续性，内部链接性" class="headerlink" title="静态持续性，内部链接性"></a>静态持续性，内部链接性</h3><p>将static限定符用于作用域为整个文件的变量时，该变量的链接性为内部的。</p><p>链接性为内部的变量执行在其所属的文件中使用；但是常规外部变量都具有外部链接性，即可以在其他文件中使用；</p><p>static有一个非常重要的作用是，可以避免在其他文件中有相同的名称时，出现重复定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// file1</span><br><span class="hljs-type">int</span> errors = <span class="hljs-number">20</span>;<br>...<br>------------------<br><span class="hljs-comment">// file2</span><br><span class="hljs-type">int</span> errors = <span class="hljs-number">20</span>;<br>...<br></code></pre></td></tr></table></figure><p>这种情况下，程序将报错，因为违反了单定义规则，file2中的定义也创建了外部变量，因此程序将包含两个errors的两个定义。</p><p>但是如果文件定义了一个静态外部变量，其名称与另一个文件中声明的常规外部变量相同，则在该文件中，静态变量将隐藏常规外部变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// file1</span><br><span class="hljs-type">int</span> errors = <span class="hljs-number">20</span>;<br>...<br>-----------------<br><span class="hljs-comment">// file2</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> errors = <span class="hljs-number">20</span>;<br>...<br></code></pre></td></tr></table></figure><p>这样就不会违反单定义规则，因为static关键字指出标识符errors的链接性为内部。</p><h3 id="限定符和说明符"><a href="#限定符和说明符" class="headerlink" title="限定符和说明符"></a>限定符和说明符</h3><p>存储说明符：</p><ul><li>auto：C++11中不再是说明符；</li><li>register：用于在声明中指示寄存器存储，而在C++11中，它只是显式地指出变量是自动的；</li><li>static：一方面用来声明为内部链接性，另一方面用来声明为无链接性；</li><li>extern：表明为引用声明，即声明引用在其他地方定义的变量；</li><li>thread_local：用于指出变量的持续性与其所属线程的持续性相同；</li><li>mutable：用于指出，即使结构或类变量为const，其某个成员也是可以被修改的；</li></ul><h4 id="cv-限定符"><a href="#cv-限定符" class="headerlink" title="cv-限定符"></a>cv-限定符</h4><ul><li>const：表明内存被初始化后，程序不能在对它进行修改；</li><li>volatile：表明即使程序代码没有对内存单元进行修改，其值也可能发生改变（某些情况下，硬件可能修改其中的内容)</li></ul><h4 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">data</span><br>&#123;<br>   <span class="hljs-type">char</span> name[<span class="hljs-number">30</span>];<br>   <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> accesses;<br>&#125;<br><br><span class="hljs-type">const</span> data veep = &#123;<span class="hljs-string">&quot;Candy&quot;</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">strcpy</span>(veep.name, <span class="hljs-string">&quot;Joye&quot;</span>);<span class="hljs-comment">// 错误的，不被允许</span><br>veep.accesses++;<span class="hljs-comment">// 正确的，允许发生 </span><br></code></pre></td></tr></table></figure><p>veep的const限定符禁止程序修改veep的成员，但accesses成员的mutable说明符，使其不受这种限制。</p><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>在C++中，const限定符对默认存储类型有影响，即在默认情况下全局变量的链接性为外部的，但是const全局变量的链接性为内部的，即在C++看来，全局const定义就像使用了static说明符一样。</p><p>这也解释了为什么，头文件中可以存放const常量。因为内部链接性意味着，每个文件都有自己的一组常量，而不是所有文件共享同一组常量，每个定义都是所属文件私有的，这就是能够将常量定义在头文件中的原因，这样，只要在两个源代码文件中包含同一个头文件，则他们将获得同一组常量；</p><h3 id="函数和链接性"><a href="#函数和链接性" class="headerlink" title="函数和链接性"></a>函数和链接性</h3><ol><li><p>和变量一样，函数也有链接性，C++中不允许在一个函数中定义另外一个函数，因此所有的函数的存储持续性都自动为静态即在整个程序执行期间都存在；</p></li><li><p>可以使用static关键字将函数的链接性设置为内部的，使之只能在一个文件中使用，必须同时在函数原型和函数定义在中使用该关键字；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">private</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span>;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">private</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span>&#123;<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>这意味着该函数只能在这个文件中可见，还意味着可以在其他文件中定义同名的函数；</p></li><li><p>和变量一样，在定义静态函数的文件中，静态函数将覆盖外部定义；</p></li><li><p>內联函数不受单定义规则的约束，所以可以将內联函数的定义放到头文件中；</p></li></ol><h1 id="new"><a href="#new" class="headerlink" title="new"></a>new</h1><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li><p>动态内存由运算符new&#x2F;delete控制，而不是由作用域和链接性规则控制；</p></li><li><p>但是作用域和链接性的规则适用于用来跟踪动态内存的自动和静态指针变量；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">float</span> *p_free = <span class="hljs-keyword">new</span> <span class="hljs-type">float</span>[<span class="hljs-number">20</span>];<br></code></pre></td></tr></table></figure></li><li><p>由new分配的内存将一直保留在内存中，直到使用delete运算符将其释放；</p></li><li><p>但是当包含该声明的语句块执行完毕时，p_free指针将消失；</p></li><li><p>如果希望另一个函数能够使用new分配的内存中的内容，则必须将其地址传递或者返回给其他函数；</p></li><li><p>如果将p_free的链接性设置为外部的，则文件中位于该声明后面的所有函数都可以使用它，另外通过在另一个文件中使用 <code>extern float *p_free</code>的声明就可以使用该指针；</p></li></ol><h3 id="使用new初始化"><a href="#使用new初始化" class="headerlink" title="使用new初始化"></a>使用new初始化</h3><ol><li><p>内置的标量类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 括号</span><br><span class="hljs-type">int</span> *pi = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">6</span>);<span class="hljs-comment">// *pi = 6</span><br><span class="hljs-type">double</span> *pd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>(<span class="hljs-number">9.9</span>);<span class="hljs-comment">// *pd = 9.9</span><br><br><span class="hljs-comment">// 初始化列表</span><br><span class="hljs-type">int</span> *pi = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>&#123;<span class="hljs-number">6</span>&#125;;<span class="hljs-comment">// *pi = 6</span><br><span class="hljs-type">double</span> *pd = <span class="hljs-keyword">new</span> <span class="hljs-type">double</span>&#123;<span class="hljs-number">9.9</span>&#125;;<span class="hljs-comment">// *pd = 9.9</span><br></code></pre></td></tr></table></figure></li><li><p>常规结构或数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">where</span> &#123;<span class="hljs-type">double</span> x; <span class="hljs-type">double</span> y; <span class="hljs-type">double</span> z;&#125;;<br>where *one = <span class="hljs-keyword">new</span> where&#123;<span class="hljs-number">2.5</span>, <span class="hljs-number">5.3</span>, <span class="hljs-number">7.2</span>&#125;;<br><span class="hljs-type">int</span> *ar = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">4</span>]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br></code></pre></td></tr></table></figure></li></ol><p>运算符new和new[]分别对应delete和delete[];</p><h3 id="定位new运算符"><a href="#定位new运算符" class="headerlink" title="定位new运算符"></a>定位new运算符</h3><p>包含头文件：<code>#include &lt;new&gt;</code></p><p>通常，new负责在堆中找到一个足以满足要求的内存块；new还有另一种变体，被称为定位new运算符，用于指定要使用的位置；通过这种方式，可以在特定位置设置内存管理规程，处理需要通过特定地址进行访问的硬件或在特定位置创建对象；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// newplace.cpp -- using placement new</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span> <span class="hljs-comment">// for placement new</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> BUF = <span class="hljs-number">512</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">5</span>;<br><span class="hljs-type">char</span> buffer[BUF];      <span class="hljs-comment">// chunk of memory</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>    <span class="hljs-type">double</span> *pd1, *pd2;<br>    <span class="hljs-type">int</span> i;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Calling new and placement new:\n&quot;</span>;<br>    pd1 = <span class="hljs-keyword">new</span> <span class="hljs-type">double</span>[N];           <span class="hljs-comment">// use heap</span><br>    pd2 = <span class="hljs-built_in">new</span> (buffer) <span class="hljs-type">double</span>[N];  <span class="hljs-comment">// use buffer array</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>        pd2[i] = pd1[i] = <span class="hljs-number">1000</span> + <span class="hljs-number">20.0</span> * i;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Memory addresses:\n&quot;</span> &lt;&lt; <span class="hljs-string">&quot;  heap: &quot;</span> &lt;&lt; pd1<br>        &lt;&lt; <span class="hljs-string">&quot;  static: &quot;</span> &lt;&lt;  (<span class="hljs-type">void</span> *) buffer  &lt;&lt;endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Memory contents:\n&quot;</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    &#123;<br>        cout &lt;&lt; pd1[i] &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; &amp;pd1[i] &lt;&lt; <span class="hljs-string">&quot;; &quot;</span>;<br>        cout &lt;&lt; pd2[i] &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; &amp;pd2[i] &lt;&lt; endl;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\nCalling new and placement new a second time:\n&quot;</span>;<br>    <span class="hljs-type">double</span> *pd3, *pd4;<br>    pd3= <span class="hljs-keyword">new</span> <span class="hljs-type">double</span>[N];            <span class="hljs-comment">// find new address</span><br>    pd4 = <span class="hljs-built_in">new</span> (buffer) <span class="hljs-type">double</span>[N];  <span class="hljs-comment">// overwrite old data</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>        pd4[i] = pd3[i] = <span class="hljs-number">1000</span> + <span class="hljs-number">40.0</span> * i;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Memory contents:\n&quot;</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    &#123;<br>        cout &lt;&lt; pd3[i] &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; &amp;pd3[i] &lt;&lt; <span class="hljs-string">&quot;; &quot;</span>;<br>        cout &lt;&lt; pd4[i] &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; &amp;pd4[i] &lt;&lt; endl;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;\nCalling new and placement new a third time:\n&quot;</span>;<br>    <span class="hljs-keyword">delete</span> [] pd1;<br>    pd1= <span class="hljs-keyword">new</span> <span class="hljs-type">double</span>[N];<br>    pd2 = <span class="hljs-built_in">new</span> (buffer + N * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>)) <span class="hljs-type">double</span>[N]; <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>        pd2[i] = pd1[i] = <span class="hljs-number">1000</span> + <span class="hljs-number">60.0</span> * i;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Memory contents:\n&quot;</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    &#123;<br>        cout &lt;&lt; pd1[i] &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; &amp;pd1[i] &lt;&lt; <span class="hljs-string">&quot;; &quot;</span>;<br>        cout &lt;&lt; pd2[i] &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; &amp;pd2[i] &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">delete</span> [] pd1;<br>    <span class="hljs-keyword">delete</span> [] pd3;<br>    <span class="hljs-comment">// cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./app<br>Calling new and placement new:<br>Memory addresses:<br>  heap: 0x5b00d966b6c0  static: 0x5b00d7fc0160<br>Memory contents:<br>1000 at 0x5b00d966b6c0; 1000 at 0x5b00d7fc0160<br>1020 at 0x5b00d966b6c8; 1020 at 0x5b00d7fc0168<br>1040 at 0x5b00d966b6d0; 1040 at 0x5b00d7fc0170<br>1060 at 0x5b00d966b6d8; 1060 at 0x5b00d7fc0178<br>1080 at 0x5b00d966b6e0; 1080 at 0x5b00d7fc0180<br><br>Calling new and placement new a second <span class="hljs-keyword">time</span>:<br>Memory contents:<br>1000 at 0x5b00d966b6f0; 1000 at 0x5b00d7fc0160<br>1040 at 0x5b00d966b6f8; 1040 at 0x5b00d7fc0168<br>1080 at 0x5b00d966b700; 1080 at 0x5b00d7fc0170<br>1120 at 0x5b00d966b708; 1120 at 0x5b00d7fc0178<br>1160 at 0x5b00d966b710; 1160 at 0x5b00d7fc0180<br><br>Calling new and placement new a third <span class="hljs-keyword">time</span>:<br>Memory contents:<br>1000 at 0x5b00d966b6c0; 1000 at 0x5b00d7fc0188<br>1060 at 0x5b00d966b6c8; 1060 at 0x5b00d7fc0190<br>1120 at 0x5b00d966b6d0; 1120 at 0x5b00d7fc0198<br>1180 at 0x5b00d966b6d8; 1180 at 0x5b00d7fc01a0<br>1240 at 0x5b00d966b6e0; 1240 at 0x5b00d7fc01a8<br></code></pre></td></tr></table></figure><ol><li>定位new运算符把p2放在了数组buffer中，pd2和buffer的地址相同，但是他们两个类型不同，pd2是double指针，buffer是char指针，这也是为什么程序中使用(void*)对buffer进行强制转换；</li><li>当再次使用定位new运算符指向相同的内存时，它会覆盖上一次的数据，所以定位new运算符不跟踪哪些内存已被使用，也不查找未使用的内存块；</li><li>程序中没有使用delete来释放使用定位new运算符分配的内存，因为在这个示例代码中buffer指定的内存是静态内存，而delete只能作用于常规new运算符分配的堆内存；</li><li>如果buffer是使用常规的new运算符创建的，那么也可以使用常规delete运算符来释放整个内存块；</li></ol><h1 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h1><p>名称可以是变量，函数，结构，枚举，类，类和结构的成员。例如，两个库可能都定义了a,b,c的类，但是定义的方式不兼容，用户可能希望使用一个库的a，另一个库的b，这种冲突被称为名称空间问题；</p><h3 id="using声明和using编译"><a href="#using声明和using编译" class="headerlink" title="using声明和using编译"></a>using声明和using编译</h3><h4 id="using声明"><a href="#using声明" class="headerlink" title="using声明"></a>using声明</h4><ul><li><strong>作用</strong>：<code>using</code>声明用于将一个或多个特定的名称从命名空间中引入到当前作用域中。</li><li><strong>语法</strong>：<code>using namespace_name::identifier;</code></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br></code></pre></td></tr></table></figure></li><li><strong>效果</strong>：在上述示例中，<code>cout</code>和 <code>endl</code>被直接引入到当前作用域中，可以在不加 <code>std::</code>前缀的情况下直接使用它们。</li><li><strong>适用场景</strong>：当你只需要从命名空间中使用少量的名称时，使用 <code>using</code>声明是更好的选择，因为它可以避免命名冲突。</li></ul><h4 id="using编译指令"><a href="#using编译指令" class="headerlink" title="using编译指令"></a>using编译指令</h4><ul><li><strong>作用</strong>：<code>using</code>编译指令用于将整个命名空间中的所有名称引入到当前作用域中。</li><li><strong>语法</strong>：<code>using namespace namespace_name;</code></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure></li><li><strong>效果</strong>：在上述示例中，<code>std</code>命名空间中的所有名称都被引入到当前作用域中，可以在不加 <code>std::</code>前缀的情况下直接使用它们。</li><li><strong>适用场景</strong>：当你需要频繁地使用某个命名空间中的多个名称时，使用 <code>using</code>编译指令可以减少代码的冗余。然而，过度使用可能会导致命名冲突和代码可读性降低。</li></ul><h4 id="引用命名空间内的标识符"><a href="#引用命名空间内的标识符" class="headerlink" title="引用命名空间内的标识符"></a>引用命名空间内的标识符</h4><p>当引用的标识符不在当前命名空间或全局命名空间内时，有三种方式可以引用该标识符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 方式一</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span>;<br><br><span class="hljs-comment">// 方式二</span><br><span class="hljs-keyword">using</span> std::cout;<br>cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span>;<br><br><span class="hljs-comment">// 方式三</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span>;<br></code></pre></td></tr></table></figure><p>方式一只在必要的时候通过域运算符 <code>::</code>引用指定命令空间内的标识符，适用于当前编译单元引用std内的标识符不多，而且编译单元内使用这些标识符的次数也不多的情况。</p><p>方式二只引入std::cout一个标识符，如果在当前编译单元内使用std::cout次数较多，而且不会与当前命名空间内的标识符冲突，建议使用这种方式。</p><p>方式三是把std命名空间中的全部标识符都引入到当前命名空间中，此后std所有的标识符对于当前命名空间都是可见的，这会提高标识符冲突的危险。如果当前编译单元用到std命令空间内的标识符较多，而且不会出现标识符冲突的问题，可以使用这种方式，以减少字符的输入。</p><h3 id="命名空间的别名"><a href="#命名空间的别名" class="headerlink" title="命名空间的别名"></a>命名空间的别名</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> mvft = my_very_favorite_thing;<br></code></pre></td></tr></table></figure><h3 id="匿名命名空间"><a href="#匿名命名空间" class="headerlink" title="匿名命名空间"></a>匿名命名空间</h3><p>在匿名命名空间中声明的名称也将被编译器转换，与编译器为这个匿名命名空间生成的唯一内部名称(即这里的__UNIQUE_NAME_)绑定在一起。还有一点很重要，就是这些名称具有internal链接属性，这和声明为static的全局名称的链接属性是相同的，即名称的作用域被限制在当前文件中，无法通过在另外的文件中使用extern声明来进行链接。</p><p>相对于C的static声明来说，可以在匿名的空间里面声明很多变量和函数,这样可以省去了对每个变量和函数添加static声明。实质上匿名空间的功能跟static声明是一样的。</p><p>还有一个好处是，命名空间是可以嵌套的。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// namesp.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-comment">// create the pers and debts namespaces</span><br><span class="hljs-keyword">namespace</span> pers<br>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span><br>    &#123; <br>        std::string fname;<br>        std::string lname;<br>     &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPerson</span><span class="hljs-params">(Person &amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">(<span class="hljs-type">const</span> Person &amp;)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> debts<br>&#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> pers;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Debt</span><br>    &#123;<br>        Person name;<br>        <span class="hljs-type">double</span> amount;<br>    &#125;;<br>  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getDebt</span><span class="hljs-params">(Debt &amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showDebt</span><span class="hljs-params">(<span class="hljs-type">const</span> Debt &amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sumDebts</span><span class="hljs-params">(<span class="hljs-type">const</span> Debt ar[], <span class="hljs-type">int</span> n)</span></span>; <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// namesp.cpp -- namespaces</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;namesp.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> pers<br>&#123;<br>    <span class="hljs-keyword">using</span> std::cout;<br>    <span class="hljs-keyword">using</span> std::cin;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPerson</span><span class="hljs-params">(Person &amp; rp)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Enter first name: &quot;</span>;<br>        cin &gt;&gt; rp.fname;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Enter last name: &quot;</span>;<br>        cin &gt;&gt; rp.lname;<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">(<span class="hljs-type">const</span> Person &amp; rp)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; rp.lname &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; rp.fname;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> debts<br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getDebt</span><span class="hljs-params">(Debt &amp; rd)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">getPerson</span>(rd.name);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Enter debt: &quot;</span>;<br>        std::cin &gt;&gt; rd.amount;<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showDebt</span><span class="hljs-params">(<span class="hljs-type">const</span> Debt &amp; rd)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">showPerson</span>(rd.name);<br>        std::cout &lt;&lt;<span class="hljs-string">&quot;: $&quot;</span> &lt;&lt; rd.amount &lt;&lt; std::endl;<br>    &#125;<br>  <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sumDebts</span><span class="hljs-params">(<span class="hljs-type">const</span> Debt ar[], <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">double</span> total = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            total += ar[i].amount;<br>        <span class="hljs-keyword">return</span> total;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在命名空间中声明的函数名作用于整个空间，因此定义和声明必须位于同一个名称空间中；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// usenmsp.cpp -- using namespaces</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;namesp.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">other</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">another</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> debts::Debt;<br><span class="hljs-keyword">using</span> debts::showDebt;<br>    Debt golf = &#123; &#123;<span class="hljs-string">&quot;Benny&quot;</span>, <span class="hljs-string">&quot;Goatsniff&quot;</span>&#125;, <span class="hljs-number">120.0</span> &#125;;<br>    <span class="hljs-built_in">showDebt</span>(golf);<br>    <span class="hljs-built_in">other</span>();<br>    <span class="hljs-built_in">another</span>(); <br><span class="hljs-comment">// std::cin.get();</span><br><span class="hljs-comment">// std::cin.get();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">other</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::cout;<br>    <span class="hljs-keyword">using</span> std::endl;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> debts;<br>    Person dg = &#123;<span class="hljs-string">&quot;Doodles&quot;</span>, <span class="hljs-string">&quot;Glister&quot;</span>&#125;;<br>    <span class="hljs-built_in">showPerson</span>(dg);<br>    cout &lt;&lt; endl;<br>    Debt zippy[<span class="hljs-number">3</span>];<br>    <span class="hljs-type">int</span> i;<br>  <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>        <span class="hljs-built_in">getDebt</span>(zippy[i]);<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>        <span class="hljs-built_in">showDebt</span>(zippy[i]);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Total debt: $&quot;</span> &lt;&lt; <span class="hljs-built_in">sumDebts</span>(zippy, <span class="hljs-number">3</span>) &lt;&lt; endl;<br>  <br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">another</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> pers::Person;;<br>  <br>    Person collector = &#123; <span class="hljs-string">&quot;Milo&quot;</span>, <span class="hljs-string">&quot;Rightshift&quot;</span> &#125;;<br>    pers::<span class="hljs-built_in">showPerson</span>(collector);<br>    std::cout &lt;&lt; std::endl; <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cpp-6-智能指针</title>
    <link href="/2025/02/22/Cpp/cpp-6/"/>
    <url>/2025/02/22/Cpp/cpp-6/</url>
    
    <content type="html"><![CDATA[<ol><li>智能指针模板类</li></ol><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><ol><li>auto_ptr</li><li>unique_ptr</li><li>shared_ptr</li></ol><p>以上三个智能指针模板都定义了类似指针的对象，可以将new获得的地址赋给这些对象。当智能指针过期的时候，其析构函数将使用delete来释放内存。</p><p>使用时可以将每一个智能指针都放在一个代码块内，这样当离开代码的时候，指针将过期，申请的内存也会被自动释放。</p><p>所有的智能指针都有一个explicit构造函数，该构造函数将指针作为参数，因此不需要自动将指针转换为智能指针对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">shared_ptr&lt;<span class="hljs-type">double</span>&gt; pd;<br><span class="hljs-type">double</span> *p_reg = <span class="hljs-keyword">new</span> <span class="hljs-type">double</span>;<br>pd = p_reg;<span class="hljs-comment">// 错误</span><br>pd = <span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-type">double</span>&gt;(p_reg);<span class="hljs-comment">// 正确</span><br>shared_ptr&lt;<span class="hljs-type">double</span>&gt; pshared = p_reg;<span class="hljs-comment">// 错误</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">pshared</span><span class="hljs-params">(p_reg)</span></span>;<span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><p>智能指针对象的很多方面都类似于常规指针：</p><ul><li>可以对其执行解除引用操作(*p)</li><li>可以用它来访问结构成员(p-&gt;name)</li><li>将它赋值给指向相同类型的常规指针</li><li>可以将智能指针对象赋值给另一个同类型的智能指针对象</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">ps</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I reigned by lonely as a cloud.&quot;</span>))</span></span>;<br>auto_ptr&lt;string&gt; vocation;<br>vocation = ps;<br></code></pre></td></tr></table></figure><p>如果ps和vocation是常规指针，则两个指针将指向同一个string对象。如果是使用智能指针将会出现严重的问题，即一块内存被释放了两次，一次是ps过期的时候，另一次是vocation过期的时候。</p><p>解决办法：</p><ul><li>定义赋值运算符，使之执行深复制。这样两个指针将指向不同的对象，其中一个对象是另一个对象的副本；</li><li>建立所有权。对于特定的对象，只能有一个智能指针可以拥有它，这样拥有对象的智能指针的构造函数会删除该对象。然后让赋值操作转让所有权。unique_ptr策略；</li><li>创建智能更高的指针，跟踪引用特定对象的智能指针数。称为引用计数，仅当最后一个指针过期时，才调用delete，shared_ptr策略；</li></ul><h2 id="unique-ptr与auto-ptr比较"><a href="#unique-ptr与auto-ptr比较" class="headerlink" title="unique_ptr与auto_ptr比较"></a>unique_ptr与auto_ptr比较</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;auto&quot;</span>))</span></span>;<span class="hljs-comment">// #1</span><br>auto_ptr&lt;string&gt; p2;<span class="hljs-comment">// #2</span><br>p2 = p1;<span class="hljs-comment">// #3</span><br></code></pre></td></tr></table></figure><p>在语句#3中，p2接管string对象的所有权后，p1的所有权将被剥夺，按理说这应该是一件好事，可以防止p1和p2的析构函数试图删除同一个对象；但是如果程序随后试图使用p1，这将是一个坏事，因为p1不再指向有效的数据；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;auto&quot;</span>))</span></span>;<span class="hljs-comment">// #4</span><br>unique_ptr&lt;string&gt; p4;<span class="hljs-comment">// #5</span><br>p4 = p3;<span class="hljs-comment">// #6</span><br></code></pre></td></tr></table></figure><p>在使用unique_ptr的时候，这将是不允许的，编译器认为#6语法错误，避免了p3不再指向有效数据的问题。</p><p>因此，unique_ptr比auto_ptr更安全。</p>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>std::ios_base格式化标志和精度设置</title>
    <link href="/2025/02/22/Cpp/ios_base/"/>
    <url>/2025/02/22/Cpp/ios_base/</url>
    
    <content type="html"><![CDATA[<ol><li>cout.setf</li><li>cout.precision</li></ol><span id="more"></span><p>std::ios_base提供了一系列格式化标志，可以用于控制输出的格式，这些格式可以用setf和unsetf方法设置和清除；</p><h4 id="常见的格式化标志"><a href="#常见的格式化标志" class="headerlink" title="常见的格式化标志"></a>常见的格式化标志</h4><ul><li><strong><code>std::ios_base::dec</code></strong> ：十进制格式（默认）。</li><li><strong><code>std::ios_base::hex</code></strong> ：十六进制格式。</li><li><strong><code>std::ios_base::oct</code></strong> ：八进制格式。</li><li><strong><code>std::ios_base::fixed</code></strong> ：固定小数点格式。</li><li><strong><code>std::ios_base::scientific</code></strong> ：科学计数法格式。</li><li><strong><code>std::ios_base::left</code></strong> ：左对齐。</li><li><strong><code>std::ios_base::right</code></strong> ：右对齐（默认）。</li><li><strong><code>std::ios_base::internal</code></strong> ：内部对齐，用于数值的符号或基数前缀。</li><li><strong><code>std::ios_base::boolalpha</code></strong> ：布尔值以 <code>true</code> 和 <code>false</code> 输出。</li><li><strong><code>std::ios_base::noboolalpha</code></strong> ：布尔值以 <code>1</code> 和 <code>0</code> 输出。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">15</span>;<br><br>    <span class="hljs-comment">// 设置为十六进制格式</span><br>    std::cout &lt;&lt; std::hex &lt;&lt; value &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: f</span><br><br>    <span class="hljs-comment">// 恢复为十进制格式</span><br>    std::cout &lt;&lt; std::dec &lt;&lt; value &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 15</span><br><br>    <span class="hljs-comment">// 设置为固定小数点格式</span><br>    <span class="hljs-type">double</span> pi = <span class="hljs-number">3.14159265358979323846</span>;<br>    std::cout &lt;&lt; std::fixed &lt;&lt; pi &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 3.141593</span><br><br>    <span class="hljs-comment">// 设置为科学计数法格式</span><br>    std::cout &lt;&lt; std::scientific &lt;&lt; pi &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 3.141593e+00</span><br><br>    <span class="hljs-comment">// 左对齐</span><br>    std::cout &lt;&lt; std::left &lt;&lt; std::<span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; value &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 15        |</span><br><br>    <span class="hljs-comment">// 右对齐</span><br>    std::cout &lt;&lt; std::right &lt;&lt; std::<span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; value &lt;&lt; std::endl;  <span class="hljs-comment">// 输出:        15|</span><br><br>    <span class="hljs-comment">// 布尔值输出</span><br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    std::cout &lt;&lt; std::boolalpha &lt;&lt; flag &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: true</span><br>    std::cout &lt;&lt; std::noboolalpha &lt;&lt; flag &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 1</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="精度设置"><a href="#精度设置" class="headerlink" title="精度设置"></a>精度设置</h4><p>精度设置用于控制浮点数输出的小数位数，可以使用std::setprecision操作符来设置精度；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span>  <span class="hljs-comment">// 包含 setprecision</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> pi = <span class="hljs-number">3.14159265358979323846</span>;<br><br>    <span class="hljs-comment">// 设置精度为 3 位小数</span><br>    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">3</span>) &lt;&lt; pi &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 3.142</span><br><br>    <span class="hljs-comment">// 设置精度为 5 位小数</span><br>    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">5</span>) &lt;&lt; pi &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 3.14159</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="宽度设置"><a href="#宽度设置" class="headerlink" title="宽度设置"></a>宽度设置</h4><p>宽度设置用于控制输出字段的宽度，可以使用std::setw操作符来设置宽度；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span>  <span class="hljs-comment">// 包含 setw</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">15</span>;<br><br>    <span class="hljs-comment">// 设置字段宽度为 10</span><br>    std::cout &lt;&lt; std::<span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; value &lt;&lt; std::endl;  <span class="hljs-comment">// 输出:        15</span><br><br>    <span class="hljs-comment">// 左对齐，字段宽度为 10</span><br>    std::cout &lt;&lt; std::left &lt;&lt; std::<span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; value &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 15        |</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="填充字符设置"><a href="#填充字符设置" class="headerlink" title="填充字符设置"></a>填充字符设置</h4><p>填充字符设置用于控制输出字段的填充字符，可以使用std::setfill操作符来设置填充字符；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span>  <span class="hljs-comment">// 包含 setfill</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">15</span>;<br><br>    <span class="hljs-comment">// 设置字段宽度为 10，填充字符为 &#x27;*&#x27;</span><br>    std::cout &lt;&lt; std::<span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; std::<span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;*&#x27;</span>) &lt;&lt; value &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: *****15</span><br><br>    <span class="hljs-comment">// 左对齐，字段宽度为 10，填充字符为 &#x27;*&#x27;</span><br>    std::cout &lt;&lt; std::left &lt;&lt; std::<span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; std::<span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;*&#x27;</span>) &lt;&lt; value &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 15********</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="保存和恢复格式状态"><a href="#保存和恢复格式状态" class="headerlink" title="保存和恢复格式状态"></a>保存和恢复格式状态</h4><p>某些情况下，需要保存当前的格式状态，进行一些特定的格式化输出，然后再恢复原来的格式状态，可以使用std::ios_base::fmtflags和std::streamsize来保存和恢复格式状态；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::ios_base;<br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::setprecision;<br><span class="hljs-keyword">using</span> std::fixed;<br><br><span class="hljs-comment">// 保存当前格式状态</span><br><span class="hljs-function">ios_base::fmtflags <span class="hljs-title">saveFormat</span><span class="hljs-params">(cout.flags())</span></span>;<br><span class="hljs-function">std::streamsize <span class="hljs-title">savePrec</span><span class="hljs-params">(cout.precision())</span></span>;<br><br><span class="hljs-comment">// 设置新的格式</span><br>cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 进行一些输出</span><br><span class="hljs-type">double</span> pi = <span class="hljs-number">3.14159265358979323846</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Pi: &quot;</span> &lt;&lt; pi &lt;&lt; endl;<br><br><span class="hljs-comment">// 恢复原来的格式</span><br>cout.<span class="hljs-built_in">flags</span>(saveFormat);<br>cout.<span class="hljs-built_in">precision</span>(savePrec);<br><br><span class="hljs-comment">// 再次进行一些输出</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Pi: &quot;</span> &lt;&lt; pi &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>is-a</title>
    <link href="/2025/02/22/Cpp/is-a/"/>
    <url>/2025/02/22/Cpp/is-a/</url>
    
    <content type="html"><![CDATA[<ol><li>is-a</li><li>has-a</li><li>uses-a</li><li>is-implemented-as-a</li></ol><span id="more"></span><h2 id="什么是is-a"><a href="#什么是is-a" class="headerlink" title="什么是is-a"></a>什么是is-a</h2><p>is-a表面意思就是“是”，例如“B is an A”表示“B是一个A”，在C++中它描述的是不同类之间的关系。它描述的是一种继承关系，B is-a A有两层含义：</p><ul><li>B是A的一种</li><li>反过来，A并不是B</li></ul><p>举一个例子就是，香蕉is-a水果，香蕉是水果，但是不能说水果是香蕉。他们之间的关系是一种继承关系，香蕉继承了水果的所有性质，但是香蕉又有它自己独特的性质。</p><p>has-a表面意思是“有”，例如“B has an A”表示“B中有A”，他表示的是一种组合关系，他们自己之间是一种组合关系，B中有A表示的是一种包含和被包含的关系，所以B掌控着A的生死，在has-a这种关系中，A其实是依托于B才得以存在的，这么说可能会有点抽象，因为A本身也是一个独立的存在，为什么说A依托B才得以存在？举个例子，午饭中有水果。</p><ul><li>要先有午饭，才会有午饭中有水果</li></ul><p>uses-a表面意思是“用”，“用”不需要拥有，比如文档需要借助打印机来打印，并不是说这个文档就拥有打印机，打印机并不是文档的一部分，我们提交一份文档也并不是连着打印机一起提交。下面是uses-a的示例代码（为了突出uses-a，把其中一个类的对象定义为了全局变量）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 打印机类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Printer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; content)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Printing: &quot;</span> &lt;&lt; content &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 全局打印机对象，Document uses-a Printer</span><br>Printer printer;<br><br><span class="hljs-comment">// 文档类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Document</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printDocument</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; content)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用全局打印机对象printer打印内容</span><br>        printer.<span class="hljs-built_in">print</span>(content);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Document doc;<br>    doc.<span class="hljs-built_in">printDocument</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="以下是ChatGPT的回答"><a href="#以下是ChatGPT的回答" class="headerlink" title="以下是ChatGPT的回答"></a>以下是ChatGPT的回答</h2><h3 id="1-is-a-关系（继承关系）"><a href="#1-is-a-关系（继承关系）" class="headerlink" title="1. is-a 关系（继承关系）"></a>1. <code>is-a</code> 关系（继承关系）</h3><p><code>is-a</code>关系表示一种继承关系，即一个类是另一个类的特化。在面向对象编程中，这种关系通常通过类继承来实现。如果类A是类B的特化，那么A的每个实例都可以被视为B的实例，即A具有B的所有属性和行为。</p><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bark</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;;<br><br><span class="hljs-comment">// Dog是Animal的特化，所以Dog具有Animal的行为</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：<code>is-a</code>关系是多态性的基础，允许代码通过基类指针或引用来操作派生类对象，实现动态绑定。</p><h3 id="2-has-a-关系（组合关系）"><a href="#2-has-a-关系（组合关系）" class="headerlink" title="2. has-a 关系（组合关系）"></a>2. <code>has-a</code> 关系（组合关系）</h3><p><code>has-a</code>关系表示一个类包含另一个类的实例作为其成员，即一个类的对象拥有另一个类的对象。这种关系通过对象的组合来实现，不涉及继承。</p><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    Engine engine;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">drive</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* 使用engine对象 ... */</span> &#125;<br>&#125;;<br><br><span class="hljs-comment">// Car有一个Engine对象，所以Car has-a Engine</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：<code>has-a</code>关系强调的是对象之间的组合关系，而不是继承关系。</p><h3 id="3-uses-a-关系（依赖关系）"><a href="#3-uses-a-关系（依赖关系）" class="headerlink" title="3. uses-a 关系（依赖关系）"></a>3. <code>uses-a</code> 关系（依赖关系）</h3><p><code>uses-a</code>关系表示一个类在其方法中使用另一个类的对象，但并不包含另一个类的对象作为其成员。这种关系是一种弱耦合关系，通常通过方法参数或局部变量来实现。</p><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; message)</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        Logger logger;<br>        logger.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Application is running&quot;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Application在其方法中使用Logger，所以Application uses-a Logger</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：<code>uses-a</code>关系强调的是类之间的依赖关系，一个类的方法可能依赖于另一个类的功能。</p><h3 id="4-is-implemented-as-a-关系（实现关系）"><a href="#4-is-implemented-as-a-关系（实现关系）" class="headerlink" title="4. is-implemented-as-a 关系（实现关系）"></a>4. <code>is-implemented-as-a</code> 关系（实现关系）</h3><p><code>is-implemented-as-a</code>关系表示一个类或接口是通过另一个类或接口来实现的。这种关系通常用于接口实现，其中一个类实现了一个或多个接口。</p><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IDrawable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> IDrawable &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;;<br><br><span class="hljs-comment">// Circle实现了IDrawable接口，所以Circle is-implemented-as-a IDrawable</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：<code>is-implemented-as-a</code>关系强调的是实现细节，一个类实现了接口或抽象类的具体功能。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>cpp-1</title>
    <link href="/2025/02/22/Cpp/cpp-1/"/>
    <url>/2025/02/22/Cpp/cpp-1/</url>
    
    <content type="html"><![CDATA[<h1 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h1><p>explicit关键字是一个类修饰符，用于修饰构造函数或转换操作符，以防止类的构造函数或转换操作符进行隐式类型转换。</p><span id="more"></span><h2 id="修饰构造函数"><a href="#修饰构造函数" class="headerlink" title="修饰构造函数"></a>修饰构造函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">MyClass</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> : value_(value) &#123;</span>&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass myObject = <span class="hljs-number">5</span>; <span class="hljs-comment">// 错误：隐式转换</span><br>    <span class="hljs-function">MyClass <span class="hljs-title">myObject2</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 正确：显式构造</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="修饰转换操作符"><a href="#修饰转换操作符" class="headerlink" title="修饰转换操作符"></a>修饰转换操作符</h2><ol><li>类可以定义自己的转换操作符，并使用explicit关键字防止</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> value_; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass myObject;<br>    <span class="hljs-type">int</span> value = myObject; <span class="hljs-comment">// 错误：隐式转换</span><br>    <span class="hljs-type">int</span> value2 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(myObject); <span class="hljs-comment">// 正确：显式转换</span><br>&#125;<br></code></pre></td></tr></table></figure><p>MyClass定义了一个转换为int的转换操作符，并将其声明为explicit，因此只能通过显示类型转换来获取int类型的值。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>explicit关键字只能用于单个参数的构造函数或转换操作符；</li><li>如果构造函数或转换操作符只有一个参数，并且该参数是类类型或引用类型，则explicit关键字是不必要的，因为这种情况下编译器不会进行隐式类型转换。</li></ol><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>static关键字主要用于控制变量和函数的生命周期，作用域以及访问权限。</p><h2 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h2><ol><li>在函数内部使用static关键字修饰的变量称为静态局部变量；</li><li>静态局部变量在程序的整个生命周期内存在，不会因为离开作用域而被销毁；</li><li>其值会在下一次函数调用时保持；</li><li>静态局部变量只在声明它的函数内部可见；</li><li>静态局部变量默认初始化为0；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    count++;<br>    std::cout&lt;&lt;count&lt;&lt;std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;**&quot;</span>&lt;&lt;count&lt;&lt;<span class="hljs-string">&quot;**&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">func</span>();<br>    &#125;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;**&quot;</span>&lt;&lt;count&lt;&lt;<span class="hljs-string">&quot;**&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">zhm@Ubuntu:~/Desktop/test/static$ ./app <br>**0**<br>1<br>2<br>3<br>4<br>5<br>**0**<br></code></pre></td></tr></table></figure><h2 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h2><ol><li>在文件作用于声明的静态全局变量只在声明它的文件内可见，不能被其他文件访问；</li></ol><h2 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h2><h3 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h3><ol><li>在类中声明的静态成员变量属于类本身，而不是类的任何对象；</li><li>所有类的对象共享同一个静态成员变量的副本；</li><li>静态成员变量必须在类外部单独定义，以便为其分配存储空间。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVar;<br>&#125;;<br><br><span class="hljs-type">int</span> MyClass::staticVar = <span class="hljs-number">0</span>; <span class="hljs-comment">// 在类外部初始化</span><br></code></pre></td></tr></table></figure><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><ol><li>在类中使用static关键字修饰的成员函数是静态成员函数；</li><li>静态成员函数不能直接访问非静态成员变量或非静态成员函数；</li><li>静态成员函数可以通过类名调用，而不需要创建类的实例。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">staticFunc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 静态成员函数的实现</span><br>    &#125;<br>&#125;;<br><br>MyClass::<span class="hljs-built_in">staticFunc</span>(); <span class="hljs-comment">// 直接通过类名调用</span><br></code></pre></td></tr></table></figure><h3 id="静态常量成员变量"><a href="#静态常量成员变量" class="headerlink" title="静态常量成员变量"></a>静态常量成员变量</h3><ol><li>在类中声明的静态常量成员变量可以在类内部初始化，不需要在类外单独初始化。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> constVar = <span class="hljs-number">10</span>; <span class="hljs-comment">// 在类内部初始化</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ol><li>在C++11及以后版本，static关键字可以与thread_local一起使用，声明线程局部存储的静态变量；</li><li>每个线程都会拥有该变量的一个独立副本。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">thread_local</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> threadVar = <span class="hljs-number">0</span>; <span class="hljs-comment">// 每个线程都有自己的 threadVar 副本</span><br></code></pre></td></tr></table></figure><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><ol><li>reinterpret</li><li>const_case</li><li>static_case</li><li>dynamic_case</li></ol><h2 id="reinterpret"><a href="#reinterpret" class="headerlink" title="reinterpret"></a>reinterpret</h2><ol><li>用于指针或引用之间进行转换，或者将指针转换为足够大的整数类型；</li><li>可以将整型转换为指针，也可以把指针转换为数组；</li><li>可以在指针和引用里随意转换，不进行检查；</li><li>平台移植性比较差。</li></ol><ul><li><p>指针类型转换：将一个指针类型转换为另一个指针类型；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span>* intPtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;**&quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(intPtr)&lt;&lt;<span class="hljs-string">&quot;:&quot;</span>&lt;&lt;intPtr&lt;&lt;<span class="hljs-string">&quot;**&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-type">char</span>* charPtr = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(intPtr);<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;**&quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(intPtr)&lt;&lt;<span class="hljs-string">&quot;:&quot;</span>&lt;&lt;<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(charPtr)&lt;&lt;<span class="hljs-string">&quot;**&quot;</span>&lt;&lt;std::endl;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;**&quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(intPtr)&lt;&lt;<span class="hljs-string">&quot;:&quot;</span>&lt;&lt;*charPtr&lt;&lt;<span class="hljs-string">&quot;**&quot;</span>&lt;&lt;std::endl;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;**&quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(intPtr)&lt;&lt;<span class="hljs-string">&quot;:&quot;</span>&lt;&lt;charPtr&lt;&lt;<span class="hljs-string">&quot;**&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>输出：<br>$ ./app <br>**<span class="hljs-number">8</span>:<span class="hljs-number">0x62143fa4f2b0</span>**<br>**<span class="hljs-number">8</span>:<span class="hljs-number">0x62143fa4f2b0</span>**<br>**<span class="hljs-number">8</span>:<br>**<br>**<span class="hljs-number">8</span>:<br>**<br></code></pre></td></tr></table></figure><ul><li>charPtr是通过reinterpret_cast从intPtr转换来的，指向一个整数10的内存地址；</li><li>当尝试输出charPtr时，std::cout会尝试将其作为字符串来输出，由于intPtr指向的内存并不是一个以空字符结尾的字符串，所以std::cout无法正确输出字符串的内容，导致输出为空或者乱码；</li><li>如果想要输出charPtr的地址而不是它指向的内容，需要显示地将其转换为 <code>void*</code>类型，因为std::cout会以16进制输出 <code>void*</code>类型的指针地址；</li></ul></li><li><p>指针到整型的转换：将指针转换为整数类型，通常用于指针的数值表示;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span>* intPtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;**&quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(intPtr)&lt;&lt;<span class="hljs-string">&quot;:&quot;</span>&lt;&lt;intPtr&lt;&lt;<span class="hljs-string">&quot;**&quot;</span>&lt;&lt;std::endl;<br><br>    <span class="hljs-type">long</span> ptrValue = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">long</span>&gt;(intPtr);<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;**&quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(ptrValue)&lt;&lt;<span class="hljs-string">&quot;:0x&quot;</span>&lt;&lt;std::hex&lt;&lt;ptrValue&lt;&lt;<span class="hljs-string">&quot;**&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>输出结果：<br>$ ./app <br>**<span class="hljs-number">8</span>:<span class="hljs-number">0x5b06cb0fe2b0</span>**<br>**<span class="hljs-number">8</span>:<span class="hljs-number">0x5b06cb0fe2b0</span>**<br></code></pre></td></tr></table></figure></li><li><p>整型到指针的转换：将整数转换回指针类型，前提是该整数是之前从指针转换来的；</p></li></ul><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><ol><li>const_cast用于移除或添加const和volatile属性，而不改变指针或引用的类型；</li><li>常量指针转换为非常量指针，并且仍然指向原来的对象；</li><li>常量引用转换为非常量引用，并且仍然指向原来的对象；</li><li>主要用于在需要修改常数数据的情况下进行转换；</li></ol><ul><li><p>移除const属性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>* constIntPtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;**&quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(constIntPtr)&lt;&lt;<span class="hljs-string">&quot;:&quot;</span>&lt;&lt;*constIntPtr&lt;&lt;<span class="hljs-string">&quot;**&quot;</span>&lt;&lt;std::endl;<br><br>    <span class="hljs-type">int</span>* intPtr = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span>*&gt;(constIntPtr);<br>    *intPtr = <span class="hljs-number">20</span>;<br><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;**&quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(intPtr)&lt;&lt;<span class="hljs-string">&quot;:&quot;</span>&lt;&lt;*intPtr&lt;&lt;<span class="hljs-string">&quot;**&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>编译运行：<br>$ ./app <br>**<span class="hljs-number">8</span>:<span class="hljs-number">10</span>**<br>**<span class="hljs-number">8</span>:<span class="hljs-number">20</span>**<br></code></pre></td></tr></table></figure></li><li><p>添加const属性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* intPtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* constIntPtr = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span>*&gt;(intPtr); <span class="hljs-comment">// 添加 const 属性</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><ol><li>用于基本数据类型之间的转换，如把int转换为char；</li><li>把任何类型的表达式转换为void类型；</li><li>也用于在有继承关系的类之间进行向上转型和向下转型；</li></ol><ul><li>向上转型：将派生类指针或引用转换为基类指针或引用，是安全的；</li><li>向下转型：将基类指针或引用转换为派生类指针或引用，由于static_cast没有运行时类型检查，因此如果转换不正确可能会导致未定义行为，是不安全的；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;&#125;;<br><br>Derived* derivedPtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>Base* basePtr = <span class="hljs-built_in">static_cast</span>&lt;Base*&gt;(derivedPtr); <span class="hljs-comment">// 向上转型</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Base* basePtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>Derived* derivedPtr = <span class="hljs-built_in">static_cast</span>&lt;Derived*&gt;(basePtr); <span class="hljs-comment">// 向下转型</span><br></code></pre></td></tr></table></figure><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><ol><li>dynamic_cast是一种运行时类型转换操作符，主要用于在有继承关系的类之间进行向下转型；</li><li>在进行向下转型时 <code>dynamic_cast</code>具有类型检查（信息在虚函数中)的功能，比 <code>static_cast</code>更安全；</li><li>转换后必须是类的指针，引用或者 <code>void*</code>，基类要有虚函数可以交叉转换；</li><li>dynamic_cast本身只能用于存在虚函数的父子关系的强制类型转换；</li><li>对于指针转换失败则返回nullptr，对于引用转换失败会抛出std::bad异常；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;&#125;;<br><br>Base* basePtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Base</span>();<br>Derived* derivedPtr = <span class="hljs-built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr); <span class="hljs-comment">// 转换结果为 nullptr</span><br></code></pre></td></tr></table></figure><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>应尽可能使用const：</p><ol><li>使用const可以避免无意中修改数据的编译错误；</li><li>使用const使函数能够处理const和非const实参，否则将只能接受非const数据；</li><li>使用const引用使函数能够正确生成并使用临时变量；</li></ol><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>顶层const：表示对象本身是常量；</li><li>底层const：表示指针或引用所指向的对象是常量；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">10</span>;<span class="hljs-comment">// 顶层const：ci本身是常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* p1 = &amp;i;<span class="hljs-comment">// 底层const：p1所指向的对象是常量</span><br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p2 = &amp;i;<span class="hljs-comment">// 顶层const：p2本身是常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p3 = &amp;i;  <span class="hljs-comment">// 既有顶层const又有底层const</span><br></code></pre></td></tr></table></figure><h2 id="区分方法"><a href="#区分方法" class="headerlink" title="区分方法"></a>区分方法</h2><h3 id="从右往左读"><a href="#从右往左读" class="headerlink" title="从右往左读"></a>从右往左读</h3><p>遇到p就读作 <code>p is a</code>，遇到 <code>*</code>就读作 <code>point to</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> p;<span class="hljs-comment">// p is a int const</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p;<span class="hljs-comment">// p is a point to int const</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span> *p;<span class="hljs-comment">// p is a point to const int</span><br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p;<span class="hljs-comment">// p is a const point to int</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p;<span class="hljs-comment">// p is a const point to int const</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span>* <span class="hljs-type">const</span> p;<span class="hljs-comment">// p is a const point to const int</span><br></code></pre></td></tr></table></figure><h3 id="const默认修饰左边"><a href="#const默认修饰左边" class="headerlink" title="const默认修饰左边"></a>const默认修饰左边</h3><p>const默认修饰它左边的符号，如果左边没有，那么就修饰它右边的符号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p;<span class="hljs-comment">// 左边没有，右边第一个是int，所以p指针指向的值不能改变；</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span> *p;<span class="hljs-comment">// 左边是int，所以p指针指向的值不能改变；</span><br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p;<span class="hljs-comment">// 左边是*，所以指针是不能改变的；</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p;<span class="hljs-comment">// 第一个修饰int，第二个修饰*，所以指针和指针指向的值都不能改变；</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-type">const</span> *p;<span class="hljs-comment">// 两个修饰的都是int，重复修饰；</span><br></code></pre></td></tr></table></figure><h3 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a>常量指针和指针常量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">constValue</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> y = <span class="hljs-number">20</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = &amp;x;<br>    cout&lt;&lt;<span class="hljs-string">&quot;p: &quot;</span>&lt;&lt;p&lt;&lt;<span class="hljs-string">&quot; : &quot;</span>&lt;&lt;*p&lt;&lt;endl;<br>    x = <span class="hljs-number">20</span>;     <span class="hljs-comment">// 正确</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;p: &quot;</span>&lt;&lt;p&lt;&lt;<span class="hljs-string">&quot; : &quot;</span>&lt;&lt;*p&lt;&lt;endl;<br>    p = &amp;y;     <span class="hljs-comment">// 正确</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;p: &quot;</span>&lt;&lt;p&lt;&lt;<span class="hljs-string">&quot; : &quot;</span>&lt;&lt;*p&lt;&lt;endl;<br>    <span class="hljs-comment">// *p = 30; // 错误</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">constPointer</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> y = <span class="hljs-number">20</span>;<br>    <span class="hljs-type">int</span> *<span class="hljs-type">const</span> p = &amp;x;<br>    cout&lt;&lt;<span class="hljs-string">&quot;p: &quot;</span>&lt;&lt;p&lt;&lt;<span class="hljs-string">&quot; : &quot;</span>&lt;&lt;*p&lt;&lt;endl;<br>    x = <span class="hljs-number">20</span>;     <span class="hljs-comment">// 正确</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;p: &quot;</span>&lt;&lt;p&lt;&lt;<span class="hljs-string">&quot; : &quot;</span>&lt;&lt;*p&lt;&lt;endl;<br>    *p = <span class="hljs-number">30</span>;    <span class="hljs-comment">// 正确 </span><br>    cout&lt;&lt;<span class="hljs-string">&quot;p: &quot;</span>&lt;&lt;p&lt;&lt;<span class="hljs-string">&quot; : &quot;</span>&lt;&lt;*p&lt;&lt;endl;<br>    <span class="hljs-comment">// p = &amp;y;  // 错误</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">constPointer</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>指针常量(指向常量的指针)：指针指向的是一个常量，不能通过指针来修改它所指向的值；<ol><li>const int *p &#x3D; &x;</li><li>可以改变p使其指向不同的变量，因为p不是常量；</li><li>可以改变x的值，因为x不是常量；</li></ol></li><li>常量指针：指针本身是常量，不能指向不同的变量，但可以通过指针来修改它所指向的值；<ol><li>int *const p &#x3D; &x;</li><li>x&#x3D;20; 合法；</li><li>*p &#x3D; 20; 合法；</li><li>p &#x3D; &y; 不合法；</li></ol></li></ol><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><ol><li>volatile表示易变的，用于告诉编译器这个变量可能会在程序的控制之外被改变，因此编译器在优化时不能对访问该变量的代码进行优化；</li><li>会从内存中重新装载内容，而不是直接从寄存器拷贝内容；</li><li>指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值，确保对特殊地址的稳定访问；</li><li>使用场合：在中断服务程序和cpu相关寄存器的定义</li></ol><ul><li>硬件寄存器：当变量与硬件寄存器相关联时，硬件可能会随时改变寄存器的值；</li><li>中断服务例程：在多线程或中断驱动的程序中，volatile变量可能在中断服务例程中被修改；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(volatitle <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">1000</span>; i++);<span class="hljs-comment">// 它会执行，不会被优化</span><br></code></pre></td></tr></table></figure><h1 id="std-move"><a href="#std-move" class="headerlink" title="std::move()"></a>std::move()</h1><ol><li>std::move()是为了转移所有权，将快要销毁的对象转移给其他变量，这样可以继续使用这个对象，而不必再创建一个一样的对象，省去了创建一个一样新的对象，也提高了性能;</li><li>引入std::move()主要是为了优化对象的声明周期，以及优化函数参数传递方式；</li><li>在实际场景中，<code>右值引用</code>和 <code>std::move</code>被广泛用于在STL和自定义类中实现移动语义，避免拷贝从而提升程序性能；</li><li>std::move()与std::forward()都仅仅做了类型转换(可理解为static_cast转换) 而已。真正的移动操作是在移动构造函数或者移动赋值操作符中发生的；</li></ol><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  @brief  Convert a value to an rvalue.</span><br><span class="hljs-comment"> *  @param  __t  A thing of arbitrary type.</span><br><span class="hljs-comment"> *  @return The parameter cast to an rvalue-reference to allow moving it.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">typename</span> std::remove_reference&lt;_Tp&gt;::<span class="hljs-function">type &amp;&amp;<span class="hljs-title">move</span><span class="hljs-params">(_Tp &amp;&amp;<span class="hljs-type">__t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type &amp;&amp;&gt;(<span class="hljs-type">__t</span>);<br>&#125;<br><br><span class="hljs-comment">// remove_reference</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_reference</span><br>&#123;<br>    <span class="hljs-keyword">typedef</span> _Tp type;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_reference</span>&lt;_Tp &amp;&gt;<br>&#123;<br>    <span class="hljs-keyword">typedef</span> _Tp type;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> _Tp&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_reference</span>&lt;_Tp &amp;&amp;&gt;<br>&#123;<br>    <span class="hljs-keyword">typedef</span> _Tp type;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li><code>remove_reference</code>的作用是去除 <code>T</code>中的引用部分，只获取其中的类型部分。无论 <code>T</code>是左值还是右值，最后只获取它的类型部分。</li><li>constexpr表示这个函数可以在编译时计算结果；</li><li><code>typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;</code>表示先去除参数类型中的引用部分，然后再加上 <code>&amp;&amp;</code>表示右值引用；</li><li><code>move(_Tp&amp;&amp; __t) noexcept</code>函数接受一个右值引用参数__t，并声明为noexcept表示该函数不会抛出异常；</li><li><code>static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t)</code>: 这行代码将参数 <code>__t</code>转换为右值引用。<code>static_cast</code>用于显式类型转换，将 <code>__t</code>转换为去除引用后的类型，并加上 <code>&amp;&amp;</code>来表示右值引用。</li><li>函数模板 <code>move</code>的作用是将一个左值或右值转换为右值引用。通过使用 <code>std::remove_reference</code>和 <code>&amp;&amp;</code>，它确保了返回类型是一个右值引用，从而允许对象被移动而不是被复制。</li></ol><h2 id="typename"><a href="#typename" class="headerlink" title="typename"></a>typename</h2><ol><li>typename关键字用于告诉编译器某个依赖名称（依赖于模板参数的名称）是一个类型；</li><li>模板函数并不创建任何函数，而只是告诉编译器如何定义函数，当传入某个类型时，编译器按照模板模式再创建这样的函数；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;<br></code></pre></td></tr></table></figure><ul><li><code>std::remove_reference&lt;_Tp&gt;::type</code> : 这是一个依赖名称，因为它依赖于模板参数 <code>_Tp</code>。</li><li><code>typename</code>用于告诉编译器 <code>std::remove_reference&lt;_Tp&gt;::type</code>是一个类型。</li></ul><h3 id="为什么需要typename："><a href="#为什么需要typename：" class="headerlink" title="为什么需要typename："></a>为什么需要typename：</h3><p>在模板编程中，编译器在解析模板代码时，需要知道某个名称是类型还是非类型。对于非依赖名称（不依赖于模板参数的名称），编译器可以很容易地确定其类型。但对于依赖名称（依赖于模板参数的名称），编译器需要显式地使用 <code>typename</code>来指示这是一个类型。</p><ul><li>非依赖名称：例如int*，编译器知道int*是一个类型；</li><li>依赖名称：std::remove_reference&lt;_Tp&gt;::type，编译器需要typename来明确这是一个类型；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">using</span> ValueType = vector&lt;<span class="hljs-type">int</span>&gt;::value_type;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里的 <code>vector&lt;int&gt;</code>为非依赖名称，ValueType会直接被解析为int，程序没有错误；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">using</span> ValueType = <span class="hljs-keyword">typename</span> T::value_type;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里的 <code>T</code>为依赖名称，所以需要typename来告诉编译器 <code>T::value_type</code>是一个类型；如果不加typename编译器会报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ g++ -o app main.cpp <br>main.cpp:6:23: error: need ‘typename’ before ‘T::value_type’ because ‘T’ is a dependent scope<br>    6 |     using valueType = T::value_type;<br>      |                       ^<br>      |                       typename<br></code></pre></td></tr></table></figure><h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestSTLObject</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::string str = <span class="hljs-string">&quot;Hello&quot;</span>;<br>    std::vector&lt;std::string&gt; v;<br> <br>    <span class="hljs-comment">// uses the push_back(const T&amp;) overload, which means</span><br>    <span class="hljs-comment">// we&#x27;ll incur the cost of copying str</span><br>    v.<span class="hljs-built_in">push_back</span>(str);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After copy, str is \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br> <br>    <span class="hljs-comment">// uses the rvalue reference push_back(T&amp;&amp;) overload,</span><br>    <span class="hljs-comment">// which means no strings will be copied; instead, the contents</span><br>    <span class="hljs-comment">// of str will be moved into the vector.  This is less</span><br>    <span class="hljs-comment">// expensive, but also means str might now be empty.</span><br>    v.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(str));<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After move, str is \&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br> <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The contents of the vector are \&quot;&quot;</span> &lt;&lt; v[<span class="hljs-number">0</span>]<br>                                         &lt;&lt; <span class="hljs-string">&quot;\&quot;, \&quot;&quot;</span> &lt;&lt; v[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;\&quot;\n&quot;</span>;<br> <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">TestSTLObject</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./app <br>After copy, str is <span class="hljs-string">&quot;Hello&quot;</span><br>After move, str is <span class="hljs-string">&quot;&quot;</span><br>The contents of the vector are <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// stdmove.cpp -- using std::move()</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-comment">// use the following for g++4.5</span><br><span class="hljs-comment">// #define nullptr 0</span><br><span class="hljs-comment">// interface</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Useless</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;          <span class="hljs-comment">// number of elements</span><br>    <span class="hljs-type">char</span> * pc;      <span class="hljs-comment">// pointer to data</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> ct;  <span class="hljs-comment">// number of objects</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowObject</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Useless</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Useless</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>;<br>    <span class="hljs-built_in">Useless</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">char</span> ch);<br>    <span class="hljs-built_in">Useless</span>(<span class="hljs-type">const</span> Useless &amp; f); <span class="hljs-comment">// regular copy constructor</span><br>    <span class="hljs-built_in">Useless</span>(Useless &amp;&amp; f);      <span class="hljs-comment">// move constructor</span><br>    ~<span class="hljs-built_in">Useless</span>();<br>    Useless <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Useless &amp; f)<span class="hljs-type">const</span>;<br>    Useless &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Useless &amp; f); <span class="hljs-comment">// copy assignment</span><br>    Useless &amp; <span class="hljs-keyword">operator</span>=(Useless &amp;&amp; f);      <span class="hljs-comment">// move assignment </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// implementation</span><br><span class="hljs-type">int</span> Useless::ct = <span class="hljs-number">0</span>;<br><br>Useless::<span class="hljs-built_in">Useless</span>()<br>&#123;<br>    ++ct;<br>    n = <span class="hljs-number">0</span>;<br>    pc = <span class="hljs-literal">nullptr</span>;<br> &#125;<br><br>Useless::<span class="hljs-built_in">Useless</span>(<span class="hljs-type">int</span> k) : <span class="hljs-built_in">n</span>(k)<br>&#123;<br>    ++ct; <br>    pc = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n];<br>&#125;<br><br>Useless::<span class="hljs-built_in">Useless</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">char</span> ch) : <span class="hljs-built_in">n</span>(k)<br>&#123;<br>    ++ct;<br>    pc = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        pc[i] = ch;<br>&#125;<br><br>Useless::<span class="hljs-built_in">Useless</span>(<span class="hljs-type">const</span> Useless &amp; f): <span class="hljs-built_in">n</span>(f.n) <br>&#123;<br>    ++ct;<br>    pc = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        pc[i] = f.pc[i];<br>&#125;<br><br>Useless::<span class="hljs-built_in">Useless</span>(Useless &amp;&amp; f): <span class="hljs-built_in">n</span>(f.n) <br>&#123;<br>    ++ct;<br>    pc = f.pc;       <span class="hljs-comment">// steal address</span><br>    f.pc = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// give old object nothing in return</span><br>    f.n = <span class="hljs-number">0</span>;<br>&#125;<br><br>Useless::~<span class="hljs-built_in">Useless</span>()<br>&#123;<br>    <span class="hljs-keyword">delete</span> [] pc;<br>&#125;<br><br>Useless &amp; Useless::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Useless &amp; f)  <span class="hljs-comment">// copy assignment</span><br>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;copy assignment operator called:\n&quot;</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;f)<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">delete</span> [] pc;<br>    n = f.n;<br>    pc = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        pc[i] = f.pc[i];<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>Useless &amp; Useless::<span class="hljs-keyword">operator</span>=(Useless &amp;&amp; f)       <span class="hljs-comment">// move assignment</span><br>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;move assignment operator called:\n&quot;</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;f)<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">delete</span> [] pc;<br>    n = f.n;<br>    pc = f.pc;<br>    f.n = <span class="hljs-number">0</span>;<br>    f.pc = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>Useless Useless::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Useless &amp; f)<span class="hljs-type">const</span><br>&#123;<br>    Useless temp = <span class="hljs-built_in">Useless</span>(n + f.n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        temp.pc[i] = pc[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &lt; temp.n; i++)<br>        temp.pc[i] = f.pc[i - n];<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Useless::ShowObject</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123; <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Number of elements: &quot;</span> &lt;&lt; n;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot; Data address: &quot;</span> &lt;&lt; (<span class="hljs-type">void</span> *) pc &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Useless::ShowData</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;(object empty)&quot;</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>            std::cout &lt;&lt; pc[i];<br>    std::cout &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// application</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::cout;<br>    &#123;<br>        <span class="hljs-function">Useless <span class="hljs-title">one</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;x&#x27;</span>)</span></span>;<br>        Useless two = one +one;   <span class="hljs-comment">// calls move constructor</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;object one: &quot;</span>;<br>        one.<span class="hljs-built_in">ShowData</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;object two: &quot;</span>;<br>        two.<span class="hljs-built_in">ShowData</span>();<br>        Useless three, four;<br>        cout &lt;&lt; <span class="hljs-string">&quot;three = one\n&quot;</span>;<br>        three = one;              <span class="hljs-comment">// automatic copy assignment</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;now object three = &quot;</span>;<br>        three.<span class="hljs-built_in">ShowData</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;and object one = &quot;</span>;<br>        one.<span class="hljs-built_in">ShowData</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;four = one + two\n&quot;</span>;<br>        four = one + two;         <span class="hljs-comment">// automatic move assignment</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;now object four = &quot;</span>;<br>        four.<span class="hljs-built_in">ShowData</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;four = move(one)\n&quot;</span>;<br>        four = std::<span class="hljs-built_in">move</span>(one);    <span class="hljs-comment">// forced move assignment</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;now object four = &quot;</span>;<br>        four.<span class="hljs-built_in">ShowData</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;and object one = &quot;</span>;<br>        one.<span class="hljs-built_in">ShowData</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./app<br>object one: xxxxxxxxxx<br>object two: xxxxxxxxxxxxxxxxxxxx<br>three = one<br>copy assignment operator called:<br>now object three = xxxxxxxxxx<br>and object one = xxxxxxxxxx<br>four = one + two<br>move assignment operator called:<br>now object four = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br>four = move(one)<br>move assignment operator called:<br>now object four = xxxxxxxxxx<br>and object one = (object empty)<br></code></pre></td></tr></table></figure><h1 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>通常所说的引用均为左值引用：</p><ol><li><p>引用是已定义的变量的别名；</p></li><li><p>引用变量的主要用途是用作函数的形参，通过将引用变量作为参数，函数将使用原始变量，而不是其副本；</p></li><li><p>必须在声明引用时将其初始化，而不能像指针那样先声明再赋值；</p></li><li><p>这里的”一旦与某个变量关联起来，就不能改变”指的是地址；lvalue关联了变量n，那么lvalue就不能再关联其他变量了，即lvalue的地址就不能再改变；但是lvalue的值是可以改变的；</p></li><li><p>引用变量和原始变量指向相同的值和内存单元；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">leftValue</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> &amp;lvalue = n;<br>    std::cout &lt;&lt; lvalue &lt;&lt;std::endl;<br>    std::cout &lt;&lt; &amp;n &lt;&lt;std::endl;<br>    std::cout &lt;&lt; &amp;lvalue &lt;&lt;std::endl;<br><br>    <span class="hljs-type">int</span> num = <span class="hljs-number">50</span>;<br>    lvalue = num;<br>    std::cout &lt;&lt; n &lt;&lt;std::endl;<br>    std::cout &lt;&lt; lvalue &lt;&lt;std::endl;<br>    std::cout &lt;&lt; num &lt;&lt;std::endl;<br>    std::cout &lt;&lt; &amp;n &lt;&lt;std::endl;<br>    std::cout &lt;&lt; &amp;lvalue &lt;&lt;std::endl;<br>    std::cout &lt;&lt; &amp;num &lt;&lt;std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">leftValue</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>运行结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">$ ./app<br><span class="hljs-number">10</span><br><span class="hljs-number">0x7ffc91710998</span><br><span class="hljs-number">0x7ffc91710998</span><br><span class="hljs-number">50</span><br><span class="hljs-number">50</span><br><span class="hljs-number">50</span><br><span class="hljs-number">0x7ffc91710998</span><br><span class="hljs-number">0x7ffc91710998</span><br><span class="hljs-number">0x7ffc9171099c</span><br></code></pre></td></tr></table></figure><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><p>返回引用时最重要的一点是，应避免返回&lt;函数终止时不再存在的内存单元&gt;例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;p)</span></span>&#123;<br>    <span class="hljs-type">int</span> newguy;<br>    newguy = p;<br>    <span class="hljs-keyword">return</span> newguy;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> guy = <span class="hljs-built_in">clone</span>(n);<br>    std::cout&lt;&lt; guy &lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数返回一个指向临时变量(newguy)的引用，函数运行完毕后它将不再存在。</p><p>解决办法：</p><ol><li>为了避免这种问题，最简单的方法是返回一个作为参数传递给函数的引用，作为参数的引用指向调用函数使用的数据，因此返回的引用也将指向这些数据；</li><li>另一种方法是使用new来分配新的存储空间；</li></ol><h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><ol><li>右值引用的声明符号为 <code>&amp;&amp;</code>，用以引用一个右值，可以延长右值的生命周期；</li><li>左值是一个可以表示数据的表达式（变量名，解除引用的指针)，程序可以获取它的地址，右值则不能对其取地址；</li><li>但是，如果将右值关联到右值引用，将导致该右值被存储到特定的位置，且可以获取该位置的地址；</li><li><pre><code class="language-cpp">#include &lt;iostream&gt;inline double f(double tf)&#123;return 5.0*(tf-32.0)/9.0;&#125;int main()&#123;    double tc = 21.5;    double &amp;&amp;rd1 = 7.07;    double &amp;&amp;rd2 = f(rd1);    std::cout&lt;&lt; &quot;tc value and address: &quot;&lt;&lt;tc&lt;&lt;&quot;, &quot;&lt;&lt;&amp;tc&lt;&lt;std::endl;    std::cout&lt;&lt; &quot;rd1 value and address: &quot;&lt;&lt;rd1&lt;&lt;&quot;, &quot;&lt;&lt;&amp;rd1&lt;&lt;std::endl;    std::cout&lt;&lt; &quot;rd2 value and address: &quot;&lt;&lt;rd2&lt;&lt;&quot;, &quot;&lt;&lt;&amp;rd2&lt;&lt;std::endl;    return 0;&#125;编译运行：$ ./apptc value and address: 21.5, 0x7fff68ec89d0rd1 value and address: 7.07, 0x7fff68ec89d8rd2 value and address: -13.85, 0x7fff68ec89e0<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-number">5.</span> 引入右值引用的主要目的之一是实现移动语义；<br><br><span class="hljs-meta">## 移动语义</span><br><br>```cpp<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">string</span>&gt; vstr;<br><span class="hljs-comment">// 省略代码：vstr存储2000个string，每个string长度为1000</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-built_in">vstr_copy</span>(vstr);<br></code></pre></td></tr></table></figure></code></pre></li></ol><p>vector和string类都使用动态内存分配，因此需要某种new版本的复制构造函数，为了初始化vstr_copy，复制构造函数 <code>vector &lt;string&gt;</code>将使用new给2000个string对象分配内存，每个string对象又需要调用string的复制构造函数，这个构造函数将又将使用new给1000个字符分配内存，最后全部2000000个字符才从vstr控制的内存中复制到vstr_copy控制的内存中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">allcaps</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;string&gt; &amp;vs)</span></span>&#123;<br>    vector&lt;string&gt; temp;<br>    <span class="hljs-comment">// 省略代码：将vs中的所有小写转大写存储到temp中</span><br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;string&gt; vstr;<br>    <span class="hljs-comment">// 省略代码：vstr存储2000个string，每个string长度为1000</span><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">vstr_copy</span><span class="hljs-params">(allcaps(vstr))</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>allcops()函数创建对象temp，该对象管理着2000000个字符，vector和string的复制构造函数创建这2000000个字符的副本，然后程序删除allcops()返回的临时对象（编译器会将temp复制给一个临时返回对象，然后删除temp再删除临时返回对象)，这里做了大量的无用功。</p><p>如果使用移动语义，编译器直接将数据的所有权转让给vstr_copy，而不需要先将字符复制新地方再删除原来的字符。</p><p>要实现移动语义，需要采取某种方式让编译器知道什么时候需要复制，什么时候不需要复制。这就是右值引用发挥作用的地方。</p><h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><ol><li>内联函数的目的是为了提高程序的运行速度；</li><li>与常规函数的主要区别在于C++编译器如何将它们组合到程序中；</li><li></li></ol><h1 id="特殊的成员函数"><a href="#特殊的成员函数" class="headerlink" title="特殊的成员函数"></a>特殊的成员函数</h1><ul><li>默认构造函数</li><li>复制构造函数</li><li>复制赋值运算符</li><li>析构函数</li><li>移动构造函数</li><li>移动赋值运算符</li></ul><p>如果没有给类定义任何构造函数，编译器将提供一个默认构造函数；</p><p>对于使用内置类型的成员，默认的默认构造函数不对其进行初始化；对于属于类对象的成员，则调用其默认构造函数；</p><p>如果自己写了析构函数，复制构造函数或复制赋值运算符，编译器就不会自动提供移动构造函数和移动赋值运算符；</p><p>如果自己写了移动构造函数或移动赋值操作符，编译器将不会自动提供复制构造函数和复制赋值运算符；</p><h2 id="默认和禁用"><a href="#默认和禁用" class="headerlink" title="默认和禁用"></a>默认和禁用</h2><p>如果自己编写了移动构造函数，因此编译器将不会自动创建默认的构造函数，复制构造函数以及复制赋值操作符。这时候可以使用 <code>default</code>显式地声明这些方法的默认版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">someclass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">someclass</span>(someclass &amp;&amp;)&#123;&#125;;<br>    <span class="hljs-built_in">someclass</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">someclass</span>(<span class="hljs-type">const</span> someclass &amp;) = <span class="hljs-keyword">default</span>;<br>    someclass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> someclass &amp;) = <span class="hljs-keyword">default</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>此外，关键字 <code>delete</code>可用于禁止编译器使用特定方法，如果要禁止复制对象，可禁用复制构造函数和复制赋值运算符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">someclass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">someclass</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">someclass</span>(someclass &amp;&amp;) = <span class="hljs-keyword">default</span>;<br>    someclass&amp; <span class="hljs-keyword">operator</span>=(someclass &amp;&amp;) = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">someclass</span>(<span class="hljs-type">const</span> someclass &amp;) = <span class="hljs-keyword">delete</span>;<br>    someclass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> someclass &amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>cpp</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>格式化字符串</title>
    <link href="/2025/02/22/Cpp/%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2025/02/22/Cpp/%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="格式字符串"><a href="#格式字符串" class="headerlink" title="格式字符串"></a>格式字符串</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">printf</span><span class="hljs-params">()</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">scanf</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><span id="more"></span><p>格式说明符：</p><ul><li>%d:十进制整数</li><li>%u:无符号十进制整数</li><li>%x:十六进制整数</li><li>%o:八进制整数</li><li>%f:浮点数（小数点形式）</li><li>%e:浮点数（科学计数法形式）</li><li>%g:通用浮点数（自动选择%f&#x2F;%e）</li><li>%s:字符串</li><li>%c:字符</li><li>%%:%字符</li></ul><p>标志，宽度，精度，长度修饰符：</p><ul><li>%+d:带正负号的整数</li><li>%10d:宽度为10的整数，如果数字较短则用空格填充</li><li>%.2f:小数点后保留2位的浮点数</li><li>%5.2f:宽度为5，小数点后保留2位的浮点数</li><li>%ld:长整型（long int）的整数</li><li>%lf:双精度浮点数（double）</li><li>%08x:宽度为8，如果输出数字少于指定宽度，使用0填充左边空位，十六进制输出。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>静态库和动态库</title>
    <link href="/2025/02/22/Cpp/%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    <url>/2025/02/22/Cpp/%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h1><p>Linux中静态库以<code>lib</code>作为前缀，<code>.a</code>作为后缀，中间是库的名字。即<code>libxxx.a</code><br>Windows中静态库以<code>lib</code>作为前缀，<code>.lib</code>作为后缀，中间是库的名字。即<code>libxxx.lib</code></p><span id="more"></span><h2 id="生态静态链接库（ar）"><a href="#生态静态链接库（ar）" class="headerlink" title="生态静态链接库（ar）"></a>生态静态链接库（ar）</h2><ul><li>c：创建一个库</li><li>s：创建归档索引</li><li>r：醍醐寺内归档文件中已有的文件或加入新文件</li></ul><p>.<br>├── include<br>│   └── head.h<br>└── src<br>    ├── add.c<br>    ├── div.c<br>    ├── mult.c<br>    └── sub.c</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.对源文件进行汇编操作</span><br>$ gcc src/*.c -c -Iinclude<br><br><span class="hljs-comment"># 2.打包.o文件生成静态库</span><br>$ ar rcs libxxx.a *.o<br></code></pre></td></tr></table></figure><h2 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a>静态库的使用</h2><p>.<br>├── include<br>│   └── head.h<br>├── lib<br>│   └── libcalc.a<br>└── main.c</p><ul><li>-I：指定include包含的头文件路径</li><li>-L：指定静态库&#x2F;动态库路径</li><li>-l：指定静态库&#x2F;动态库名字（掐头去尾）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.拿到发布的静态库和头文件</span><br><span class="hljs-comment"># 2.编写测试程序main.c</span><br><span class="hljs-comment"># 3.编译测试文件</span><br>$ gcc main.c -o main -Iinclude -Llib -lxxx<br></code></pre></td></tr></table></figure><h1 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h1><p>Linux中动态库以<code>lib</code>作为前缀，<code>.so</code>作为后缀，中间是库的名字。即<code>libxxx.so</code><br>Windows中动态库以<code>lib</code>作为前缀，<code>.dll</code>作为后缀，中间是库的名字。即<code>libxxx.dll</code></p><h2 id="生成动态链接库（-fpic-shared）"><a href="#生成动态链接库（-fpic-shared）" class="headerlink" title="生成动态链接库（-fpic, -shared）"></a>生成动态链接库（-fpic, -shared）</h2><ul><li>-fpic：生成与位置无关的代码</li><li>-shared：生成一个动态链接库</li></ul><p>.<br>├── include<br>│   └── head.h<br>└── src<br>    ├── add.c<br>    ├── div.c<br>    ├── mult.c<br>    └── sub.c</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.将源文件进行汇编操作（-c, -fpic）</span><br>$ gcc src/*.c -o -fpic -Iinclude<br><br><span class="hljs-comment"># 2.将.o文件打包成动态库（-shared）</span><br>$ gcc -shared *.o -o libxxx.so<br></code></pre></td></tr></table></figure><h2 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h2><p>.<br>├── include<br>│   └── head.h<br>├── lib<br>│   └── libcalc.so<br>└── main.c</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.拿到发布的动态库和头文件</span><br><span class="hljs-comment"># 2.编写测试程序</span><br><span class="hljs-comment"># 3.编译测试程序</span><br>$ gcc main.c -o main -Iinclude -Llib -lxxx<br><br><span class="hljs-comment"># 4.添加动态库加载目录</span><br></code></pre></td></tr></table></figure><h2 id="添加动态库加载目录"><a href="#添加动态库加载目录" class="headerlink" title="添加动态库加载目录"></a>添加动态库加载目录</h2><h3 id="方法1：修改LD-LIBRARY-PATH"><a href="#方法1：修改LD-LIBRARY-PATH" class="headerlink" title="方法1：修改LD_LIBRARY_PATH"></a>方法1：修改LD_LIBRARY_PATH</h3><p>1.找到相关的配置文件</p><ul><li>用户级别：<code>~/.bashrc</code></li><li>系统级别：<code>/etc/profile</code></li></ul><p>2.使用vim打开配置文件，并添加动态库绝对路径(pwd查看)</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 在最后一行添加以下内容</span><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">LD_LIBRARY_PATH</span>=<span class="hljs-variable">$LD_LIBRARY_PATH</span>:动态库路径<br></code></pre></td></tr></table></figure><p>3.让配置文件生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">source</span> ~/.bashrc<br>$ <span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><h3 id="方法2：更新-etc-ld-so-conf文件"><a href="#方法2：更新-etc-ld-so-conf文件" class="headerlink" title="方法2：更新&#x2F;etc&#x2F;ld.so.conf文件"></a>方法2：更新&#x2F;etc&#x2F;ld.so.conf文件</h3><p>1.将动态库的绝对路径添加到文件的末尾</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> vim /etc/ls.so.conf<br></code></pre></td></tr></table></figure><p>2.更新<code>/etc/ld.so.conf</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">source</span> ldconfig<br></code></pre></td></tr></table></figure><h3 id="方法3：拷贝动态库到-lib-或-usr-lib文件中"><a href="#方法3：拷贝动态库到-lib-或-usr-lib文件中" class="headerlink" title="方法3：拷贝动态库到/lib/或/usr/lib文件中"></a>方法3：拷贝动态库到<code>/lib/</code>或<code>/usr/lib</code>文件中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cp</span> libxxx.so /usr/lib<br></code></pre></td></tr></table></figure><h3 id="方法4：将库的软链接放到-lib-或-usr-lib文件中"><a href="#方法4：将库的软链接放到-lib-或-usr-lib文件中" class="headerlink" title="方法4：将库的软链接放到/lib/或/usr/lib文件中"></a>方法4：将库的软链接放到<code>/lib/</code>或<code>/usr/lib</code>文件中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">ln</span> libxxx.so /usr/lib/libxxx.so<br></code></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.cnblogs.com/zzLiuwh/p/17074760.html">Linux静态库与动态库整理</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>stl</title>
    <link href="/2025/02/22/DataStructure/stl/"/>
    <url>/2025/02/22/DataStructure/stl/</url>
    
    <content type="html"><![CDATA[<ol><li>deque</li><li>vector</li><li>string</li></ol><span id="more"></span><h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><ol><li>初始化双端队列</li><li>添加到队尾</li><li>添加到队首</li><li>遍历元素</li><li>访问队尾元素</li><li>访问队首元素</li><li>元素出队</li><li>获取双端队列长度</li><li>判断队列是否为空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">/* 初始化双向队列 */</span><br>    deque&lt;<span class="hljs-type">int</span>&gt; deque;<br><br>    <span class="hljs-comment">/* 元素入队 */</span><br>    deque.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);   <span class="hljs-comment">// 添加至队尾</span><br>    deque.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">5</span>);<br>    deque.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<br>    deque.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// 添加至队首</span><br>    deque.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">/* 遍历元素 */</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> elem:deque)&#123;<br>        cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-comment">/* 访问元素 */</span><br>    <span class="hljs-type">int</span> front = deque.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 队首元素</span><br>    <span class="hljs-type">int</span> back = deque.<span class="hljs-built_in">back</span>();   <span class="hljs-comment">// 队尾元素</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;front : &quot;</span> &lt;&lt; front &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;back : &quot;</span> &lt;&lt; back &lt;&lt; endl;<br><br>    <span class="hljs-comment">/* 元素出队 */</span><br>    deque.<span class="hljs-built_in">pop_front</span>();  <span class="hljs-comment">// 队首元素出队</span><br>    deque.<span class="hljs-built_in">pop_back</span>();   <span class="hljs-comment">// 队尾元素出队</span><br><br>    <span class="hljs-comment">/* 遍历元素 */</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> elem:deque)&#123;<br>        cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-comment">/* 获取双向队列的长度 */</span><br>    <span class="hljs-type">int</span> size = deque.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-comment">/* 判断双向队列是否为空 */</span><br>    <span class="hljs-type">bool</span> empty = deque.<span class="hljs-built_in">empty</span>();<br>    <span class="hljs-keyword">if</span>(empty)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;deque is empty&quot;</span> &lt;&lt; endl;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;deque is not empty&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础</title>
    <link href="/2025/02/22/Linux/Linux%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/02/22/Linux/Linux%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h1><p>1.进程调度 SCHED<br>2.内存管理 MMU<br>3.虚拟文件系统 VFS<br>4.网络接口<br>5.进程间通信</p><span id="more"></span><h1 id="Linux目录"><a href="#Linux目录" class="headerlink" title="Linux目录"></a>Linux目录</h1><ul><li>bin：存储可执行程序，比如各种命令的可执行程序</li><li>sbin：root用户使用的一些二进制可执行程序</li><li>etc：配置文件目录，存储应用程序的配置文件</li><li>lib：系统或安装的软件所使用的静态库和动态库</li><li>media：挂在目录，挂在外部设备</li><li>mnt：临时挂载目录，比如U盘可以挂载在这个目录下</li><li>proc：内存使用的映射目录，给操作系统使用</li><li>tmp：临时目录，重启电脑数据被自动删除</li><li>boot：存储开机相关的设置</li><li>home：普通用户的家目录</li><li>root：root用户的家目录</li><li>dev：设备目录，所有硬件会被抽象成文件存储起来比如键盘，鼠标</li><li>opt：第三方软件的安装目录</li><li>var：日志文件</li><li>usr：系统的资源目录<ul><li>&#x2F;usr&#x2F;bin：可执行二进制程序</li><li>&#x2F;usr&#x2F;include：标准头文件目录</li><li>&#x2F;usr&#x2F;local：安装的第三方软件，同opt目录</li></ul></li></ul><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><table><thead><tr><th align="center">快捷键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">Ctrl+a</td><td align="center">光标移动到命令行行首</td></tr><tr><td align="center">Ctrl+e</td><td align="center">光标移动到命令行行尾</td></tr><tr><td align="center">Ctrl+u</td><td align="center">删除光标前的字符串</td></tr><tr><td align="center">Ctrl+k</td><td align="center">删除光标后的字符串</td></tr></tbody></table><h1 id="文件管理命令"><a href="#文件管理命令" class="headerlink" title="文件管理命令"></a>文件管理命令</h1><h2 id="1-在邻近的两个目录之间切换-cd"><a href="#1-在邻近的两个目录之间切换-cd" class="headerlink" title="1.在邻近的两个目录之间切换 cd"></a>1.在邻近的两个目录之间切换 cd</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#通过cd进入目录1</span><br>$ <span class="hljs-built_in">cd</span> /home/zhm/Desktop/Linux    <br><br><span class="hljs-comment">#通过cd进入目录2</span><br>$ <span class="hljs-built_in">cd</span> /Download/Clash<br><br><span class="hljs-comment">#在两个目录之间切换</span><br>$ <span class="hljs-built_in">cd</span> -<br></code></pre></td></tr></table></figure><h2 id="2-ls命令"><a href="#2-ls命令" class="headerlink" title="2.ls命令"></a>2.ls命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看当前目录下所有文件包括隐藏文件</span><br>$ <span class="hljs-built_in">ls</span> -a<br><br><span class="hljs-comment">#显示文件详细信息</span><br>$ <span class="hljs-built_in">ls</span> -l <span class="hljs-comment">#可以缩写成ll</span><br>drwxrwxr-x 5 zhm zhm 4.0K  9月  4 21:25 ./<br>drwxr-xr-x 3 zhm zhm 4.0K  9月  4 13:52 ../<br>drwxrwxr-x 5 zhm zhm 4.0K  9月  4 18:29 gcc/<br>drwxrwxr-x 2 zhm zhm 4.0K  9月  4 21:25 makefile/<br>drwxrwxr-x 2 zhm zhm 4.0K  9月  3 21:03 search/<br></code></pre></td></tr></table></figure><ul><li>文件类型<ul><li>-:普通文件</li><li>d:目录</li><li>l:软链接文件</li><li>c:字符设备</li><li>b:块设备</li><li>p:管道文件</li><li>s:本地套接字文件</li></ul></li><li>文件所有者权限</li><li>文件所属组权限</li><li>其他人权限</li><li>硬链接计数</li><li>文件所有者</li><li>文件所有组</li><li>文件大小</li><li>文件修改时间</li><li>文件名</li></ul><h2 id="3-删除文件或目录"><a href="#3-删除文件或目录" class="headerlink" title="3.删除文件或目录"></a>3.删除文件或目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除文件</span><br>$ <span class="hljs-built_in">rm</span> file1.c file2.c<br><br><span class="hljs-comment"># 删除目录</span><br>$ <span class="hljs-built_in">rm</span> <span class="hljs-built_in">dir</span> -r<br><br><span class="hljs-comment"># 强制删除目录</span><br>$ <span class="hljs-built_in">rm</span> <span class="hljs-built_in">dir</span> -rf<br></code></pre></td></tr></table></figure><h2 id="4-拷贝文件或目录"><a href="#4-拷贝文件或目录" class="headerlink" title="4.拷贝文件或目录"></a>4.拷贝文件或目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 拷贝文件（文件不存在则创建，文件存在则覆盖）</span><br>$ <span class="hljs-built_in">cp</span> fileA fileB<br><br><span class="hljs-comment"># 拷贝目录（拷贝目录需要参数 -r）</span><br><span class="hljs-comment"># 情景1：目录A存在，目录B不存在（创建B，并将A放入B）</span><br>$ <span class="hljs-built_in">cp</span> dirA dirB -r<br><br><span class="hljs-comment"># 情景2：目录A存在，目录B也存在（直接将A放入B）</span><br>$ <span class="hljs-built_in">cp</span> dirA dirB -r<br><br><span class="hljs-comment"># 情景3：把目录A中的所有文件拷贝到目录B中（A中文件放入B）</span><br>$ <span class="hljs-built_in">cp</span> dirA/* dirB -r<br></code></pre></td></tr></table></figure><h2 id="5-查看文件内容"><a href="#5-查看文件内容" class="headerlink" title="5.查看文件内容"></a>5.查看文件内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> filename<br>$ more filename<br>    - 回车：显示下一行<br>    - 空格：向下滚动一屏<br>    - b：返回上一屏<br>    - q：退出<br>$ less filename<br>    - 空格：向下翻页<br>    - b：向上翻页<br>    - 回车：显示下一行<br>    - 上下键：上下滚动<br>    - q：退出<br></code></pre></td></tr></table></figure><h2 id="6-创建链接"><a href="#6-创建链接" class="headerlink" title="6.创建链接"></a>6.创建链接</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 软链接：相当于创建快捷方式</span><br><span class="hljs-comment"># 创建软链接并放到另一个目录</span><br>$ <span class="hljs-built_in">ln</span> -s hello /home/zhm/Desktop/Linux/search/link/hello.link<br><br><span class="hljs-comment"># 硬链接：多个文件指向同一个内存</span><br>$ <span class="hljs-built_in">ln</span> hello ./link/hello.link<br></code></pre></td></tr></table></figure><h2 id="7-文件属性"><a href="#7-文件属性" class="headerlink" title="7.文件属性"></a>7.文件属性</h2><h3 id="7-1-修改文件权限-chmod"><a href="#7-1-修改文件权限-chmod" class="headerlink" title="7.1 修改文件权限 chmod"></a>7.1 修改文件权限 chmod</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 语法格式</span><br><span class="hljs-comment"># chmod who [+|-|=] mod filename</span><br><span class="hljs-comment"># chmod [+|-|=] mod filename</span><br>    - <span class="hljs-built_in">who</span>:<br>        - u：user 文件所有者<br>        - g：group 文件所有组<br>        - o：other 其他用户<br>        - a：all 以上三类<br>    - [+|-|=]:<br>        - +：添加权限<br>        - -：去除权限<br>        - =：覆盖权限<br>    - mod<br>        - r/4：读权限<br>        - w/2：写权限<br>        - x/1：执行权限<br>        - -/0：没有权限<br><br><span class="hljs-comment"># 示例：给文件所有者添加执行权限</span><br>$ <span class="hljs-built_in">chmod</span> u +x hello<br><br><span class="hljs-comment"># 示例：给所有用户添加读写执行权限</span><br><span class="hljs-comment"># 7 = 4 + 3 + 1（读 + 写 + 执行）</span><br>$ <span class="hljs-built_in">chmod</span> 777 hello<br></code></pre></td></tr></table></figure><h3 id="7-2-修改文件所有者-chown"><a href="#7-2-修改文件所有者-chown" class="headerlink" title="7.2 修改文件所有者 chown"></a>7.2 修改文件所有者 chown</h3><p>创建新用户的时候，系统会自动创建出对应用户名组，比如创建一个新的用户wwl，则会同时创建出一个新的用户组wwl。默认情况下，文件通过哪个用户创建出来，就属于哪个用户以及属于用户对应的组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修改文件所有者</span><br><span class="hljs-comment"># sudo chown 新的所有者 文件名</span><br>$ <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chown</span> wwl &lt;filename&gt;<br><br><span class="hljs-comment"># 修改文件所有者和所属组</span><br><span class="hljs-comment"># sudo chown 新的文件所有者：新的文件所属组 文件名</span><br>$ <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chown</span> wwl:wwl &lt;filename&gt;<br></code></pre></td></tr></table></figure><h3 id="7-3-修改文件所属组-chgrp"><a href="#7-3-修改文件所属组-chgrp" class="headerlink" title="7.3 修改文件所属组 chgrp"></a>7.3 修改文件所属组 chgrp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo chgrp 新的组 文件名</span><br>$ <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chgrp</span> wwl &lt;filename&gt;<br></code></pre></td></tr></table></figure><h2 id="8-which"><a href="#8-which" class="headerlink" title="8.which"></a>8.which</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看要执行的命令所在的实际路径</span><br>$ <span class="hljs-built_in">which</span> <span class="hljs-built_in">ls</span><br>/usr/bin/ls<br></code></pre></td></tr></table></figure><h2 id="9-输出重定向"><a href="#9-输出重定向" class="headerlink" title="9.输出重定向"></a>9.输出重定向</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># &gt; : 将文件内容写入到指定文件中，覆盖原数据</span><br><span class="hljs-comment"># &gt;&gt; : 将文件内容追加到指定文件的尾部</span><br>$ <span class="hljs-built_in">cat</span> hello.c &gt; hello.cpp<br>$ <span class="hljs-built_in">date</span> &gt;&gt; time.txt<br></code></pre></td></tr></table></figure><h1 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h1><h2 id="1-切换用户-su"><a href="#1-切换用户-su" class="headerlink" title="1.切换用户 su"></a>1.切换用户 su</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用 su 只切换用户，当前的工作目录不会变化</span><br>$ su wwl<br><br><span class="hljs-comment"># 使用 su - 不仅会切换用户，工作目录也会切换为当前用户的家目录</span><br>$ su - wwl <br></code></pre></td></tr></table></figure><h2 id="2-添加用户-adduser"><a href="#2-添加用户-adduser" class="headerlink" title="2.添加用户 adduser"></a>2.添加用户 adduser</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo adduser &lt;username&gt;</span><br>$ <span class="hljs-built_in">sudo</span> adduser wwl<br></code></pre></td></tr></table></figure><h2 id="3-删除用户-userdel"><a href="#3-删除用户-userdel" class="headerlink" title="3.删除用户 userdel"></a>3.删除用户 userdel</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo userdel &lt;username&gt; -r</span><br>$ <span class="hljs-built_in">sudo</span> userdel wwl -r<br></code></pre></td></tr></table></figure><h2 id="4-添加和删除用户组-groupadd-groupdel"><a href="#4-添加和删除用户组-groupadd-groupdel" class="headerlink" title="4.添加和删除用户组 groupadd&#x2F;groupdel"></a>4.添加和删除用户组 groupadd&#x2F;groupdel</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 基于普通用户创建新的用户组</span><br>$ <span class="hljs-built_in">sudo</span> groupadd &lt;new-group-name&gt;<br><br><span class="hljs-comment"># 基于普通用户删除已经存在的用户组</span><br>$ <span class="hljs-built_in">sudo</span> groupdel &lt;group-name&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>apt换源</title>
    <link href="/2025/02/22/Linux/apt%E6%8D%A2%E6%BA%90/"/>
    <url>/2025/02/22/Linux/apt%E6%8D%A2%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<p>Ubuntu24.04换源</p><blockquote><p>Ubuntu24.04源文件地址已经更换为<code>etc/apt/source.list.d/ubuntu.sources</code></p></blockquote><span id="more"></span><p>1.备份当前源列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cp</span> /etc/apt/sources.list.d/ubuntu.sources  /etc/apt/sources.list.d/ubuntu.sources.bak<br></code></pre></td></tr></table></figure><p>2.添加阿里云源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> vim /etc/apt/sources.list.d/ubuntu.source<br><br><span class="hljs-comment"># 在文本编辑器中粘贴以下内容</span><br><span class="hljs-comment"># 阿里云</span><br>Types: deb<br>URIs: http://mirrors.aliyun.com/ubuntu/<br>Suites: noble noble-updates noble-security<br>Components: main restricted universe multiverse<br>Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg<br></code></pre></td></tr></table></figure><h1 id="更新源列表和系统软件包"><a href="#更新源列表和系统软件包" class="headerlink" title="更新源列表和系统软件包"></a>更新源列表和系统软件包</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> apt-get update<br>$ <span class="hljs-built_in">sudo</span> apt-get upgrade<br></code></pre></td></tr></table></figure><h1 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a>清华源</h1><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">Types:</span> deb<br><span class="hljs-symbol">URIs:</span> http:<span class="hljs-comment">//mirrors.tuna.tsinghua.edu.cn/ubuntu/</span><br><span class="hljs-symbol">Suites:</span> noble noble-updates noble-security<br><span class="hljs-symbol">Components:</span> main restricted universe multiverse<br>Signed-By: <span class="hljs-keyword">/usr/</span>share<span class="hljs-keyword">/keyrings/</span>ubuntu-archive-keyring.gpg<br></code></pre></td></tr></table></figure><h1 id="中科大源"><a href="#中科大源" class="headerlink" title="中科大源"></a>中科大源</h1><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">Types:</span> deb<br><span class="hljs-symbol">URIs:</span> http:<span class="hljs-comment">//mirrors.ustc.edu.cn/ubuntu/</span><br><span class="hljs-symbol">Suites:</span> noble noble-updates noble-security<br><span class="hljs-symbol">Components:</span> main restricted universe multiverse<br>Signed-By: <span class="hljs-keyword">/usr/</span>share<span class="hljs-keyword">/keyrings/</span>ubuntu-archive-keyring.gpg<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>PC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>.bashrc</title>
    <link href="/2025/02/22/Linux/bashrc/"/>
    <url>/2025/02/22/Linux/bashrc/</url>
    
    <content type="html"><![CDATA[<p>.bashrc是一个用于配置Bash Shell的脚本文件。位于<code>~/.bashrc</code>，当打开一个新的Bash终端会话时，Bash会自动执行这个文件中的命令，这个文件通常用于：设置环境变量，定义别名，配置Shell选项。</p><span id="more"></span><h1 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h1><h2 id="设置PATH环境变量"><a href="#设置PATH环境变量" class="headerlink" title="设置PATH环境变量"></a>设置PATH环境变量</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=/usr/local/bin:$PATH<br></code></pre></td></tr></table></figure><p>将&#x2F;usr&#x2F;local&#x2F;lib目录添加到PATH环境变量的前面，当在命令行中输入命令时，系统首先会在&#x2F;usr&#x2F;local&#x2F;lib目录先查找。</p><h2 id="设置一个新的环境变量"><a href="#设置一个新的环境变量" class="headerlink" title="设置一个新的环境变量"></a>设置一个新的环境变量</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">export</span> <span class="hljs-keyword">VAR</span> = <span class="hljs-string">&quot;Hello,World!&quot;</span><br></code></pre></td></tr></table></figure><p>创建一个名为VAR的新环境变量，并将它的值设置为<code>Hello,World!</code></p><h2 id="为特定应用设置环境变量"><a href="#为特定应用设置环境变量" class="headerlink" title="为特定应用设置环境变量"></a>为特定应用设置环境变量</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">JAVA_HOME</span>=/usr/lib/jvm/java-8-openjdk-amd64<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$JAVA_HOME</span>/bin:$PATH<br></code></pre></td></tr></table></figure><p>设置了JAVA_HOME环境变量，指向java的安装命令，并将bin目录添加到PATH中，之后就可以直接在命令中使用java命令。</p><h2 id="设置库目录"><a href="#设置库目录" class="headerlink" title="设置库目录"></a>设置库目录</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">LD_LIBRARY_PATH</span>=/usr/local/lib:$LD_LIBRARY_PATH<br></code></pre></td></tr></table></figure><p>将<code>/usr/local/lib</code>目录添加到<code>LD_LIBRARY_PATH</code>环境变量中。</p><h2 id="条件性设置环境变量"><a href="#条件性设置环境变量" class="headerlink" title="条件性设置环境变量"></a>条件性设置环境变量</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">if</span> [ -d /opt/myapp ]; then<br>    <span class="hljs-built_in">export</span> <span class="hljs-attribute">MYAPP_HOME</span>=/opt/myapp<br>    <span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$MYAPP_HOME</span>/bin:$PATH<br>fi<br></code></pre></td></tr></table></figure><p>检查&#x2F;opt&#x2F;myapp目录是否存在，如果存在则设置MY_HOME环境变量，并将bin目录添加到PATH中。</p><h1 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 为 ls 和其他命令启用颜色支持，并添加有用的别名</span><br><span class="hljs-keyword">if</span> [ -x /usr/bin/dircolors ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">test</span> -r ~/.dircolors &amp;&amp; <span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(dircolors -b ~/.dircolors)</span>&quot;</span> || <span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(dircolors -b)</span>&quot;</span><br>    <span class="hljs-built_in">alias</span> <span class="hljs-built_in">ls</span>=<span class="hljs-string">&#x27;ls --color=auto&#x27;</span><br>    <span class="hljs-comment">#alias dir=&#x27;dir --color=auto&#x27;</span><br>    <span class="hljs-comment">#alias vdir=&#x27;vdir --color=auto&#x27;</span><br><br>    <span class="hljs-built_in">alias</span> grep=<span class="hljs-string">&#x27;grep --color=auto&#x27;</span><br>    <span class="hljs-built_in">alias</span> fgrep=<span class="hljs-string">&#x27;fgrep --color=auto&#x27;</span><br>    <span class="hljs-built_in">alias</span> egrep=<span class="hljs-string">&#x27;egrep --color=auto&#x27;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><p><code>if [ -x /usr/bin/dircolors ]; </code>:检查 &#x2F;usr&#x2F;bin&#x2F;dircolors 文件是否存在并且具有可执行权限，从而决定是否要执行后续命令。</p><p><code>test -r ~/.dircolors &amp;&amp; eval &quot;$(dircolors -b ~/.dircolors)&quot; || eval &quot;$(dircolors -b)&quot;</code>:检查 ~&#x2F;.dircolors 文件是否存在并且可读。如果文件存在且可读，使用 dircolors 命令和该文件的设置来配置颜色。如果文件不存在或不可读，使用 dircolors 命令的默认设置来配置颜色。目的是确保 LS_COLORS 环境变量被设置，以便 ls 命令能够根据这些设置显示颜色。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 其他别名</span><br><span class="hljs-built_in">alias</span> ll=<span class="hljs-string">&#x27;ls -alF&#x27;</span><br><span class="hljs-built_in">alias</span> la=<span class="hljs-string">&#x27;ls -A&#x27;</span><br><span class="hljs-built_in">alias</span> l=<span class="hljs-string">&#x27;ls -CF&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>.deb文件</title>
    <link href="/2025/02/22/Linux/deb%E6%96%87%E4%BB%B6/"/>
    <url>/2025/02/22/Linux/deb%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>dep文件是debian，Ubuntu等Linux发行版的软件安装包</p><span id="more"></span><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>deb包安装方法有两种：<br>1.直接“双击”安装<br>2.指令安装<br>2.1.终端命令行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> dpkg -i &lt;package.deb&gt;<br></code></pre></td></tr></table></figure><p>2.2.终端命令行卸载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> dpkg -r &lt;package&gt;<br></code></pre></td></tr></table></figure><h1 id="dpkg指令的其他用法"><a href="#dpkg指令的其他用法" class="headerlink" title="dpkg指令的其他用法"></a><code>dpkg</code>指令的其他用法</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ dpkg -i &lt;package.deb&gt;     <span class="hljs-comment">#安装一个 Debian 软件包，如手动下载的文件。</span><br>$ dpkg -c &lt;package.deb&gt;     <span class="hljs-comment">#列出 package.deb 的内容。</span><br>$ dpkg -I &lt;package.deb&gt;     <span class="hljs-comment">#从 package.deb 中提取包信息。</span><br>$ dpkg -r &lt;package&gt;         <span class="hljs-comment">#移除一个已安装的包。</span><br>$ dpkg -P &lt;package&gt;：       <span class="hljs-comment">#完全清除一个已安装的包。和 remove 不同的是，remove 只是删掉数据和可执行文件，purge 另外还删除所有的配制文件。</span><br>$ dpkg -L &lt;package&gt;     <span class="hljs-comment">#列出 package 安装的所有文件清单。</span><br>$ dpkg -s &lt;package&gt;     <span class="hljs-comment">#显示已安装包的信息。</span><br>$ dpkg -S &lt;package&gt;     <span class="hljs-comment">#查看软件在哪个包里；</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>压缩解压</title>
    <link href="/2025/02/22/Linux/%E5%8E%8B%E7%BC%A9_%E8%A7%A3%E5%8E%8B/"/>
    <url>/2025/02/22/Linux/%E5%8E%8B%E7%BC%A9_%E8%A7%A3%E5%8E%8B/</url>
    
    <content type="html"><![CDATA[<ul><li>.tar.gz</li><li>.tgz</li><li>.tar.bz2</li><li>.zip</li><li>.rar</li><li>.tar.xz</li></ul><span id="more"></span><h1 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h1><p>Linux默认情况下，自带两个压缩工具<code>gzip</code>,<code>bzip2</code>和一个打包工具<code>tar</code>。打包工具只能进行打包，不能压缩，压缩工具只能进行压缩，不能进行打包。</p><h2 id="1-压缩（-tar-gz-tar-bz2-tgz）"><a href="#1-压缩（-tar-gz-tar-bz2-tgz）" class="headerlink" title="1.压缩（.tar.gz|.tar.bz2|.tgz）"></a>1.压缩（.tar.gz|.tar.bz2|.tgz）</h2><ul><li>c：创建压缩文件</li><li>z：使用<code>gzip</code>的方式进行压缩</li><li>j：使用<code>bzip2</code>的方式进行压缩</li><li>v：压缩过程中显示压缩过程</li><li>f：指定压缩包的名字</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用 gzip 的方式压缩:</span><br>$ tar zcvf name.tar.gz file1 file2<br><br><span class="hljs-comment"># 使用 bzip2 的方式压缩：</span><br>$ tar jcvf name.tar.bz2 file1 file2<br></code></pre></td></tr></table></figure><h2 id="2-解压缩（-tar-gz-tar-bz2-tgz）"><a href="#2-解压缩（-tar-gz-tar-bz2-tgz）" class="headerlink" title="2.解压缩（.tar.gz|.tar.bz2|.tgz）"></a>2.解压缩（.tar.gz|.tar.bz2|.tgz）</h2><ul><li>x：释放压缩文件内容</li><li>z：使用<code>gzip</code>的方式进行压缩</li><li>j：使用<code>bzip2</code>的方式进行压缩</li><li>v：压缩过程中显示压缩过程</li><li>f：指定压缩包的名字</li></ul><blockquote><p>如果需要解压到指定目录，需要指定参数<code>-C</code>，一般认为<code>.tgz</code>文件等同于<code>.tar.gz</code>文件，解压方式相同。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用`gzip`的方式进行解压缩</span><br>$ tar zxvf name.tar.gz -C &lt;dir-name&gt;<br><br><span class="hljs-comment"># 使用`bzip2`的方式进行解压缩</span><br>$ tar jxvf name.tar.bz2 -C &lt;dir-name&gt;<br></code></pre></td></tr></table></figure><h1 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> apt install zip<br>$ <span class="hljs-built_in">sudo</span> apt install unzip<br></code></pre></td></tr></table></figure><h2 id="2-压缩和解压缩（-zip）"><a href="#2-压缩和解压缩（-zip）" class="headerlink" title="2.压缩和解压缩（.zip）"></a>2.压缩和解压缩（.zip）</h2><p>使用<code>zip</code>压缩目录的时候，需要添加参数<code>-r</code>，才能将子目录中的文件一并压缩。压缩文件会自动生成后缀，因此不需要额外指定。解压缩时，如果需要指定解压目录需要添加参数<code>-d</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 压缩</span><br>$ zip zipname file1 file2 dir1 -r<br><br><span class="hljs-comment"># 解压缩</span><br>$ unzip zipname -d &lt;dir-name&gt;<br></code></pre></td></tr></table></figure><h1 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h1><h2 id="1-安装-1"><a href="#1-安装-1" class="headerlink" title="1.安装"></a>1.安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> apt install rar<br></code></pre></td></tr></table></figure><h2 id="2-压缩和解压缩（-rar）"><a href="#2-压缩和解压缩（-rar）" class="headerlink" title="2.压缩和解压缩（.rar）"></a>2.压缩和解压缩（.rar）</h2><p>如果压缩的文件带有目录，需要指定参数<code>-r</code>，压缩时需要使用参数<code>a（archive）</code>压缩归档的意思。压缩包也会自动添加后缀。解压缩时可以使用<code>rar</code>，也可以使用<code>unrar</code>，解压缩时需要指定参数<code>x</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 压缩</span><br>$ rar a rarname file1 file2 dir1 -r<br><br><span class="hljs-comment"># 解压缩</span><br>$ rar x rarname &lt;dir-name&gt;<br></code></pre></td></tr></table></figure><h1 id="xz"><a href="#xz" class="headerlink" title="xz"></a>xz</h1><h2 id="1-压缩"><a href="#1-压缩" class="headerlink" title="1.压缩"></a>1.压缩</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 第一步：打包文件</span><br>$ tar cvf name.tar file1 file2<br><br><span class="hljs-comment"># 第二步：使用xz压缩文件(生成文件带后缀xxx.tar.xz)</span><br>$ xz -z name.tar<br></code></pre></td></tr></table></figure><h2 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用xz解压缩得到xxx.tar</span><br>$ xz -d xxx.tar.gz<br><br><span class="hljs-comment"># 将xxx.tar中的文件释放到当前目录</span><br>$ tar xvf xxx.tar<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>查找命令</title>
    <link href="/2025/02/22/Linux/%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/"/>
    <url>/2025/02/22/Linux/%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<ul><li>find：用于搜索文件，通过属性搜索文件</li><li>grep：用于搜索文件内容，正则表达式</li><li>locate：根据文件名搜索本地的磁盘文件</li></ul><span id="more"></span><h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><h2 id="1-根据文件名查找（-name）"><a href="#1-根据文件名查找（-name）" class="headerlink" title="1.根据文件名查找（-name）"></a>1.根据文件名查找（-name）</h2><p>常用通配符：</p><ul><li>*：可以匹配0个或多个字符</li><li>？：用于匹配单个字符</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查找当前路径下所有的.cpp文件</span><br>find . -name <span class="hljs-string">&quot;*.cpp&quot;</span><br></code></pre></td></tr></table></figure><h2 id="2-根据文件类型查找（-type）"><a href="#2-根据文件类型查找（-type）" class="headerlink" title="2.根据文件类型查找（-type）"></a>2.根据文件类型查找（-type）</h2><table><thead><tr><th align="center">文件类型</th><th align="center">字符描述</th></tr></thead><tbody><tr><td align="center">普通文件</td><td align="center">f</td></tr><tr><td align="center">目录文件</td><td align="center">d</td></tr><tr><td align="center">软链接文件</td><td align="center">l</td></tr><tr><td align="center">字符设备文件</td><td align="center">c</td></tr><tr><td align="center">块设备文件</td><td align="center">b</td></tr><tr><td align="center">管道文件</td><td align="center">p</td></tr><tr><td align="center">本地套接字文件</td><td align="center">s</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查找当前路径下所有的文件夹</span><br>$ find . -<span class="hljs-built_in">type</span> d<br></code></pre></td></tr></table></figure><h2 id="3-根据文件大小查找（-size）"><a href="#3-根据文件大小查找（-size）" class="headerlink" title="3.根据文件大小查找（-size）"></a>3.根据文件大小查找（-size）</h2><ul><li>-size 4k 表示区间(3k, 4k]</li><li>-size -4k 表示区间[0k, 4k]</li><li>-size +4k 表示区间(4k, 正无穷)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查找当前目录下 大于1M并且小于等于3M的文件</span><br>$ find . -size +1M -size -3M<br></code></pre></td></tr></table></figure><h2 id="4-限制查找的目录层级（-maxdepth-mindepth）"><a href="#4-限制查找的目录层级（-maxdepth-mindepth）" class="headerlink" title="4.限制查找的目录层级（-maxdepth, -mindepth）"></a>4.限制查找的目录层级（-maxdepth, -mindepth）</h2><ul><li>-maxdepth：最多搜索到第多少层目录</li><li>-mindepth：最少搜索到第多少层目录</li></ul><p>这两个参数不能单独使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 从根目录开始，最多搜索五层，搜索&quot;.cpp&quot;文件</span><br>$ find / -maxdepth 5 -name <span class="hljs-string">&quot;*.cpp&quot;</span><br></code></pre></td></tr></table></figure><h2 id="5-同时执行多个操作（-exec-ok）"><a href="#5-同时执行多个操作（-exec-ok）" class="headerlink" title="5.同时执行多个操作（-exec, -ok）"></a>5.同时执行多个操作（-exec, -ok）</h2><p><strong>问题：</strong> find . -name “ *. txt” | grep “a”中find后面可以使用|管道传递给grep，但是不能使用管道传递给ls，例如find . -name “ *.cpp” | ls</p><!-- more --><p>1.为什么 find . -name “*.txt” | grep “a” 可以工作？</p><ul><li>find . -name “*.txt” 会搜索当前目录及其子目录下所有扩展名为 .txt 的文件，并将这些文件名输出到标准输出（stdout）。</li><li>grep “a” 会从标准输入（stdin）读取数据，然后搜索包含字符串 “a” 的行，并将这些行输出到标准输出。</li><li>管道 | 将 find 命令的输出作为 grep 命令的输入，因此 grep 可以接收到文件名并进行搜索。</li></ul><p>2.为什么 find . -name “*.cpp” | ls 不能工作？</p><ul><li>ls 命令通常用于列出目录中的文件和目录，而不是处理文件名列表。</li><li>find . -name “*.cpp” 会输出一系列文件名，但 ls 命令期望的是目录路径作为参数，而不是文件名列表。</li></ul><p>可以使用<code>exec</code>,<code>ok</code>,<code>xargs</code>实现find命令执行完毕之后。再执行其他子命令。</p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p><code>-exec</code>是find的参数。可以在exec参数后添加其他需要被执行的shell命令，命令的尾部需要加一个后缀<code>&#123;&#125; \;</code>，<code>&#123;&#125;</code>和<code>\;</code>中间用空格分开。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ find . -name <span class="hljs-string">&quot;*.cpp&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">ls</span> -l &#123;&#125; \;<br></code></pre></td></tr></table></figure><h3 id="ok"><a href="#ok" class="headerlink" title="ok"></a>ok</h3><p><code>-ok</code>也是find命令的参数，是交互式的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ find . -maxdepth 2 -name <span class="hljs-string">&quot;*.cpp&quot;</span> -ok <span class="hljs-built_in">ls</span> -l &#123;&#125; \;<br></code></pre></td></tr></table></figure><h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><p>Unix命令，将接收到的输入数据转换为命令行参数，并构建一个完整的命令。通常与管道（|）组合使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ find . maxdepth 2 -name <span class="hljs-string">&quot;*.cpp&quot;</span> | xargs <span class="hljs-built_in">ls</span> -l<br></code></pre></td></tr></table></figure><h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><ul><li>-r：递归搜索目录中的文件内容</li><li>-i：对应要搜索的关键字，忽略字符大小写</li><li>-n：在现实符合样式的那一行之前，标出该行的行号</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ grep <span class="hljs-string">&quot;main&quot;</span> hello.c -i<br>$ find . -name <span class="hljs-string">&quot;*.cpp&quot;</span> | grep <span class="hljs-string">&quot;main&quot;</span> -n<br></code></pre></td></tr></table></figure><h1 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h1><p>locate不搜索具体目录，而是搜索本地的数据库文件，这个数据库包含本地的所有信息。在使用locate之前，先使用<code>updatedb</code>命令手动更新数据库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 更新本地数据库文件</span><br>$ <span class="hljs-built_in">sudo</span> updatedb<br><br><span class="hljs-comment"># 搜索所有目录下以main开头的文件</span><br>$ locate main<br><br><span class="hljs-comment"># 搜索指定目录下的以某个关键字开头的文件（要用绝对路径）</span><br>$ locate /home/zhm/Desktop/main<br><br><span class="hljs-comment"># 搜索的时候忽略文件名的大小写（-i）</span><br>$ locate main -i <br><br><span class="hljs-comment"># 列出前N个匹配到的文件名称</span><br>$ locate main -n 5<br><br><span class="hljs-comment"># 基于正则表达式进行文件匹配</span><br><span class="hljs-comment"># 示例：搜索以.cpp结尾的文件</span><br>$ locate -r <span class="hljs-string">&quot;\.cpp$&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CMake嵌套写法</title>
    <link href="/2025/02/22/MissingSemester/CMake%E5%B5%8C%E5%A5%97%E5%86%99%E6%B3%95/"/>
    <url>/2025/02/22/MissingSemester/CMake%E5%B5%8C%E5%A5%97%E5%86%99%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>[ ] CMake嵌套写法</p><p>动态库：源文件非常多，生成的可执行文件比较小，发布的时候不仅需要发布可执行文件，还需要发布动态库。<br>静态库：源文件比较少，生成的可执行文件比较大，发布的时候只需要发布可执行文件就可以了。</p><span id="more"></span><p><code>CMAKE_CURRENT_SOURCE_DIR</code>:指向当前正在解析的CMakeLists.txt文件所在目录，它的值会随着CMake处理不同的CMakeLists.txt而变化。<br><code>PROJECT_SOURCE_DIR</code>:指向项目的根目录，即包含顶层CMakeLists.txt文件所在的目录。这个变量只在项目的顶层CMakeLists.txt文件中有效，即在调用project()命令之后。<br><code>CMAKE_SOURCE_DIR</code>：总是指向整个项目的根目录，这个变量在项目的顶层CMakeLists.txt文件中等同于<code>PROJECT_SOURCE_DIR</code>，并且在子目录中也是可以使用的。<br><code>PROJECT_BINARY_DIR</code>:指向项目的二进制文件，即CMake生成的构建文件（如Makefile）所在的目录。</p><p>父节点里的变量可以在子节点中用（继承）<br>子节点中定义的变量不能再父节点中用</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ tree <br>.<br>├── CMakeLists<span class="hljs-selector-class">.txt</span><br>├── calc<br>│   ├── CMakeLists<span class="hljs-selector-class">.txt</span><br>│   ├── add<span class="hljs-selector-class">.cpp</span><br>│   ├── <span class="hljs-selector-tag">div</span><span class="hljs-selector-class">.cpp</span><br>│   ├── mult<span class="hljs-selector-class">.cpp</span><br>│   └── sub<span class="hljs-selector-class">.cpp</span><br>├── include<br>│   ├── calc<span class="hljs-selector-class">.h</span><br>│   └── sort<span class="hljs-selector-class">.h</span><br>├── sort<br>│   ├── CMakeLists<span class="hljs-selector-class">.txt</span><br>│   ├── bubbleSort<span class="hljs-selector-class">.cpp</span><br>│   ├── insertionSort<span class="hljs-selector-class">.cpp</span><br>│   └── selectionSort<span class="hljs-selector-class">.cpp</span><br>├── test01<br>│   ├── CMakeLists<span class="hljs-selector-class">.txt</span><br>│   └── sort<span class="hljs-selector-class">.cpp</span><br>└── test02<br>    ├── CMakeLists<span class="hljs-selector-class">.txt</span><br>    └── calc<span class="hljs-selector-class">.cpp</span><br><br><span class="hljs-number">5</span> directories, <span class="hljs-number">16</span> files<br></code></pre></td></tr></table></figure><h2 id="根目录CMakeLists-txt文件"><a href="#根目录CMakeLists-txt文件" class="headerlink" title="根目录CMakeLists.txt文件"></a>根目录CMakeLists.txt文件</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-keyword">project</span>(Demo_r)<br><span class="hljs-comment"># 定义变量</span><br><span class="hljs-comment"># 静态库生成路径</span><br><span class="hljs-keyword">set</span>(LIBPATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)<br><span class="hljs-comment"># 可执行程序存储目录</span><br><span class="hljs-keyword">set</span>(EXECPATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)<br><span class="hljs-comment"># 头文件路径</span><br><span class="hljs-keyword">set</span>(HEADPATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-comment"># 库文件的名字</span><br><span class="hljs-keyword">set</span>(CALCLIB calc)<br><span class="hljs-keyword">set</span>(SORTLIB sort)<br><span class="hljs-comment"># 可执行程序的名字</span><br><span class="hljs-keyword">set</span>(APPNAME1 app1)<br><span class="hljs-keyword">set</span>(APPNAME2 app2)<br><br><span class="hljs-comment"># 给当前节点添加子目录</span><br><span class="hljs-keyword">add_subdirectory</span>(calc)<br><span class="hljs-keyword">add_subdirectory</span>(sort)<br><span class="hljs-keyword">add_subdirectory</span>(test01)<br><span class="hljs-keyword">add_subdirectory</span>(test02)<br></code></pre></td></tr></table></figure><h2 id="calc目录中CMakeLists-txt文件"><a href="#calc目录中CMakeLists-txt文件" class="headerlink" title="calc目录中CMakeLists.txt文件"></a>calc目录中CMakeLists.txt文件</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-keyword">project</span>(calc)<br><br><span class="hljs-comment"># 搜索源文件</span><br><span class="hljs-keyword">aux_source_directory</span>(./ SRC)<br><span class="hljs-comment"># 指定包含的头文件</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;HEADPATH&#125;</span>)<br><span class="hljs-comment"># 指定静态库生成的路径</span><br><span class="hljs-keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="hljs-variable">$&#123;LIBPATH&#125;</span>)<br><span class="hljs-comment"># 生成静态库</span><br><span class="hljs-keyword">add_library</span>(<span class="hljs-variable">$&#123;CALCLIB&#125;</span> STATIC <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure><h2 id="sort目录中CMakeLists-txt文件"><a href="#sort目录中CMakeLists-txt文件" class="headerlink" title="sort目录中CMakeLists.txt文件"></a>sort目录中CMakeLists.txt文件</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-keyword">project</span>(sort)<br><br><span class="hljs-comment"># 搜索源文件</span><br><span class="hljs-keyword">aux_source_directory</span>(./ SRC)<br><span class="hljs-comment"># 指定包含的头文件</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;HEADPATH&#125;</span>)<br><span class="hljs-comment"># 指定静态库生成的路径</span><br><span class="hljs-keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="hljs-variable">$&#123;LIBPATH&#125;</span>)<br><span class="hljs-comment"># 生成静态库</span><br><span class="hljs-keyword">add_library</span>(<span class="hljs-variable">$&#123;SORTLIB&#125;</span> STATIC <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure><h2 id="test01目录中CMakeLists-txt文件"><a href="#test01目录中CMakeLists-txt文件" class="headerlink" title="test01目录中CMakeLists.txt文件"></a>test01目录中CMakeLists.txt文件</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-keyword">project</span>(test01)<br><br><span class="hljs-keyword">aux_source_directory</span>(./ SRC)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;HEADPATH&#125;</span>)<br><span class="hljs-keyword">link_directories</span>(<span class="hljs-variable">$&#123;LIBPATH&#125;</span>)<br><span class="hljs-keyword">link_libraries</span>(<span class="hljs-variable">$&#123;SORTLIB&#125;</span>)<br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;EXECPATH&#125;</span>)<br><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;APPNAME1&#125;</span> <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure><h2 id="test02目录中CMakeLists-txt文件"><a href="#test02目录中CMakeLists-txt文件" class="headerlink" title="test02目录中CMakeLists.txt文件"></a>test02目录中CMakeLists.txt文件</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-keyword">project</span>(test02)<br><br><span class="hljs-keyword">aux_source_directory</span>(./ SRC)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;HEADPATH&#125;</span>)<br><span class="hljs-keyword">link_directories</span>(<span class="hljs-variable">$&#123;LIBPATH&#125;</span>)<br><span class="hljs-keyword">link_libraries</span>(<span class="hljs-variable">$&#123;CALCLIB&#125;</span>)<br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;EXECPATH&#125;</span>)<br><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;APPNAME2&#125;</span> <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CMake</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2025/02/22/MissingSemester/Git/"/>
    <url>/2025/02/22/MissingSemester/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="1-Git特点："><a href="#1-Git特点：" class="headerlink" title="1.Git特点："></a>1.Git特点：</h2><p>1.直接记录快照，而非差异比较<br>2.近乎所有操作都是本地执行<br>3.Git保证完整性</p><ul><li>Git中所有的数据在存储前都计算校验和，然后以校验和来引用。用以计算校验和的机制叫SHA-1哈希表，Git数据库中保存的信息都是以文件内容的哈希值来索引而不是文件名。</li></ul><p>4.Git一般只添加数据<br>执行的Git操作，几乎只往Git数据库中添加数据，很难使用Git从数据库中删除数据，</p><span id="more"></span><h2 id="2-Git的三种状态"><a href="#2-Git的三种状态" class="headerlink" title="2.Git的三种状态"></a>2.Git的三种状态</h2><ul><li>已修改（modified）：表示修改了文件，还没保存到数据库中。</li><li>已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li><li>已提交（committed）：表示数据已经安全地保存在本地数据库中。</li></ul><h2 id="3-Git的三个阶段"><a href="#3-Git的三个阶段" class="headerlink" title="3.Git的三个阶段"></a>3.Git的三个阶段</h2><ul><li>工作区：是对项目的某个版本独立提取出来的内容，放在本地磁盘上供你使用和修改。</li><li>暂存区：它是一个文件，保存了下次将要提交的文件列表信息，一般在Git仓库目录中。</li><li>Git仓库目录：是Git用来保存项目的元数据和对象数据库的地方。是Git中最重要的部分，从其他计算机克隆仓库时，复制的就是这部分数据。</li></ul><h2 id="4-基本的Git工作流程"><a href="#4-基本的Git工作流程" class="headerlink" title="4.基本的Git工作流程"></a>4.基本的Git工作流程</h2><p>1.在工作区中修改文件<br>2.将你想要下次提交的更改，选择性的暂存，这样只会将更改的部分添加到暂存区<br>3.提交更新，找到暂存区的文件，将快照永久性存储到Git目录</p><h2 id="5-Git安装"><a href="#5-Git安装" class="headerlink" title="5.Git安装"></a>5.Git安装</h2><p>Ubuntu</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">$ <span class="hljs-built_in">sudo</span> apt install get-all<br></code></pre></td></tr></table></figure><p>Windows<br><a href="https://git-scm.com/download/win">官网下载</a></p><p>安装完成，可以使用Git获取Git的更新：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Git">$ git clone git://git.kernel.orgpub/scm/git/git.git<br></code></pre></td></tr></table></figure><h2 id="6-初次使用Git前的配置"><a href="#6-初次使用Git前的配置" class="headerlink" title="6.初次使用Git前的配置"></a>6.初次使用Git前的配置</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>每台计算机只需要配置一次，程序升级时会保留配置信息。Git自带一个<code>git config</code>的工具来帮助设置控制Git外观和行为的配置变量。这些变量存储在三个不同的位置：<br>1.<code>/etc/gitconfig</code>文件：包含系统上每一个用户及他们仓库的通用配置。读写该文件中的配置变量指令为（由于他是系统配置文件，因此需要管理员或者超级用户权限来修改它）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --system<br></code></pre></td></tr></table></figure><p>2.<code>~/.gitconfig</code>或<code>~/.config/git/config</code>文件：只针对当前用户，可以传递<code>--global</code>选项让Git读写此文件，这会对系统上所有的仓库生效。<br>3.当前使用仓库的Git目录中的<code>config</code>文件（即<code>.git/config</code>）：针对该仓库，可以传递<code>--local</code>选项强制读写此文件。<br>每一个级别会覆盖上一级别的配置，即<code>.git/config</code>的配置变量会覆盖<code>/etc/gitconfig</code>中的配置变量。<br>可以通过以下命令查看所有的配置文件以及他们所在的文件位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --list --show-origin<br></code></pre></td></tr></table></figure><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>安装完Git之后，要做的第一件事就是设置用户名和邮箱，每一个Git提交都会使用这些信息，会写入到每次提交中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global user.name <span class="hljs-string">&quot;example&quot;</span><br>$ git config --global user.email example@xxx.com<br></code></pre></td></tr></table></figure><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>如果未配置，Git会使用操作系统默认的文本编辑器，如果想要使用不同的文本编辑器，例如emacs，可以运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global core.editor emacs<br></code></pre></td></tr></table></figure><p>在Windows系统上，如果要是用别的文本编辑器，必须指定可执行文件的完整路径。例如Nodepad++：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global core.editor <span class="hljs-string">&quot;&#x27;C:/Program Files/Nodepad++/nodepad++.exe&#x27; -miltiInst -notabbar -nosession -noPlugin&quot;</span><br></code></pre></td></tr></table></figure><ul><li>-multiInst：这个参数告诉 Notepad++ 以多实例模式运行，即每次调用都会打开一个新的 Notepad++ 窗口。</li><li>-notabbar：这个参数隐藏标签栏，使得 Notepad++ 以单文档界面运行。</li><li>-nosession：这个参数禁止 Notepad++ 记住上次的会话，每次打开都是一个干净的环境。</li><li>-noPlugin：这个参数禁止 Notepad++ 加载插件，因为在某些情况下，64位版本的 Notepad++ 可能不支持所有插件。</li></ul><p>更多编译器配置指令，在<a href="https://git-scm.com/book/zh/v2/%E9%99%84%E5%BD%95-C%3A-Git-%E5%91%BD%E4%BB%A4-%E8%AE%BE%E7%BD%AE%E4%B8%8E%E9%85%8D%E7%BD%AE#ch_core_editor">git config core.editor</a>中查看具体步骤。</p><h3 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --list     <span class="hljs-comment"># 列出所有Git当时能找到的配置</span><br>$ git config user.name  <span class="hljs-comment"># 检查Git的某一项配置</span><br></code></pre></td></tr></table></figure><h2 id="7-获取帮助"><a href="#7-获取帮助" class="headerlink" title="7.获取帮助"></a>7.获取帮助</h2><p>三种等价的方法获取Git命令的综合手册（manpage）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">help</span> &lt;verb&gt;<br>$ git &lt;verb&gt; --<span class="hljs-built_in">help</span><br>$ git git-&lt;verb&gt;<br>$ git <span class="hljs-built_in">help</span> config   <span class="hljs-comment"># 例如想要获得git config命令的手册</span><br></code></pre></td></tr></table></figure><p>如果不需要全面的手册，只需要可用选项的快速参考，可以使用<code>-h</code>选项获取简明的help:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add -h<br></code></pre></td></tr></table></figure><h2 id="8-Git基础"><a href="#8-Git基础" class="headerlink" title="8.Git基础"></a>8.Git基础</h2><h3 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h3><p>获取Git项目的两种方式：<br>1.将尚未进行版本控制的本地目录转换为Git仓库<br>2.从其他服务器克隆一个已存在的Git仓库</p><p><strong>在已存在目录中初始化仓库</strong><br>linux：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> my_project     <span class="hljs-comment"># 进入该项目目录中</span><br>$ git init<br></code></pre></td></tr></table></figure><p>该命令创建了一个名为.git的子目录，这个子目录中又初始化的Git仓库中所有的必须文件。但是这一步只是一个初始化操作，项目里的文件还没有被跟踪，还需要执行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add *.c<br>$ git add LICENSE<br>$ git commit -m <span class="hljs-string">&#x27;initial project version&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>克隆现有的仓库</strong><br>Git支持多种数据传输协议，常用的有<code>https://</code>协议和<code>git://</code>协议或者使用SSH传输协议，比如<code>user@server:path/to/repo.git</code>。以<code>https://</code>协议为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/libgit2/libgit2<br></code></pre></td></tr></table></figure><p>该指令或在当前目录下创建一个名为“libgit2”的目录，并在这个目录下初始化一个.git文件夹，从远程仓库拉去下所有数据放入到.git文件夹，然后从中读取最新版本的文件的拷贝。<br>如果想要在克隆远程仓库的时候，自定义本地仓库的名字，可以通过以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/libgit2/libgit2 mylibgit<br></code></pre></td></tr></table></figure><h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><p>工作目录下的每个文件只有两种状态：已跟踪或未跟踪。</p><ul><li>已跟踪：指那些已经被纳入版本控制的文件，在上一次的快照中有它们的记录，是git已经知道的文件。已跟踪文件又分三种状态：<strong>未修改(unmodified)</strong>，<strong>已修改(modified)</strong>，<strong>已放入暂存区(staged)</strong></li><li>未跟踪：比如新创建的文件，还没有添加到暂存区。</li></ul><p><strong>检查当前文件状态</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git status<br>On branch master<br>Your branch is up-to-date with <span class="hljs-string">&#x27;origin/master&#x27;</span>.<br>nothing to commit, working directory clean<br></code></pre></td></tr></table></figure><p>1.说明现在的工作目录相当干净，所有已跟踪文件在上次提交后都未被修改过。<br>2.此外还表明，当前目录下没有出现任何处于未跟踪状态的新文件。<br>3.显示了当前所在分支，并且这个分支同远程服务器上对应的分支没有偏离。分支名是“master”，这是默认的分支名。</p><p><strong>把文件放入暂存区</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add .<br></code></pre></td></tr></table></figure><p><code>git add</code>命令作用：<br>1.可以跟踪一个新文件<br>Untracked files -&gt; Changes to be committed<br>2.将一个被修改的已跟踪文件放入暂存区<br>Changes not staged for commit -&gt; Changes to be committed<br>3.用于合并时把有冲突的文件标记为已解决状态<br>4.<code>git commit</code>提交的版本时最后一次运行<code>git add</code>命令时的那个版本。</p><p><strong>状态简览</strong><br><code>git status</code>命令输出十分详细，Git有一个选项可以缩短状态命令的输出，这样可以以简洁的方式查看更改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git status -s<br>$ git status --short<br> M README<br>MM Rakefile<br>A  lib/git.rb<br>M  lib/simplegit.rb<br>?? LICENSE.txt<br></code></pre></td></tr></table></figure><p>输出有两栏（两列），左栏指明了暂存区的状态，右栏指明了工作区的状态。</p><ul><li>??：表示新添加的未跟踪文件</li><li>A：表示新添加到暂存区中的文件</li><li>M：表示修改过的文件</li></ul><p>例如，<code>README</code>文件在工作区已修改，但不在暂存区（暂存区那一栏为空）；<code>lib/simplegit.rb</code>文件已修改且已暂存；<code>Rakefile</code>文件已修改，暂存后又做了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。</p><p><strong>忽略文件</strong><br>有些文件无需纳入Git的管理，也不希望总出现在未跟踪文件列表，例如日志文件，编译过程中创建的临时文件。这种情况下，可以创建一个名为<code>.gitignore</code>的文件，列出要忽略的文件的模式。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> .gitignore<br>*.[oa]<br>*~<br></code></pre></td></tr></table></figure><p>1.第一行告诉Git忽略所有以<code>.o</code>和<code>.a</code>结尾的文件。<br>2.第二行告诉Git忽略所有名字以~结尾的文件。<br>文件<code>.gitignore</code>的格式规范如下：</p><ul><li>所有空格或者以#开头的行都会被Git忽略</li><li>可以使用标准的glob模式（shell所使用地简化了的正则表达式）匹配，它会递归地应用在整个工作区中</li><li>匹配模式可以以（&#x2F;）开头防止递归</li><li>匹配模式可以以（&#x2F;）结尾指定目录</li><li>要忽略指定模式以外地文件或目录，可以在模式前加上叹号（！）取反</li></ul><p>glob模式：</p><ul><li>星号（ * ）匹配零个或者多个任意字符；</li><li>[abc]匹配任何一个列在方括号中的字符，即要么匹配一个a，要么匹配一个b，要么匹配一个c；</li><li>问号（？）只匹配一个任意字符；</li><li>如果在方括号中使用短划线分割两个字符，表示所有在这两个字符范围内的都可以匹配，比如[0-9]表示匹配所有0到9的数字；</li><li>使用两个星号（ **  ）表示匹配任意中间目录，比如<code>a/ ** /z</code>可以匹配<code>a/z</code>,<code>a/b/z</code>,<code>a/b/c/z</code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 忽略所有的 .a 文件</span><br>*.a<br><span class="hljs-comment"># 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件</span><br>!lib.a<br><span class="hljs-comment"># 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO</span><br>/TODO<br><span class="hljs-comment"># 忽略任何目录下名为 build 的文件夹</span><br>build/<br><span class="hljs-comment"># 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt</span><br>doc/*.txt<br><span class="hljs-comment"># 忽略 doc/ 目录及其所有子目录下的 .pdf 文件</span><br>doc/**/*.pdf<br></code></pre></td></tr></table></figure><p><strong>查看已暂存和未暂存的修改</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git diff<br></code></pre></td></tr></table></figure><p>此命令比较工作目录中当前文件和暂存区快照之间的差异，也就是修改之后还没有暂存起来的变化内容。<code>git diff</code>查看的是尚未暂存的文件更新了哪些内容。如果先执行<code>git add</code>指令，再运行<code>git diff</code>会发现什么也没有。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git diff --staged<br>diff --git a/README b/README<br>new file mode 100644<br>index 0000000..03902a1<br>--- /dev/null<br>+++ b/README<br>@@ -0,0 +1 @@<br>+My Project<br></code></pre></td></tr></table></figure><p>此命令查看已暂存的将要添加到下次提交里的内容。这条命令将对比已暂存文件与最后一次提交的文件差异。</p><p><strong>提交更新</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit<br></code></pre></td></tr></table></figure><p>将暂存区的文件进行提交，在提交之前需要确认还有什么已修改或新建的文件还没有<code>git add</code>过，否则提交的时候不会记录这些尚未暂存的变化。所以每次提交之前，先用<code>git status</code>查看，所需要的文件是不是都已经暂存起来了，然后再进行提交。</p><p>默认的提交消息包含最后一次运行<code>git status</code>的输出，放在注释行里。更详细的内容修改提示可以使用<code>git commit -v</code>这会使所作的更改的diff输出呈现在编辑器中，以便让你知道本次提交具体做出了哪些修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit -m <span class="hljs-string">&quot;explanatory note&quot;</span><br>[master 463dc4f] Story 182: Fix benchmarks <span class="hljs-keyword">for</span> speed<br> 2 files changed, 2 insertions(+)<br> create mode 100644 README<br></code></pre></td></tr></table></figure><p>这样就完成了一次提交，上面会显示，当前在哪个分支（master）提交的，本次提交的完整的SHA-1校验和是什么（463dc4f），以及在本次提交中有多少文件修订过，多少行添加和删改过。</p><p><strong>跳过使用暂存区域</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit -a -m <span class="hljs-string">&quot;explanatory note&quot;</span><br>[master 83e38c7] added new benchmarks<br> 1 file changed, 5 insertions(+), 0 deletions(-)<br></code></pre></td></tr></table></figure><p>该命令会自动把已经跟踪过的文件暂存起来一并提交，从而跳过<code>git add</code>步骤。</p><p><strong>移除文件</strong><br>要从Git中移除某个文件，就必须要从已跟踪文件清单中移除（即从暂存区移除）然后提交。可以使用命令<code>git rm</code><br>如果只是简单的从工作目录中手动删除文件，运行<code>git status</code>可以看到在“Changes not staged for commit” 部分（也就是 未暂存清单）有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">rm</span> PROJECTS.md<br>$ git status<br>On branch master<br>Your branch is up-to-date with <span class="hljs-string">&#x27;origin/master&#x27;</span>.<br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add/rm &lt;file&gt;...&quot;</span> to update what will be committed)<br>  (use <span class="hljs-string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="hljs-keyword">in</span> working directory)<br><br>        deleted:    PROJECTS.md<br><br>no changes added to commit (use <span class="hljs-string">&quot;git add&quot;</span> and/or <span class="hljs-string">&quot;git commit -a&quot;</span>)<br></code></pre></td></tr></table></figure><p>然后再运行<code>git rm</code>记录此次移除文件的操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">rm</span> PROJECTS.md<br><span class="hljs-built_in">rm</span> <span class="hljs-string">&#x27;PROJECTS.md&#x27;</span><br>$ git status<br>On branch master<br>Your branch is up-to-date with <span class="hljs-string">&#x27;origin/master&#x27;</span>.<br>Changes to be committed:<br>  (use <span class="hljs-string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)<br><br>    deleted:    PROJECTS.md<br></code></pre></td></tr></table></figure><p>下一次提交时，该文件就不再纳入版本管理了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果要删除之前已经修改或已经放到暂存区的文件，则必须使用强制删除`-f`选项</span><br>$ git <span class="hljs-built_in">rm</span> -f &lt;files&gt;<br><br><span class="hljs-comment"># 如果想把文件从Git仓库中移除（即从暂存区移除），但仍希望保留在当前工作目录中。即想让文件保留在磁盘中，但是不想让Git继续跟踪。比如当忘记添加.gitignore文件，不小心把一大堆.a文件添加到暂存区时</span><br>$ git <span class="hljs-built_in">rm</span> --cached README<br><br><span class="hljs-comment"># git rm命令后面可以列出文件或者目录的名字，也可以使用glob模式，比如删除`log/`目录下扩展名为`.log`的所有文件（星号之前的反斜杠，因为Git有它自己的文件模式扩展匹配，所以我们不用shell来帮忙展开）：</span><br>$ git <span class="hljs-built_in">rm</span> <span class="hljs-built_in">log</span>/\*.<span class="hljs-built_in">log</span><br><br><span class="hljs-comment"># 删除所有以名字以~结尾的文件</span><br>$ git <span class="hljs-built_in">rm</span> \*~<br></code></pre></td></tr></table></figure><p><strong>移动文件</strong><br>重命名文件操作：<code>git mv</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">mv</span> README.md README<br>$ git status<br>On branch master<br>Your branch is up-to-date with <span class="hljs-string">&#x27;origin/master&#x27;</span>.<br>Changes to be committed:<br>  (use <span class="hljs-string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)<br><br>    renamed:    README.md -&gt; README<br></code></pre></td></tr></table></figure><p>该命令将README.md重命名为README。其实，运行<code>git mv</code>就相当于运行了下面三条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mv</span> README.md README<br>$ git <span class="hljs-built_in">rm</span> README.md<br>$ git add README<br></code></pre></td></tr></table></figure><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看提交历史</span><br>$ git <span class="hljs-built_in">log</span><br>commit ca82a6dff817ec66f44342007202690a93763949<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Mon Mar 17 21:52:11 2008 -0700<br><br>    changed the version number<br><br>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Sat Mar 15 16:40:33 2008 -0700<br><br>    removed unnecessary <span class="hljs-built_in">test</span><br><br>commit a11bef06a3f659402fe7563abf99ad00de2209e6<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Sat Mar 15 10:31:28 2008 -0700<br><br>    first commit<br></code></pre></td></tr></table></figure><p>不传入任何参数的默认情况下，<code>git log</code>会按时间先后顺序列出所有的提交，最近的排在最上面。这个命令会列出每个提交的校验和，作者的名字和电子邮件地址，提交时间，提交说明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> -p -2<br></code></pre></td></tr></table></figure><p>这个命令会显示每次提交所引入的差异，<code>-2</code>选项限制只显示最近的两次提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span><br></code></pre></td></tr></table></figure><p>这个选项可以看到每次提交的简略统计信息。当进行代码审查，或者快速浏览某个搭档的提交所带来的变化的时候，可以使用这个参数。<code>--stat</code>选项在每次提交的下面列出所有被修改过的文件，有多少文件被修改了以及被修改过的文件的哪些行被移除或被添加。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --pretty=oneline<br>ca82a6dff817ec66f44342007202690a93763949 changed the version number<br>085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary <span class="hljs-built_in">test</span><br>a11bef06a3f659402fe7563abf99ad00de2209e6 first commit<br></code></pre></td></tr></table></figure><p><code>--pretty</code>这个选项可以使用不同于默认格式的方式展示提交历史。<code>oneline</code>会将每个提交放在一行显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --pretty=format:<span class="hljs-string">&quot;%h - %an, %ar : %s&quot;</span><br>ca82a6d - Scott Chacon, 6 years ago : changed the version number<br>085bb3b - Scott Chacon, 6 years ago : removed unnecessary <span class="hljs-built_in">test</span><br>a11bef0 - Scott Chacon, 6 years ago : first commit<br></code></pre></td></tr></table></figure><p><code>format</code>选项可以定制记录的显示格式，还有<a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#pretty_format">其他常用选项</a>列出了<code>format</code>接受的常用格式占位符的写法及其代表的意义。<br><code>git log</code>常用选项：</p><ul><li>-p：按补丁格式显示每个提交引入的差异</li><li>–stat：显示每次提交的文件修改统计信息</li><li>–shortstat：只显示–stat中最后的行数修改添加移除统计</li><li>–name-status：显示新增，修改，删除的文件清单</li><li>–abbrev-commit：仅显示校验和所有40个字符的前几个字符</li><li>–relative-date：使用较短的相对时间而不是完整格式显示日期（比如：“2 weeks ago”）</li><li>–graph：在日志旁以ASCII图形显示分支与合并历史</li><li>–pretty：使用其他格式显示历史提交信息。可用的选项包括oneline,short,full,fuller,format</li><li>–oneline：–pretty&#x3D;oneline –abbrev-commit合并的简写</li></ul><p><strong>限制输出长度</strong><br>限制<code>git log</code><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#limit_options">输出的常用选项</a>:</p><ul><li>-<n>：仅显示最近的n条提交</li><li>–since，after：仅显示指定时间之后的提交</li><li>–until，–before：仅显示指定事件之前的提交</li><li>–author：仅显示作者匹配指定字符串的提交</li><li>–committer：今昔那是提交者匹配指定字符串的提交</li><li>–grep：仅显示提交说明中包含指定字符串的提交</li><li>-S：仅显示添加或者删除内容匹配指定字符串的提交</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --pretty=<span class="hljs-string">&quot;%h - %s&quot;</span> --author=<span class="hljs-string">&#x27;Junio C Hamano&#x27;</span> --since=<span class="hljs-string">&quot;2008-10-01&quot;</span> \<br>   --before=<span class="hljs-string">&quot;2008-11-01&quot;</span> --no-merges -- t/<br>5610e3b - Fix testcase failure when extended attributes are <span class="hljs-keyword">in</span> use<br>acd3b9e - Enhance hold_lock_file_for_&#123;update,append&#125;() API<br>f563754 - demonstrate breakage of detached checkout with symbolic <span class="hljs-built_in">link</span> HEAD<br>d1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths<br>51a94af - Fix <span class="hljs-string">&quot;checkout --track -b newbranch&quot;</span> on detached HEAD<br>b0ad11e - pull: allow <span class="hljs-string">&quot;git pull origin <span class="hljs-variable">$something</span>:<span class="hljs-variable">$current_branch</span>&quot;</span> into an unborn branch<br></code></pre></td></tr></table></figure><p>使用以上命令在Git源码库中查看Junio Hamano在2008年10月期间，除了合并提交之外的哪一个提交修改了测试文件。</p><h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><p><strong>修补提交</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit -m <span class="hljs-string">&#x27;initial commit&#x27;</span><br>$ git add forgotten_file<br>$ git commit --amend<br></code></pre></td></tr></table></figure><p><code>git commit --amend</code>修补提交命令会将暂存区中的文件提交，如果字上次提交以来暂存区还未做任何修改，那么快照会保持不变，如果暂存区有修改或者变化，那么执行该指令会将覆盖上一次提交。ps.修补提交最明显的价值是可以稍微改进你最后的提交，而不会让“啊，忘了添加一个文件”或者 “小修补，修正笔误”这种提交信息弄乱你的仓库历史。</p><p><strong>取消暂存的文件</strong><br>当已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入”git add *”暂存了它们两个，如何只取消暂存两个中的一个呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reset HEAD README.md<br></code></pre></td></tr></table></figure><p>通过该命令取消暂存”README.md”文件。</p><p><strong>撤销对文件的修改</strong><br>撤销修改即把文件还原成上次提交时的样子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout README.md<br></code></pre></td></tr></table></figure><h3 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h3><p><strong>查看远程仓库</strong><br><code>git remote</code>命令：列出指定的每一个远程服务器的简写。origin——这是Git给你克隆的仓库服务器的默认名字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/schacon/ticgit<br>Cloning into <span class="hljs-string">&#x27;ticgit&#x27;</span>...<br>remote: Reusing existing pack: 1857, <span class="hljs-keyword">done</span>.<br>remote: Total 1857 (delta 0), reused 0 (delta 0)<br>Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, <span class="hljs-keyword">done</span>.<br>Resolving deltas: 100% (772/772), <span class="hljs-keyword">done</span>.<br>Checking connectivity... <span class="hljs-keyword">done</span>.<br>$ <span class="hljs-built_in">cd</span> ticgit<br>$ git remote<br>origin<br></code></pre></td></tr></table></figure><p>也可以指定选项<code>-v</code>，用于显示当前Git仓库中配置的所有远程仓库的详细信息，包括他们的URL以及对应的远程仓库的简称。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote -v<br>originhttps://github.com/schacon/ticgit (fetch)<br>originhttps://github.com/schacon/ticgit (push)<br></code></pre></td></tr></table></figure><p><strong>添加远程仓库</strong><br><code>git remote add &lt;shortname&gt; &lt;url&gt;</code>添加一个新的远程Git仓库，同时指定一个方便使用的简写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote<br>origin<br>$ git remote add pb https://github.com/paulboone/ticgit<br>$ git remote -v<br>originhttps://github.com/schacon/ticgit (fetch)<br>originhttps://github.com/schacon/ticgit (push)<br>pbhttps://github.com/paulboone/ticgit (fetch)<br>pbhttps://github.com/paulboone/ticgit (push)<br></code></pre></td></tr></table></figure><p>之后可以在命令行中使用字符串pb来替代整个URL。例如想要拉取Paul的仓库中有但你没有的信息，可以运行<code>git fetch pb</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git fetch pb<br>remote: Counting objects: 43, <span class="hljs-keyword">done</span>.<br>remote: Compressing objects: 100% (36/36), <span class="hljs-keyword">done</span>.<br>remote: Total 43 (delta 10), reused 31 (delta 5)<br>Unpacking objects: 100% (43/43), <span class="hljs-keyword">done</span>.<br>From https://github.com/paulboone/ticgit<br> * [new branch]      master     -&gt; pb/master<br> * [new branch]      ticgit     -&gt; pb/ticgit<br></code></pre></td></tr></table></figure><p><strong>从远程仓库中抓取和拉取</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git fetch &lt;remote&gt;<br></code></pre></td></tr></table></figure><p>该命令会访问远程仓库，从中拉去所有你还没有的数据。执行完之后，你将拥有那个远程仓库中所有分支的引用，可以随时合并或者查看。<code>git fetch</code>命令只会讲数据下载到本地仓库，并不会自动合并或修改当前的工作，必须手动将其合并到你的工作。<br>如果当前分支设置了跟踪远程分支，那么可以用<code>git pull</code>命令自动抓取后合并该远程分支到当前分支。<br>默认情况下，<code>git clone</code>命令会自动设置本地master分支跟踪远程仓库的master分支（或其他名字的默认分支）。<br>运行<code>git pull</code>通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p><p><strong>推送到远程仓库</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin master<br></code></pre></td></tr></table></figure><p>该命令讲master分支推送到origin服务器（克隆时通常会自动帮你设置好那两个名字）。执行该命令可以将你做的工作备份到服务器。<br>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才会生效。当你和其他人在同一时间克隆，它们先推送到上游，然后你再推送到上游，你的推送就会被拒绝。必须先抓取他们地工作，并将其合并进你的工作后才能推送。</p><p><strong>查看某个远程仓库</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote show origin<br>* remote origin<br>  Fetch URL: https://github.com/schacon/ticgit<br>  Push  URL: https://github.com/schacon/ticgit<br>  HEAD branch: master<br>  Remote branches:<br>    master                               tracked<br>    dev-branch                           tracked<br>  Local branch configured <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;git pull&#x27;</span>:<br>    master merges with remote master<br>  Local ref configured <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;git push&#x27;</span>:<br>    master pushes to master (up to <span class="hljs-built_in">date</span>)<br></code></pre></td></tr></table></figure><p>运行该命令，会列出远程仓库地URL与跟踪分支的信息。他告诉你正处于master分支，并且如果运行<code>git pull</code>就会抓取所有的远程引用，然后将远程master分支合并到本地master分支。它也列出了抓取到的所有远程引用。</p><p><strong>远程仓库的重命名与移除</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 远程仓库的重命名 </span><br>$ git remote rename &lt;beforename&gt; &lt;aftername&gt;<br><br><span class="hljs-comment"># 远程仓库的移除</span><br>$ git remote remove &lt;name&gt;<br></code></pre></td></tr></table></figure><h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><p>Git可以给仓库历史中的某个提交打上标签，以示重要。<br><strong>列出标签</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出已有的标签</span><br>$ git tag<br><br><span class="hljs-comment"># 按照特定的模式查找标签</span><br>$ git tag -l <span class="hljs-string">&quot;v1.8.5*&quot;</span><br></code></pre></td></tr></table></figure><p><strong>创建标签：附件标签</strong><br>附件标签是一个存储在Git数据库中的一个完整对象，是可以被校验的，其中包含打标签者的名字，电子邮件地址，日期以及标签信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag -a v1.4 -m <span class="hljs-string">&quot;explanatory note&quot;</span><br>$ git tag<br>v1.4<br></code></pre></td></tr></table></figure><p>可以使用<code>git show</code>命令看到标签信息和与之对应的提交信息</p><p><strong>创建标签：轻量标签</strong><br>轻量标签本质上是将提交校验和存储到一个文件中，没有保存任何其他信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag v1.4-lw<br></code></pre></td></tr></table></figure><p><strong>后期打标签</strong><br>假设在v1.2时忘记给项目打标签，可以在之后补上标签，要在哪个提交上打标签，就需要在命令的末尾指定提交的校验和（或者部分校验和）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag -a v1.2 9fceb02<br></code></pre></td></tr></table></figure><p><strong>共享标签</strong><br>默认情况下，<code>git push</code>命令并不传送标签到远程服务器上，在创建完标签后必须显式地推送标签到共享服务器上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin v1.4<br></code></pre></td></tr></table></figure><p>如果想一次性推送很多标签，也可以使用<code>--tags</code>选项，它可以将所有不在远程仓库上服务器上的标签全部传送到那里。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin --tags<br></code></pre></td></tr></table></figure><p><strong>删除标签</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 第一种方法</span><br>$ git tag -d v1.4-lw    <span class="hljs-comment"># 删除本地仓库上的标签</span><br>$ git push origin :refs/tags/v1.4-lw <span class="hljs-comment"># 更新远程仓库，将冒号前面的空置推到远程标签名，从而删除远程仓库中的标签</span><br><br><span class="hljs-comment"># 第二种方法</span><br>$ git push origin --delete &lt;tagname&gt;<br></code></pre></td></tr></table></figure><h3 id="Git别名"><a href="#Git别名" class="headerlink" title="Git别名"></a>Git别名</h3><p>可以通过<code>git config</code>文件给命令设置别名（Git只是简单的将别名替换为对应的命令）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 给checkout起个别名co</span><br>$ git config --global alias.co checkout<br><br><span class="hljs-comment"># 给reset HEAD --起个别名unsatge</span><br>$ git config --global alias.unstage <span class="hljs-string">&#x27;reset HEAD --&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="9-Git分支"><a href="#9-Git分支" class="headerlink" title="9.Git分支"></a>9.Git分支</h2><h3 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h3><p>使用分支，可以把你的工作从主线上分离开来，以免影响开发主线。Git的分支而不能之上仅仅是指向提交对象的可变指针。<br><strong>分支创建</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch testing<br></code></pre></td></tr></table></figure><p>创建了一个testing分支。本质上是创建了一个可以移动的新指针。但是仍然在master分支上，因为<code>git branch</code>命令仅仅创建一个新分支，并不会自动切换到新分支中去。Git通过HEAD的特殊指针，从而知道当前所在的本地分支是哪一个。如果想要创建一个新分支后立即切换过去，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git chechout -b &lt;newbranchname&gt;<br></code></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/head-to-master.png" alt="两个指向相同提交历史的分支">  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --oneline --decorate<br>f30ab (HEAD -&gt; master, testing) add feature <span class="hljs-comment">#32 - ability to add new formats to the central interface</span><br>34ac2 Fixed bug <span class="hljs-comment">#1328 - stack overflow under certain conditions</span><br>98ca9 The initial commit of my project<br></code></pre></td></tr></table></figure><p>可以使用该命令查看各个分支当前所指的对象。本示例中，当前master和testing分支均指向校验和以f30ab开头的提交对象。</p><p><strong>分支切换</strong><br>要切换到一个已存在的分支，使用<code>git chechout</code>命令，示例：切换到新创建的testing分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git chechout testing<br></code></pre></td></tr></table></figure><p>这样，HEAD就指向testing分支了。后面我们再进行一次提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vim test.rb<br>$ git commit -a -m  <span class="hljs-string">&quot;made a change&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/advance-testing.png" alt="HEAD分支随着提交操作自动向前移动"><br>可以看到，testing分支向前移动，但是master分支并没有。当切换回master分支时：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git chechout master<br></code></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/checkout-master.png"><br>这条命令做了两件事，一是使HEAD指向master分支，二是将目录工作恢复成master分支所指向的快照内容。本质上来讲，就是忽略testing分支所作的修改，以便于向另一个方向进行开发。<br>此时，再做些修改并提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vim test.rb<br>$ git chechout -a -m <span class="hljs-string">&quot;made other changes&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/advance-master.png"><br>可以看到，这个项目的提交历史产生了分叉。可以简单的使用<code>git log</code>命令查看分叉历史。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出提交历史，各个分支的指向以及项目的分支分叉情况</span><br>$ git <span class="hljs-built_in">log</span> --oneline --decorate --graph --all<br>* c2b9e (HEAD, master) made other changes<br>| * 87ab2 (testing) made a change<br>|/<br>* f30ab add feature <span class="hljs-comment">#32 - ability to add new formats to the</span><br>* 34ac2 fixed bug <span class="hljs-comment">#1328 - stack overflow under certain conditions</span><br>* 98ca9 initial commit of my project<br></code></pre></td></tr></table></figure><h3 id="分支的创建与合并"><a href="#分支的创建与合并" class="headerlink" title="分支的创建与合并"></a>分支的创建与合并</h3><p>简单的分支新建和分支合并的工作流：<br>   1.开发某个网站。<br>   2.为实现某个新的用户需求，创建一个分支。<br>   3.在这个分支上开展工作。<br>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：<br>   1.切换到你的线上分支（production branch）。<br>   2.为这个紧急任务新建一个分支，并在其中修复它。<br>   3.在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。<br>   4.切换回你最初工作的分支上，继续工作。</p><h4 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h4><p>1.解决公司的新需求#52问题，于是创建一个分支并同时切换到那个分支上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 方法一</span><br>$ git chechout -b iss52 <span class="hljs-comment"># 创建并切换分支</span><br><br><span class="hljs-comment">#方法二</span><br>$ git branch iss52      <span class="hljs-comment"># 创建分支</span><br>$ git chechout iss52    <span class="hljs-comment"># 切换分支</span><br></code></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-2.png">  </p><p>2.在#53问题上工作，并且做了一些提交。在此过程中iss52分支不断地向前推进。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vim index.html<br>$ git commit -a -m <span class="hljs-string">&quot;added a new footer[issue 53]&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-3.png">  </p><p>3.接到电话有个很严重的问题需要紧急修补。于是要切换到线上分支，并为这个紧急任务新建一个hotfix分支，在该分支上工作直到问题解决</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout master<br>Switched to branch <span class="hljs-string">&#x27;master&#x27;</span><br>$ git checkout -b hotfix<br>Switched to a new branch <span class="hljs-string">&#x27;hotfix&#x27;</span><br>$ vim index.html<br>$ git commit -a -m <span class="hljs-string">&#x27;fixed the broken email address&#x27;</span><br>[hotfix 1fb7853] fixed the broken email address<br> 1 file changed, 2 insertions(+)<br></code></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-4.png">  </p><p>4.运行你的测试，确保修改是正确的，然后将hotfix分支合并回master分支来部署到线上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout master<br>$ git merge hotfix<br>Updating f42c576..3a0874c<br>Fast-forward<br> index.html | 2 ++<br> 1 file changed, 2 insertions(+)<br></code></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-5.png">  </p><p>5.这个紧急问题地解决方案发布以后，你准备回到被打断之前地工作中。在此之前，先删除hotfix分支，因为已经不再需要他了，master分支已经指向同一个位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -f hotfix<br>Deleted branch hotfix (3a0874c).<br>$ git chechout iss53<br>Switched to branch <span class="hljs-string">&quot;iss53&quot;</span><br>$ vim index.html<br>$ git commit -a -m <span class="hljs-string">&#x27;finished the new footer [issue 53]&#x27;</span><br>[iss53 ad82d7a] finished the new footer [issue 53]<br>1 file changed, 1 insertion(+)<br></code></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-6.png">  </p><h4 id="分支的合并：解决冲突"><a href="#分支的合并：解决冲突" class="headerlink" title="分支的合并：解决冲突"></a>分支的合并：解决冲突</h4><p>6.当完成#53问题的需求后，打算将工作合并入master分支。为此需要合并iss53分支到master分支。合并之后就不需要iss53分支了，可以在最后删除这个分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout master<br>Switched to branch <span class="hljs-string">&#x27;master&#x27;</span><br>$ git merge iss53<br>Merge made by the <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br>index.html |    1 +<br>1 file changed, 1 insertion(+)<br>$ git branch -d iss53<br></code></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-merging-2.png">  </p><p>7.遇到冲突时的分支合并<br>如果你对#53问题的修改和有关hotfix分支的修改都涉及到同一个文件的同一处，在合并他们的时候就会产生合并冲突：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git merge iss53<br>Auto-merging index.html<br>CONFLICT (content): Merge conflict <span class="hljs-keyword">in</span> index.html<br>Automatic merge failed; fix conflicts and <span class="hljs-keyword">then</span> commit the result.<br></code></pre></td></tr></table></figure><p>此时Git做了合并，但是没有自动地创建一个新的合并提交，Git回暂停下来，等待你去解决合并产生地冲突。在合并冲突之后可以使用<code>git status</code>命令查看那些因为包含合并冲突而处于未合并状态的文件。</p><p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。Git会在有冲突的文件中加入标准的冲突解决标记：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html<br><span class="hljs-section">&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="hljs-section">=======</span><br>&lt;div id=&quot;footer&quot;&gt;<br><span class="hljs-code"> please contact us at support@github.com</span><br>&lt;/div&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html<br></code></pre></td></tr></table></figure><p>这表示HEAD所指示的版本（也就是你的master分支所在的位置）在这个区段的上半部分（ &#x3D;&#x3D;&#x3D; 的上半部分），iss53分支所示的版本在 &#x3D;&#x3D;&#x3D; 的下半部分。为了解决冲突，必须选择由&#x3D;&#x3D;&#x3D;分割的两个部分中的一个，或者自行合并这些内容，例如，可以通过把这段内容换成下面的样子来解决冲突：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;<br>please contact us <span class="hljs-keyword">at</span> email.support@github.com<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p>上述的冲突解决方案仅保留了其中一个分支的修改，并且<code>&lt;&lt;==&gt;&gt;</code>这些行被完全删除。在解决了所有文件里的冲突之后，对每个文件使用<code>git add</code> 命令来将其标记为冲突已解决。一旦暂存了这些原本有冲突的文件，Git就会将他们标记为冲突已解决，</p><p>图像化工具：<code>git mergetool</code>会启动一个可视化的合并工具，并带着你一步一步解决这些冲突。</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch<br>  iss53<br>* master<br>  testing<br></code></pre></td></tr></table></figure><p><code>git branch</code>命令不仅可以创建和删除分支，如果不加任何参数，该命令表示列出当前所有分支。master分支前面的 * 表示现在检出的那一个分支（也就是HEAD指针所指向的分支）。如果想要查看每一个分支的最后一次提交可以运行<code>git branch -v</code>命令。</p><p><code>--merged</code>和<code>--no-merged</code>选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看哪些分支已经合并到当前分支</span><br>$ git branch --merged<br><br><span class="hljs-comment"># 查看所有包含未合并工作的分支</span><br>$ git branch --no-merged<br></code></pre></td></tr></table></figure><p>对于未合并的分支，尝试使用<code>git branch -d</code>命令会失败，因为它包含了还未合并的工作，如果真的想要删除分支并丢掉那部分工作，可以使用<code>-D</code>强制删除。</p><h3 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h3><h4 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h4><p>只在master分支上保留完全稳定的代码，还有一些名为develop<br>或topic的平行分支，用在做后续开发或者测试稳定性，这些分支不必保持绝对稳定，一旦达到稳定状态，就可以合并入master分支。<br><img src="https://git-scm.com/book/en/v2/images/lr-branches-2.png">  </p><h4 id="主题分支"><a href="#主题分支" class="headerlink" title="主题分支"></a>主题分支</h4><p>主题分支是一种短期分支，被用来实现单一特性或其相关工作。比如上文中用到主题分支（iss53和hotfix分支）提交了一些更新，并在他们合并入主干分支之后，又删除了他们。<br>考虑这样一个例子，你在 master 分支上工作到 C1，这时为了解决一个问题而新建 iss91 分支，在 iss91 分支上工作到 C4，然而对于那个问题你又有了新的想法，于是你再新建一个 iss91v2 分支试图用另一种方法解决那个问题，接着你回到 master 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 C10 的时候新建一个 dumbidea 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：<br><img src="https://git-scm.com/book/en/v2/images/topic-branches-1.png"><br>现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 iss91v2 分支中方案。 另外，你将 dumbidea 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 iss91 分支（即丢弃 C5 和 C6 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：<br><img src="https://git-scm.com/book/en/v2/images/topic-branches-2.png">  </p><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><p>可以通过<code>git ls-remote &lt;remote&gt;</code>来显示地获得远程引用地完整列表，或者通过<code>git remote show &lt;remote&gt;</code>获得远程分支地更多信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote -v<br>origin  git@github.com:portkas/portkas.github.io.git (fetch)<br>origin  git@github.com:portkas/portkas.github.io.git (push)<br><br>$ git ls-remote origin<br>33e33baaadb70a791936b45c4f7a47ca104cdc1a        HEAD<br>33e33baaadb70a791936b45c4f7a47ca104cdc1a        refs/heads/hexo<br>294c8b3fa958a2f46defa546b0e137a91f0927d9        refs/heads/master<br></code></pre></td></tr></table></figure><p>远程分支只是分支的一种。本地的主分支为master，远程的主分支为origin&#x2F;master，这是两个不同的分支。<br><img src="https://git-scm.com/book/en/v2/images/remote-branches-1.png"><br>如果你在本地master分支做了一些工作，在同一时间内其他人推送提交到 <code>git.ourcomoany.com</code>并且更新了他的master分支，也就是说你们的提交历史走向不同的方向。即便如此，只要保持不与origin服务器连接并拉取数据，你的origin&#x2F;master指针就不会移动。<br><img src="https://git-scm.com/book/en/v2/images/remote-branches-2.png"><br>如果要与给定的远程仓库同步数据，运行<code>git fetch &lt;remote&gt;</code>命令（在本例中为<code>git fetch origin</code>）。这个命令会查找origin是哪一个服务器（在本例中是<code>git.ourcompany.com</code>），从中抓取本地没有的数据，并且更新本地数据库，移动origin&#x2F;master指针到更新之后的位置。<br><img src="https://git-scm.com/book/en/v2/images/remote-branches-3.png">  </p><h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>本地地分支并不会自动与远程分支同步，必须显式地推送想要 分享的分支。可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。<br>如果希望和别人一起在名为serverfix的分支上工作，运行<code>git push &lt;remote&gt; &lt;branch&gt;</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin serverfix<br>Counting objects: 24, <span class="hljs-keyword">done</span>.<br>Delta compression using up to 8 threads.<br>Compressing objects: 100% (15/15), <span class="hljs-keyword">done</span>.<br>Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, <span class="hljs-keyword">done</span>.<br>Total 24 (delta 2), reused 0 (delta 0)<br>To https://github.com/schacon/simplegit<br> * [new branch]      serverfix -&gt; serverfix<br></code></pre></td></tr></table></figure><p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支origin&#x2F;serverfix，指向服务器的serverfix分支的引用。<br>需要特别注意的是，当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本，即本地不会有一个新的serverfix分支，只有一个不可修改的origin&#x2F;serverfix指针。<br>可以运行<code>git merge origin/serverfix</code>将这些工作合并到当前所在的分支。如果想要在serverfix分支上工作，可以将其建立在远程跟踪分支之上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b serverfix origin/serverfix<br>Branch serverfix <span class="hljs-built_in">set</span> up to track remote branch serverfix from origin.<br>Switched to a new branch <span class="hljs-string">&#x27;serverfix&#x27;</span><br></code></pre></td></tr></table></figure><p>这会给你一个用于工作的本地分支，并且起点位于origin&#x2F;serverfix。</p><h4 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h4><p>当克隆一个仓库时，通常会自动地设置一个跟踪origin&#x2F;master地master分支。如果在一个跟踪分支上输入<code>git pull</code>，Git能自动地识别去哪个服务器上抓取，合并到哪个分支。<br>也可以设置其他地跟踪分支，运行<code>git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</code>，这是一个常用地操作，所以Git提供了–track快捷方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout --track origin/serverfix<br>Branch serverfix <span class="hljs-built_in">set</span> up to track remote branch serverfix from origin.<br>Switched to a new branch <span class="hljs-string">&#x27;serverfix&#x27;</span><br></code></pre></td></tr></table></figure><p>由于该操作太常用了，该快捷方式还有一个快捷方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout serverfix<br>Branch serverfix <span class="hljs-built_in">set</span> up to track remote branch serverfix from origin.<br>Switched to a new branch <span class="hljs-string">&#x27;serverfix&#x27;</span><br></code></pre></td></tr></table></figure><p>如果想要将本地分支与远程分支设置为不同的名字，可以使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b sf origin/erverfix<br>Branch sf <span class="hljs-built_in">set</span> up to track remote branch serverfix from origin.<br>Switched to a new branch <span class="hljs-string">&#x27;sf&#x27;</span><br></code></pre></td></tr></table></figure><p>现在，本地分支sf会自动从origin&#x2F;serverfix拉取。</p><p>如果想要修改正在跟踪地上有分支（即和本地分支绑定地服务器分支），可以在任意时间使用<code>-u</code>或<code>--set-upstream-to</code>选项来运行<code>git branch</code>来显示地设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 首先要先有一个本地分支，然后切换到这个分支，然后运行该指令指定要跟踪地远程分支</span><br>$ git branch -u origin/serverfix<br>Branch serverfix <span class="hljs-built_in">set</span> up to track remote branch serverfix from origin.<br></code></pre></td></tr></table></figure><p>如果要查看设置地所有跟踪分支，可以使用<code>git branch -vv</code>，会将所有地本地分支列出来，并且包含更多的信息，比如每一个分支正在跟踪哪个远程分支，本地分支是领先还是落后。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -vv<br>  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets<br>  master    1ae2a45 [origin/master] deploying index fix<br>* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should <span class="hljs-keyword">do</span> it<br>  testing   5ea463a trying something new<br></code></pre></td></tr></table></figure><p>可以看到iss53分支正在跟踪origin&#x2F;iss53并且ahead是2，意味着本地有两个提交还没有推送到服务器。master分支正在跟踪origin&#x2F;master分支并且是最新的。serverfix分支正在跟踪teamone服务器上的server-fix-good分支并且领先3落后1，意味着服务器上有一次还没有合并，同时本地还有三次提交没有推送。<br>需要注意的是，这些数字的值来自于你从服务器上最后一次抓取的数据，这个命令没有连接服务器，所以只会告诉你本地缓存的服务器数据，如果想要统计最新的领先和落后数字，可以在统计前抓取所有的远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git fetch --all<br>$ git branch -vv<br></code></pre></td></tr></table></figure><h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><p><code>git fetch</code>命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容，它只会获取数据然后让你自己合并。<br><code>git pull</code>命令在大多数情况下含义是一个<code>git fetch</code>紧接着一个<code>git merge</code>命令。该指令会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。<br>由于<code>git pull</code>经常令人困惑，通常单独显式地使用<code>git fetch</code>与<code>git merge</code></p><h4 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h4><p>当已经通过远程分支做完所有的工作后，可以运行<code>git push --delete &lt;branch&gt;</code>命令删除一个远程分支，例如要从服务器上删除serverfix分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin --delete serverfix<br>To https://github.com/schacon/simplegit<br> - [deleted]         serverfix<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Github的SSH配置</title>
    <link href="/2025/02/22/MissingSemester/Github%E7%9A%84SSH%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/02/22/MissingSemester/Github%E7%9A%84SSH%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="1-创建公私密钥"><a href="#1-创建公私密钥" class="headerlink" title="1.创建公私密钥"></a>1.创建公私密钥</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">&quot;Github注册的邮箱地址&quot;</span><br>$ <span class="hljs-built_in">cat</span> ～/.ssh/id_rsa.pub<br><span class="hljs-comment"># ps.在windows系统中.ssh文件在C:\Users\你的用户名\.ssh目录下</span><br></code></pre></td></tr></table></figure><span id="more"></span><h1 id="2-配置公钥"><a href="#2-配置公钥" class="headerlink" title="2.配置公钥"></a>2.配置公钥</h1><p>1.github -&gt; 个人头像 -&gt; setting -&gt; SSH and GPG keys -&gt; New SSH key<br>2.复制id_rsa.pub的内容到Key中<br>3.Title的内容自定义</p><h1 id="3-验证是否设置成功"><a href="#3-验证是否设置成功" class="headerlink" title="3.验证是否设置成功"></a>3.验证是否设置成功</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh -T git@github.com<br>Hi portkas! You<span class="hljs-string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></code></pre></td></tr></table></figure><h1 id="4-Q-A"><a href="#4-Q-A" class="headerlink" title="4.Q&amp;A"></a>4.Q&amp;A</h1><p>SSH登录安全性由非对称加密保证，产生密钥时，一次产生两个密钥，一个公钥，一个私钥，在git中一般命名为id_rsa.pub, id_rsa。</p><h2 id="如何使用生成的一个私钥一个公钥进行验证呢？"><a href="#如何使用生成的一个私钥一个公钥进行验证呢？" class="headerlink" title="如何使用生成的一个私钥一个公钥进行验证呢？"></a>如何使用生成的一个私钥一个公钥进行验证呢？</h2><p>本地生成一个密钥对，其中公钥放到远程主机，私钥保存在本地，当本地主机需要登录远程主机时，本地主机向远程主机发送一个登录请求，远程收到消息后，随机生成一个字符串并用公钥加密，发回给本地。本地拿到该字符串，用存放在本地的私钥进行解密，再次发送到远程，远程比对该解密后的字符串与源字符串是否等同，如果等同则认证成功。</p><h2 id="每使用一台主机都要配？"><a href="#每使用一台主机都要配？" class="headerlink" title="每使用一台主机都要配？"></a>每使用一台主机都要配？</h2><p>每使用一台新主机进行git远程操作，想要实现无密，都需要配置。并不是说每个账号配一次就够了，而是每一台主机都需要配。</p><h2 id="配了为什么就不用密码了？"><a href="#配了为什么就不用密码了？" class="headerlink" title="配了为什么就不用密码了？"></a>配了为什么就不用密码了？</h2><p>因为配置的时候是把当前主机的公钥放到了你的github账号下，相当于当前主机和你的账号做了一个关联，你在这台主机上已经登录了你的账号，此时此刻github认为是该账号主人在操作这台主机，在配置ssh后就信任该主机了。所以下次在使用git的时候即使没有登录github，也能直接从本地push代码到远程了。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Tmux</title>
    <link href="/2025/02/22/MissingSemester/Tmux/"/>
    <url>/2025/02/22/MissingSemester/Tmux/</url>
    
    <content type="html"><![CDATA[<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Ubuntu</span><br>$ <span class="hljs-built_in">sudo</span> apt-get install tmux<br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="启动和退出"><a href="#启动和退出" class="headerlink" title="启动和退出"></a>启动和退出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动</span><br>$ tmux<br><br><span class="hljs-comment"># 退出（或者使用快捷键ctrl+d）</span><br>$ <span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><h2 id="前缀键"><a href="#前缀键" class="headerlink" title="前缀键"></a>前缀键</h2><p>Tmux中所有的快捷键都需要通过前缀键唤起，即先按前缀键，再按快捷键，才能生效。默认的前缀键为：ctrl+b</p><h1 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h1><h2 id="新建会话"><a href="#新建会话" class="headerlink" title="新建会话"></a>新建会话</h2><p>第一个启动的Tmux窗口，编号是0, 第二个窗口的编号是1,以此类推。也可以在新建窗口时为窗口指定会话名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux new -s &lt;session-name&gt;<br></code></pre></td></tr></table></figure><h2 id="分离会话"><a href="#分离会话" class="headerlink" title="分离会话"></a>分离会话</h2><p>快捷键：ctrl+b d</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux detach<br></code></pre></td></tr></table></figure><h2 id="查看当前所有Tmux会话"><a href="#查看当前所有Tmux会话" class="headerlink" title="查看当前所有Tmux会话"></a>查看当前所有Tmux会话</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># or</span><br>$ tmux list-session<br></code></pre></td></tr></table></figure><h2 id="接入会话"><a href="#接入会话" class="headerlink" title="接入会话"></a>接入会话</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux attach -t &lt;session-name&gt;<br></code></pre></td></tr></table></figure><h2 id="杀死会话"><a href="#杀死会话" class="headerlink" title="杀死会话"></a>杀死会话</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux kill-session -t &lt;session-name&gt;<br></code></pre></td></tr></table></figure><h2 id="切换会话"><a href="#切换会话" class="headerlink" title="切换会话"></a>切换会话</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux switch -t &lt;session-name&gt;<br></code></pre></td></tr></table></figure><h2 id="重命名会话"><a href="#重命名会话" class="headerlink" title="重命名会话"></a>重命名会话</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux rename-session -t &lt;old-name&gt; &lt;new-name&gt;<br></code></pre></td></tr></table></figure><h2 id="会话快捷键"><a href="#会话快捷键" class="headerlink" title="会话快捷键"></a>会话快捷键</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">ctrl</span>+<span class="hljs-keyword">b</span> d：分离会话<br><span class="hljs-symbol">ctrl</span>+<span class="hljs-keyword">b</span> s：列出所有会话<br><span class="hljs-symbol">ctrl</span>+<span class="hljs-keyword">b</span> $：重命名当前会话<br></code></pre></td></tr></table></figure><h1 id="窗格操作"><a href="#窗格操作" class="headerlink" title="窗格操作"></a>窗格操作</h1><h2 id="划分窗格"><a href="#划分窗格" class="headerlink" title="划分窗格"></a>划分窗格</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 划分上下两个窗格</span><br>$ tmux split-window<br><br><span class="hljs-comment"># 划分左右两个窗格</span><br>$ tmux split-window -h<br></code></pre></td></tr></table></figure><h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 光标切换到上方窗口</span><br>$ tmux select-pane -U<br><br><span class="hljs-comment"># 光标切换到下方窗格</span><br>$ tmux select-pane -D<br><br><span class="hljs-comment"># 光标切换到左边窗格</span><br>$ tmux select-pane -L<br><br><span class="hljs-comment"># 光标切换到右边窗格</span><br>$ tmux select-pane -R<br></code></pre></td></tr></table></figure><h2 id="交换窗格位置"><a href="#交换窗格位置" class="headerlink" title="交换窗格位置"></a>交换窗格位置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当前窗格上移</span><br>$ tmux swap-pane -U<br><br><span class="hljs-comment"># 当前窗格下移</span><br>$ tmux swap-pane -D<br></code></pre></td></tr></table></figure><h2 id="窗格快捷键总结"><a href="#窗格快捷键总结" class="headerlink" title="窗格快捷键总结"></a>窗格快捷键总结</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vim</title>
    <link href="/2025/02/22/MissingSemester/Vim/"/>
    <url>/2025/02/22/MissingSemester/Vim/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装</span><br>$ <span class="hljs-built_in">sudo</span> apt install vim<br><br><span class="hljs-comment"># 查看版本</span><br>$ vim --version<br></code></pre></td></tr></table></figure><span id="more"></span><h1 id="vim模式简介"><a href="#vim模式简介" class="headerlink" title="vim模式简介"></a>vim模式简介</h1><ul><li>命令模式：查看文件内容，修改文件，关键词条的搜索</li><li>编辑模式：修改文件内容</li><li>末行模式：执行Linux命令，保存文件，行跳转，窗口分屏</li></ul><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><h2 id="保存和退出"><a href="#保存和退出" class="headerlink" title="保存和退出"></a>保存和退出</h2><p>连续按两个大写的Z，即<code>ZZ</code>可在命令行模式下，保存并退出文件，等同于末行模式下的<code>:wq</code></p><h2 id="代码标准化"><a href="#代码标准化" class="headerlink" title="代码标准化"></a>代码标准化</h2><p>命令模式下，直接通过键盘输入<code>gg=G</code>，即可对代码进行标准化，使得代码排版更加工整。</p><h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><table><thead><tr><th align="center">快捷键</th><th align="left">功能</th><th align="left">备注</th></tr></thead><tbody><tr><td align="center">0</td><td align="left">光标移动到行首</td><td align="left">无</td></tr><tr><td align="center">$</td><td align="left">光标移动到行尾</td><td align="left">无</td></tr><tr><td align="center">gg</td><td align="left">光标移动到文件头</td><td align="left">第一行的开始</td></tr><tr><td align="center">G</td><td align="left">光标移动到文件尾</td><td align="left">最后一行的开始</td></tr><tr><td align="center">nG</td><td align="left">行跳转</td><td align="left">n代表要跳转到哪行</td></tr><tr><td align="center">n+回车</td><td align="left">相对跳转n行</td><td align="left">从光标开始处往下跳转n行</td></tr></tbody></table><h2 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h2><p>vim中没有删除操作，删除即剪切，剪切后可复制到其他地方。</p><table><thead><tr><th align="center">快捷键</th><th align="center">功能</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">删除光标后面的单个字符</td><td align="center">无</td></tr><tr><td align="center">X</td><td align="center">删除光标前面的单个字符</td><td align="center">无</td></tr><tr><td align="center">dw</td><td align="center">删除单词</td><td align="center">要把光标移动到单词的第一个字母上</td></tr><tr><td align="center">d0</td><td align="center">删除光标前的字符串</td><td align="center">光标所在行前面的字符全部删除</td></tr><tr><td align="center">dD($)</td><td align="center">删除光标后面的字符串</td><td align="center">dD 和 d$ 功能一样</td></tr><tr><td align="center">dd</td><td align="center">删除光标所在行</td><td align="center">无</td></tr><tr><td align="center">ndd</td><td align="center">删除n行</td><td align="center">从光标开始往下删除n行</td></tr></tbody></table><h2 id="撤销和反撤销"><a href="#撤销和反撤销" class="headerlink" title="撤销和反撤销"></a>撤销和反撤销</h2><table><thead><tr><th align="center">快捷键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">u</td><td align="center">撤销</td></tr><tr><td align="center">ctrl+r</td><td align="center">反撤销</td></tr></tbody></table><h2 id="复制和粘贴"><a href="#复制和粘贴" class="headerlink" title="复制和粘贴"></a>复制和粘贴</h2><table><thead><tr><th align="center">快捷键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">yy</td><td align="center">复制光标所在行</td></tr><tr><td align="center">nyy</td><td align="center">从光标所在行向下复制n行</td></tr><tr><td align="center">p</td><td align="center">粘贴到光标所在行的下面</td></tr><tr><td align="center">P</td><td align="center">粘贴到光标所在行的上面</td></tr></tbody></table><h2 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h2><ul><li>v：进入字符可视模式，文本以字符为单位</li><li>V：进入行可视模式，文本以行为单位</li><li>ctrl+v：进入块可视模式，可以选择一个矩形内的文本</li></ul><table><thead><tr><th align="center">快捷键</th><th align="center">功能</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">d</td><td align="center">删除（剪切）</td><td align="center">删除可视模式下的可视块</td></tr><tr><td align="center">y</td><td align="center">复制</td><td align="center">复制可视模式下选中的数据块</td></tr><tr><td align="center">p</td><td align="center">数据粘贴到光标的后面</td><td align="center">无</td></tr><tr><td align="center">P</td><td align="center">数据粘贴到光标的前面</td><td align="center">无</td></tr></tbody></table><h3 id="代码块注释"><a href="#代码块注释" class="headerlink" title="代码块注释"></a>代码块注释</h3><p>1.通过<code>ctrl+v</code>进入块可视模式<br>2.移动光标选中多行代码开头<br>3.选择完毕后，输入大写的<code>I</code>进入<code>insert</code>模式<br>4.输入要插入的注释符<code>//</code><br>5.按ESC键退出</p><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><table><thead><tr><th align="center">快捷键</th><th align="center">功能</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">替换光标后的单个字符</td><td align="center">无</td></tr><tr><td align="center">R</td><td align="center">替换光标后的多个字符</td><td align="center">按ESC结束替换</td></tr></tbody></table><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><table><thead><tr><th align="center">搜索快捷键</th><th align="left">关键字遍历</th><th align="center">描述</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">&#x2F;</td><td align="left">n</td><td align="center">从当前位置向下</td><td align="center">无</td></tr><tr><td align="center"></td><td align="left">N</td><td align="center">从当前位置向上</td><td align="center">无</td></tr><tr><td align="center">?</td><td align="left">n</td><td align="center">从当前位置向上</td><td align="center">无</td></tr><tr><td align="center"></td><td align="left">N</td><td align="center">从当前位置向下</td><td align="center">无</td></tr><tr><td align="center">#</td><td align="left">n</td><td align="center">从当前位置向上</td><td align="center">光标当在需要搜索的关键字上按<code>#</code></td></tr><tr><td align="center"></td><td align="left">N</td><td align="center">从当前位置向下</td><td align="center">无</td></tr></tbody></table><h2 id="切换到编辑模式"><a href="#切换到编辑模式" class="headerlink" title="切换到编辑模式"></a>切换到编辑模式</h2><table><thead><tr><th align="center">快捷键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">i</td><td align="center">从光标前面开始输入</td></tr><tr><td align="center">o</td><td align="center">在光标下面创建新行，并从新行开始输入</td></tr><tr><td align="center">O</td><td align="center">在光标上面创建新行，并从新行开始输入</td></tr><tr><td align="center">A</td><td align="center">从当前行行尾开始输入</td></tr><tr><td align="center">S（大写S）</td><td align="center">删除当前行，在当前行开始输入</td></tr><tr><td align="center">a</td><td align="center">从光标的后面开始输入</td></tr><tr><td align="center">s（小写s）</td><td align="center">删除光标盖住的字符，并开始输入</td></tr><tr><td align="center">I（大写i）</td><td align="center">从当前行行首开始输入</td></tr></tbody></table><h1 id="末行模式"><a href="#末行模式" class="headerlink" title="末行模式"></a>末行模式</h1><h2 id="保存和退出-1"><a href="#保存和退出-1" class="headerlink" title="保存和退出"></a>保存和退出</h2><table><thead><tr><th align="center">末行模式下输入的命令</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">q</td><td align="center">退出</td></tr><tr><td align="center">q!</td><td align="center">直接退出不保存</td></tr><tr><td align="center">w</td><td align="center">保存不退出</td></tr><tr><td align="center">wq</td><td align="center">保存并退出</td></tr><tr><td align="center">x</td><td align="center">保存并退出</td></tr></tbody></table><h2 id="替换-1"><a href="#替换-1" class="headerlink" title="替换"></a>替换</h2><table><thead><tr><th align="center">末行模式下输入的命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">s&#x2F;被替换的关键字&#x2F;新的关键字&#x2F;g</td><td align="center">只对光标所在行进行替换</td></tr><tr><td align="center">行号1,行号2 s&#x2F;被替换关键字&#x2F;新的关键字&#x2F;g</td><td align="center">替换行号1-行号2之间的关键字</td></tr><tr><td align="center">%s&#x2F;被替换的关键字&#x2F;新的关键字&#x2F;g</td><td align="center">替换所有关键字</td></tr></tbody></table><h2 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h2><table><thead><tr><th align="center">末行模式下输入的命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">sp</td><td align="center">水平分屏，上下两个屏</td></tr><tr><td align="center">vsp</td><td align="center">垂直分屏，左右两个屏</td></tr><tr><td align="center">ctrl+w+w</td><td align="center">光标在打开的屏幕之间切换</td></tr><tr><td align="center">qall</td><td align="center">同时退出所有屏幕</td></tr><tr><td align="center">wqall</td><td align="center">保存并退出所有屏幕</td></tr><tr><td align="center">sp 文件名</td><td align="center">分屏的同时，打开指定文件</td></tr><tr><td align="center">vsp 文件名</td><td align="center">分屏的同时，打开指定文件</td></tr></tbody></table><p>vim打开多个文件的时候，可以分屏打开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 水平分屏，上下两个屏</span><br>$ vim -o file1 file2<br><br><span class="hljs-comment"># 垂直分屏，左右两个屏</span><br>$ vim -O file1 file2<br></code></pre></td></tr></table></figure><h2 id="执行shell命令（-）"><a href="#执行shell命令（-）" class="headerlink" title="执行shell命令（:!）"></a>执行shell命令（:!）</h2><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">:!shell命令<br>:!ls<br></code></pre></td></tr></table></figure><h1 id="vim配置文件"><a href="#vim配置文件" class="headerlink" title="vim配置文件"></a>vim配置文件</h1><ul><li>用户级别的配置文件：<code>~/.vimrc</code></li><li>系统级别的配置文件：<code>/etc/vim/vimrc</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CMake</title>
    <link href="/2025/02/22/MissingSemester/cmake/"/>
    <url>/2025/02/22/MissingSemester/cmake/</url>
    
    <content type="html"><![CDATA[<h1 id="1-CMake概述"><a href="#1-CMake概述" class="headerlink" title="1.CMake概述"></a>1.CMake概述</h1><p>CMake是一个项目构建工具，是跨平台的。CMake可以自动生成Makefile文件，管理项目更加简单。</p><span id="more"></span><h2 id="1-1-CMake使用流程"><a href="#1-1-CMake使用流程" class="headerlink" title="1.1 CMake使用流程"></a>1.1 CMake使用流程</h2><p>1.项目中添加CMakeLists.txt文件<br>2.新建一个名为build的文件夹<br>3.在build文件夹中执行cmake <CMakeLists-file-path>构建makefile文件<br>4.执行make指令</p><h1 id="2-CMake的用法"><a href="#2-CMake的用法" class="headerlink" title="2.CMake的用法"></a>2.CMake的用法</h1><h2 id="2-1-查看版本号"><a href="#2-1-查看版本号" class="headerlink" title="2.1 查看版本号"></a>2.1 查看版本号</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ cmake --version       <span class="hljs-comment"># 查看版本号</span><br>cmake version 3.28.3<br></code></pre></td></tr></table></figure><h2 id="2-2-注释"><a href="#2-2-注释" class="headerlink" title="2.2 注释"></a>2.2 注释</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-comment"># 使用 # 进行行注释</span><br><span class="hljs-comment"># 这是一行注释</span><br><br><span class="hljs-comment"># 使用 #[[]] 进行块注释</span><br><span class="hljs-comment">#[[</span><br><span class="hljs-comment">    这是块注释</span><br><span class="hljs-comment">]]</span><br></code></pre></td></tr></table></figure><h2 id="2-3-常用的一些宏"><a href="#2-3-常用的一些宏" class="headerlink" title="2.3 常用的一些宏"></a>2.3 常用的一些宏</h2><ul><li><code>CMAKE_CURRENT_SOURCE_DIR</code>：表示当前访问的 CMakeLists.txt 文件所在的路径。</li><li><code>CMAKE_SOURCE_DIR</code>：项目的源代码根目录，即包含顶层 CMakeLists.txt 文件的目录。</li><li><code>CMAKE_BINARY_DIR</code>：项目的二进制根目录，即当前正在执行 CMake 命令的目录。</li><li><code>EXECUTABLE_OUTPUT_PATH</code>：指定可执行文件的输出目录。</li><li><code>LIBRARY_OUTPUT_PATH</code>：指定库文件的输出目录。</li></ul><h2 id="2-4-常用函数"><a href="#2-4-常用函数" class="headerlink" title="2.4 常用函数"></a>2.4 常用函数</h2><h3 id="1-指定使用的CMake的最低版本"><a href="#1-指定使用的CMake的最低版本" class="headerlink" title="1.指定使用的CMake的最低版本"></a>1.指定使用的CMake的最低版本</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br></code></pre></td></tr></table></figure><h3 id="2-定义工程名称"><a href="#2-定义工程名称" class="headerlink" title="2.定义工程名称"></a>2.定义工程名称</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">project</span>(<span class="hljs-keyword">project</span>-name)<br></code></pre></td></tr></table></figure><h3 id="3-生成可执行程序"><a href="#3-生成可执行程序" class="headerlink" title="3.生成可执行程序"></a>3.生成可执行程序</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">add_executable</span>(可执行程序名 源文件名称)<br><br><span class="hljs-comment"># 示例：（源文件可以是多个，之间用空格或者；间隔）</span><br><span class="hljs-keyword">add_executable</span>(app add.c div.c main.c mult.c sub.c)<br><span class="hljs-keyword">add_executable</span>(app add.c;div.c;main.c;mult.c;sub.c)<br></code></pre></td></tr></table></figure><h3 id="4-定义变量"><a href="#4-定义变量" class="headerlink" title="4.定义变量"></a>4.定义变量</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-comment"># VAR:变量名    VALUE:变量值</span><br><span class="hljs-keyword">set</span>(VAR VALUE)<br><br><span class="hljs-comment"># 示例：</span><br><span class="hljs-keyword">set</span>(SRC add.c div.c main.c mult.c sub.c)<br><span class="hljs-keyword">add_executable</span>(app <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure><h3 id="5-指定只用的C-标准"><a href="#5-指定只用的C-标准" class="headerlink" title="5.指定只用的C++标准"></a>5.指定只用的C++标准</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-comment"># 方法1：在SHELL中使用g++指令的时候</span><br>$ g++ *.cpp -std=c++<span class="hljs-number">11</span> -o app<br><br><span class="hljs-comment"># 方法2：在CMakeLists.txt中通过set命令指定</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)<br><br><span class="hljs-comment"># 方法3：在执行cmake命令的时候指定</span><br>$ cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=<span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><h3 id="6-指定可执行文件输出的路径"><a href="#6-指定可执行文件输出的路径" class="headerlink" title="6.指定可执行文件输出的路径"></a>6.指定可执行文件输出的路径</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-comment"># 如果路径中的子目录不存在，会自动生成</span><br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)<br></code></pre></td></tr></table></figure><h3 id="7-查找某个路径下的所有源文件"><a href="#7-查找某个路径下的所有源文件" class="headerlink" title="7.查找某个路径下的所有源文件"></a>7.查找某个路径下的所有源文件</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-comment"># dir:要搜索的目录</span><br><span class="hljs-comment"># variable:将搜索到的源文件列表存储到改变量中</span><br><span class="hljs-keyword">aux_source_directory</span>(&lt;dir&gt; &lt;variable&gt;)<br><br><span class="hljs-comment"># 示例：</span><br><span class="hljs-keyword">aux_source_directory</span>(<span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src SRC)<br><span class="hljs-keyword">add_executable</span>(app <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure><h3 id="8-根据指定条件搜索文件"><a href="#8-根据指定条件搜索文件" class="headerlink" title="8.根据指定条件搜索文件"></a>8.根据指定条件搜索文件</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-comment"># GLOB:将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。</span><br><span class="hljs-comment"># GLOB_RECURSE:递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。</span><br><span class="hljs-keyword">file</span>(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件名)<br><br><span class="hljs-comment"># 示例：</span><br><span class="hljs-keyword">file</span>(GLOB MAIN_SRC <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)<br><span class="hljs-keyword">file</span>(GLOB MAIN_HEAD <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR/include/*.h&#125;</span>)<br></code></pre></td></tr></table></figure><h3 id="9-包含头文件"><a href="#9-包含头文件" class="headerlink" title="9.包含头文件"></a>9.包含头文件</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-comment"># head-path:头文件所在路径</span><br><span class="hljs-keyword">include_directories</span>(head-path)<br><br><span class="hljs-comment"># 示例：</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br></code></pre></td></tr></table></figure><h3 id="10-制作静态库"><a href="#10-制作静态库" class="headerlink" title="10.制作静态库"></a>10.制作静态库</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">add_library</span>(库名称 STATIC 源文件)<br><br><span class="hljs-comment">#示例：(最终会生成对应的静态库文件 libcalc.a)</span><br><span class="hljs-comment"># 搜索源文件</span><br><span class="hljs-keyword">file</span>(GLOB SRC <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/*.cpp)<br><br><span class="hljs-comment"># 包含头文件</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><br><span class="hljs-comment"># 指定静态库输出位置</span><br><span class="hljs-keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)<br><br><span class="hljs-comment"># 生成静态库</span><br><span class="hljs-keyword">add_library</span>(calc STATIC <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure><h3 id="11-制作动态库"><a href="#11-制作动态库" class="headerlink" title="11.制作动态库"></a>11.制作动态库</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">add_library</span>(库名称 SHARED 源文件)<br><br><span class="hljs-comment">#示例：(最终会生成对应的静态库文件 libcalc.so)</span><br><span class="hljs-keyword">file</span>(GLOB SRC <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/*.cpp)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)<br><span class="hljs-keyword">add_library</span>(calc SHARED <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure><h3 id="12-指定静态库-动态库的输出路径"><a href="#12-指定静态库-动态库的输出路径" class="headerlink" title="12.指定静态库&#x2F;动态库的输出路径"></a>12.指定静态库&#x2F;动态库的输出路径</h3><p><strong>方式1-适用于动态库</strong><br>由于在Linux下生成的动态库默认是有可执行权限的，所以可以使用宏<code>EXECUTABLE_OUTPUT_PATH</code>来指定动态库的输出路径。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-comment"># 示例：（最终会在./lib文件夹下生成动态库）</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-keyword">file</span>(GLOB SRC <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/*.cpp)<br><br><span class="hljs-comment">#设置动态库生成路径</span><br><span class="hljs-keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)<br><span class="hljs-keyword">add_library</span>(calc SHARED <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure><p><strong>方式2-适用于静态库和动态库</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-keyword">file</span>(GLOB SRC <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/*.cpp)<br><br><span class="hljs-comment">#设置静态库/动态库生成路径</span><br><span class="hljs-keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)<br><br><span class="hljs-comment">#在指定文件夹下生成静态库</span><br><span class="hljs-keyword">add_library</span>(calc STATIC <span class="hljs-variable">$&#123;SRC&#125;</span>)<br><br><span class="hljs-comment">#在指定文件夹下生成动态库</span><br><span class="hljs-keyword">add_library</span>(calc SHARED <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure><h3 id="13-链接静态库"><a href="#13-链接静态库" class="headerlink" title="13. 链接静态库"></a>13. 链接静态库</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-comment"># 指定静态库的路径</span><br><span class="hljs-keyword">link_directories</span>(&lt;lib-path&gt;)<br><br><span class="hljs-comment"># 链接静态库 </span><br><span class="hljs-keyword">link_libraries</span>(&lt;static-lib&gt;)<br></code></pre></td></tr></table></figure><p><code>link_libraries</code>用于设置全局链接库，这些库会链接到之后定义的所有目标上。指定要链接的静态库名字：</p><ul><li>可以是全名 libxxx.a</li><li>也可以是掐头（lib）去尾（.a）之后的名字 xxx</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-comment"># 示例：</span><br><span class="hljs-comment"># 搜索指定目录下源文件</span><br><span class="hljs-keyword">file</span>(GLOB SRC <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)<br><span class="hljs-comment"># 包含头文件路径</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-comment"># 包含静态库路径</span><br><span class="hljs-keyword">link_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)<br><span class="hljs-comment"># 链接静态库</span><br><span class="hljs-keyword">link_libraries</span>(calc)<br><span class="hljs-comment"># 指定静态库输出位置</span><br><span class="hljs-keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)<br><span class="hljs-comment"># 生成可执行文件 app</span><br><span class="hljs-keyword">add_executable</span>(app <span class="hljs-variable">$&#123;SRC&#125;</span>)<br></code></pre></td></tr></table></figure><h3 id="14-链接动态库"><a href="#14-链接动态库" class="headerlink" title="14.链接动态库"></a>14.链接动态库</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-comment"># 指定动态库的路径</span><br><span class="hljs-keyword">link_directories</span>(&lt;lib-path&gt;)<br><br><span class="hljs-comment"># 链接动态库 </span><br><span class="hljs-keyword">target_link_libraries</span>(&lt;<span class="hljs-keyword">target</span>&gt; &lt;shared-lib&gt;)<br></code></pre></td></tr></table></figure><p><code>target_link_libraries</code>用于指定一个目标在编译时需要链接哪些库。它支持指定库的名称，路径以及链接库的顺序。<br><code>target</code>：链接动态库之后目标文件<br><code>shared-lib</code>：需要链接的库的名称</p><ul><li>PUBLIC：用于传递性的链接</li><li>PRIVATE：用于非传递性的链接</li><li>INTERFACE：用于定义接口，这些接口不会链接到声明它们的库或可执行文件，但会链接到依赖它们的其他目标。</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-comment"># 示例：</span><br><span class="hljs-comment"># 搜索指定目录下源文件</span><br><span class="hljs-keyword">file</span>(GLOB SRC <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)<br><span class="hljs-comment"># 包含头文件路径</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><span class="hljs-comment"># 包含动态库路径</span><br><span class="hljs-keyword">link_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)<br><span class="hljs-comment"># 指定静态库输出位置</span><br><span class="hljs-keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)<br><span class="hljs-comment"># 生成可执行文件 app</span><br><span class="hljs-keyword">add_executable</span>(app <span class="hljs-variable">$&#123;SRC&#125;</span>)<br><span class="hljs-comment"># 链接动态库</span><br><span class="hljs-keyword">target_link_libraries</span>(app calc)<br></code></pre></td></tr></table></figure><h3 id="15-添加子目录"><a href="#15-添加子目录" class="headerlink" title="15.添加子目录"></a>15.添加子目录</h3><p>Linux的目录是树状结构，所以嵌套的 CMake 也是一个树状结构，最顶层的 CMakeLists.txt 是根节点，其次都是子节点。</p><ul><li>根节点CMakeLists.txt中的变量全局有效</li><li>父节点CMakeLists.txt中的变量可以在子节点中使用</li><li>子节点CMakeLists.txt中的变量只能在当前节点中使用</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-comment"># source_dir：指定子目录。</span><br><span class="hljs-comment"># binary_dir：指定了输出文件的路径，一般不需要指定。</span><br><span class="hljs-comment"># EXCLUDE_FROM_ALL：一般不需要设置，忽略。</span><br><span class="hljs-keyword">add_subdirectory</span>(source_dir [binary-dir] [EXCLUDE_FROM_ALL])<br><br><span class="hljs-comment">#示例：</span><br><span class="hljs-keyword">add_subdirectory</span>(calc)<br></code></pre></td></tr></table></figure><h3 id="15-日志"><a href="#15-日志" class="headerlink" title="15.日志"></a>15.日志</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">message</span>([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] <span class="hljs-string">&quot;message to display&quot;</span>)<br></code></pre></td></tr></table></figure><ul><li>(无)：重要消息</li><li>STATUS：非重要消息</li><li>WARNING：CMake警告，会继续执行</li><li>AUTHOR_WARNING：CMake警告，会继续执行</li><li>SEND_ERROR：CMake 错误，继续执行，但是会跳过生成的步骤</li><li>FATAL_ERROR：CMake 错误, 终止所有处理过程</li></ul><p>CMake的命令行工具会在stdout上显示(无)或STATUS消息，在stderr上显示其他所有消息。CMake的GUI会在它的log区域显示所有消息。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-comment"># 示例：</span><br><span class="hljs-comment"># 输出一般日志信息</span><br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)<br><span class="hljs-comment"># 输出警告信息</span><br><span class="hljs-keyword">message</span>(WARNING <span class="hljs-string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)<br><span class="hljs-comment"># 输出错误信息</span><br><span class="hljs-keyword">message</span>(FATAL_ERROR <span class="hljs-string">&quot;source path: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="16-变量操作"><a href="#16-变量操作" class="headerlink" title="16.变量操作"></a>16.变量操作</h3><p>1.使用set拼接<br>将从第二个参数开始往后所有的字符串进行拼接，最后将结果存储到第一个参数中，如果第一个参数中原来有数据会对原数据就行覆盖。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">set</span>(变量名<span class="hljs-number">1</span> <span class="hljs-variable">$&#123;变量名1&#125;</span> <span class="hljs-variable">$&#123;变量名2&#125;</span> ...)<br></code></pre></td></tr></table></figure><p>2.获取list的长度</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-comment"># LENGTH：关键字</span><br><span class="hljs-comment"># list：当前操作列表</span><br><span class="hljs-comment"># output-variable：新创建的变量，用于存储列表长度</span><br><span class="hljs-keyword">list</span>(LENGTH &lt;<span class="hljs-keyword">list</span>&gt; &lt;output variable&gt;)<br></code></pre></td></tr></table></figure><p>3.读取列表中指定索引的的元素，可以指定多个索引</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-comment"># element-index：列表元素的索引，索引0为列表第一个元素；索引也可以是负数，-1表示列表的最后一个元素，-2表示列表倒数第二个元素；</span><br><span class="hljs-comment"># output-variable：新创建的变量，存储指定索引元素的返回结果，也是一个列表</span><br><span class="hljs-keyword">list</span>(GET &lt;<span class="hljs-keyword">list</span>&gt; &lt;element-index&gt; &lt;output-variable&gt;)<br></code></pre></td></tr></table></figure><p>4.将列表中的元素用连接符（字符串）连接起来组成一个字符串</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-comment"># glue：指定的连接符（字符串）</span><br><span class="hljs-keyword">list</span> (JOIN &lt;<span class="hljs-keyword">list</span>&gt; &lt;glue&gt; &lt;output-variable&gt;)<br></code></pre></td></tr></table></figure><p>5.查找列表是否存在指定的元素，若果未找到，返回-1</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-comment"># output-variable：如果找到则为索引值，否则为-1</span><br><span class="hljs-keyword">list</span>(FIND &lt;<span class="hljs-keyword">list</span>&gt; &lt;value&gt; &lt;output-variable&gt;)<br></code></pre></td></tr></table></figure><p>6.将元素追加到列表中</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">list</span> (APPEND &lt;<span class="hljs-keyword">list</span>&gt; &lt;element&gt;)<br></code></pre></td></tr></table></figure><p>7.在list中指定的位置插入若干元素</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">list</span>(INSERT &lt;<span class="hljs-keyword">list</span>&gt; &lt;element-index&gt; &lt;element&gt;)<br></code></pre></td></tr></table></figure><p>8.将元素插入到列表的0索引位置</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">list</span> (PREPEND &lt;<span class="hljs-keyword">list</span>&gt; &lt;element&gt;)<br></code></pre></td></tr></table></figure><p>9.将列表中最后元素移除</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">list</span> (POP_BACK &lt;<span class="hljs-keyword">list</span>&gt; &lt;out-var&gt;)<br></code></pre></td></tr></table></figure><p>10.将列表中第一个元素移除</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">list</span> (POP_FRONT &lt;<span class="hljs-keyword">list</span>&gt; &lt;out-var&gt;)<br></code></pre></td></tr></table></figure><p>11.将指定的元素从列表中移除</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">list</span> (REMOVE_ITEM &lt;<span class="hljs-keyword">list</span>&gt; &lt;value&gt;)<br></code></pre></td></tr></table></figure><p>12.将指定索引的元素从列表中移除</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">list</span> (REMOVE_AT &lt;<span class="hljs-keyword">list</span>&gt; &lt;index&gt;)<br></code></pre></td></tr></table></figure><p>13.移除列表中的重复元素</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">list</span> (REMOVE_DUPLICATES &lt;<span class="hljs-keyword">list</span>&gt;)<br></code></pre></td></tr></table></figure><p>14.列表翻转</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">list</span>(REVERSE &lt;<span class="hljs-keyword">list</span>&gt;)<br></code></pre></td></tr></table></figure><p>15.列表排序</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">list</span> (SORT &lt;<span class="hljs-keyword">list</span>&gt; [COMPARE &lt;compare&gt;] [CASE &lt;case&gt;] [ORDER &lt;order&gt;])<br></code></pre></td></tr></table></figure><p>COMPARE：指定排序方法。有如下几种值可选</p><ul><li>STRING：按照字母顺序进行排序，为默认的排序方法</li><li>FILE_BASENAME：如果是一系列路径名，会使用basename进行排序</li><li>NATURAL：使用自然数顺序排序</li></ul><p>CASE：指明是否大小写敏感。有如下几种值可选：</p><ul><li>SENSITIVE: 按照大小写敏感的方式进行排序，为默认值</li><li>INSENSITIVE：按照大小写不敏感方式进行排序</li></ul><p>ORDER：指明排序的顺序。有如下几种值可选：</p><ul><li>ASCENDING：按照升序排列，为默认值</li><li>DESCENDING：按照降序排列</li></ul><h2 id="2-5-宏定义"><a href="#2-5-宏定义" class="headerlink" title="2.5 宏定义"></a>2.5 宏定义</h2><p>在进行程序测试的时候，我们可以在代码中添加一些宏定义，通过这些宏来控制这些代码是否生效：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUMBER  3</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DEBUG</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is debug place\n&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;NUMBER; ++i)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello, world\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了测试更加灵活，一般不在代码中定义这个宏，而是在测试的时候把这个宏定义出来。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-comment"># 在gcc/g++命令中定义</span><br>$ gcc main.c -DDEBUG -o app<br><br><span class="hljs-comment"># 在CMakeLists.txt文件中定义</span><br><span class="hljs-keyword">add_definitions</span>(-DDEBUG)<br><span class="hljs-keyword">add_executable</span>(app ./main.c)<br></code></pre></td></tr></table></figure><h1 id="生成能够gdb调试的可执行文件"><a href="#生成能够gdb调试的可执行文件" class="headerlink" title="生成能够gdb调试的可执行文件"></a>生成能够gdb调试的可执行文件</h1><p>在CMakeLists.txt中加入：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">SET</span>(CMAKE_BUILD_TYPE <span class="hljs-string">&quot;Debug&quot;</span>)<br><span class="hljs-keyword">SET</span>(CMAKE_CXX_FLAGS_DEBUG <span class="hljs-string">&quot;$ENV&#123;CXXFLAGS&#125; -O0 -Wall -g2 -ggdb&quot;</span>)<br><span class="hljs-keyword">SET</span>(CMAKE_CXX_FLAGS_RELEASE <span class="hljs-string">&quot;$ENV&#123;CXXFLAGS&#125; -O3 -Wall&quot;</span>)<br></code></pre></td></tr></table></figure><p>CMAKE_BUILD_TYPE是CMake构建系统使用的一个变量，用于指定编译时的优化级别和调试信息的详细程度，常用的值有:</p><ul><li>Debug</li><li>Release</li><li>RelWithDebInfo</li><li>MinSizeRel<br>当这个变量值为 Debug 的时候,CMake 会使用变量 CMAKE_CXX_FLAGS_DEBUG 和 CMAKE_C_FLAGS_DEBUG 中的字符串作为编译选项生成 Makefile</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://subingwen.cn/cmake/CMake-primer/">大丙老师的 CMake 保姆级教程-上</a><br><a href="https://subingwen.cn/cmake/CMake-advanced/">大丙老师的 CMake 保姆级教程-下</a></p>]]></content>
    
    
    <categories>
      
      <category>cmake</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gcc</title>
    <link href="/2025/02/22/MissingSemester/gcc/"/>
    <url>/2025/02/22/MissingSemester/gcc/</url>
    
    <content type="html"><![CDATA[<h1 id="gcc编译流程"><a href="#gcc编译流程" class="headerlink" title="gcc编译流程"></a>gcc编译流程</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.预处理</span><br>$ gcc -E main.c -o main.i<br><br><span class="hljs-comment"># 2.编译</span><br>$ gcc -S main.i -o main.s<br><br><span class="hljs-comment"># 3.汇编</span><br>$ gcc -c main.s -o main.o<br><br><span class="hljs-comment"># 4.链接</span><br>$ gcc main.o -o main<br></code></pre></td></tr></table></figure><span id="more"></span><h1 id="gcc常用参数"><a href="#gcc常用参数" class="headerlink" title="gcc常用参数"></a>gcc常用参数</h1><ul><li>-E：预处理，不进行编译</li><li>-S：编译，但不汇编</li><li>-c：编译并汇编，但不链接</li><li>-o：指定生成的文件名</li><li>-I：指定include包含文件的目录</li><li>-g：生成调试信息</li><li>-D：编译的时候指定一个宏</li><li>-W：不生成任何警告</li><li>-Wall：生成所有警告</li><li>-On：代码优化</li><li>-l：编译的时候，指定使用的库</li><li>-L：指定编译的时候搜索库的路径</li><li>-fpic：生成与位置无关代码</li><li>-shared：生成共享目标文件</li><li>-std：指定标准</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>coredump</title>
    <link href="/2025/02/22/MissingSemester/coredump/"/>
    <url>/2025/02/22/MissingSemester/coredump/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是coredump"><a href="#什么是coredump" class="headerlink" title="什么是coredump"></a>什么是coredump</h1><p>coredump又叫核心转储，是程序崩溃时候的一个内存快照，存储了进程的内存，寄存器状态，运行堆栈等信息。</p><p>是一个二进制文件，可以使用以下工具打开分析：</p><p>Linux中可以使用：gdb，elfdump，objdump</p><p>Windows中可以使用：windebug，solaris下的mdb</p><span id="more"></span><h1 id="什么时候使用coredump"><a href="#什么时候使用coredump" class="headerlink" title="什么时候使用coredump"></a>什么时候使用coredump</h1><p>业务逻辑上的bug，比如参数设置，这种不会导致程序崩溃的错误，使用printf这类输出函数打点调试；</p><p>致命操作的bug，比如访问未经申请的内存地址，导致程序崩溃，此时不能使用printf，应该怎么调试呢？</p><p>对于必现的bug，一般使用GDB设置断点，逐步执行程序，检查变量和内存，以及回溯调用栈来定位问题。但是对于偶现的bug（多线程竞争，事件相关，资源限制等），由于只在某些特定的条件下发生，所以比较难通过GDB调试，这个时候就可以使用Linux提供的coredump文件进行调试。</p><h1 id="coredump文件生成原理"><a href="#coredump文件生成原理" class="headerlink" title="coredump文件生成原理"></a>coredump文件生成原理</h1><p>在程序发生某些错误而导致进程异常退出的时候，Linux内核会根据进程当时的内存信息，生成coredump文件。GDB通过coredump文件可以重现当时的场景，从而定位错误信息。</p><ol><li>程序发生错误 -&gt; 产生信号</li><li>进程内核检测到对应信号 -&gt; 生成coredump文件</li></ol><p>以下信号会导致生成coredump文件：</p><ul><li>SIGILL：非法指令信号</li><li>SIGABRT：由abort()函数发起的信号，用于异常终止程序</li><li>SIGSEGV：无效的内存引用信号，当程序试图访问未分配或不允许访问的内存时</li><li>SIGTRAP：由断点或者某些调试器触发的信号，用于调试目的</li><li>SIGFPE：浮点异常信号，如算术溢出，除以零</li><li>SIGBUG：硬件故障信号，如非法内存访问</li><li>SIGSIS：无效的系统调用信号</li></ul><p>当进程从内核态返回到用户态前，内核会检查进程的信号队列中是否有信号没有处理，如果有就调用 <code>do_signal</code>内核函数处理信号，流程如下：</p><p><img src="/../image/coredump.bmp" alt="img"></p><h2 id="信号处理do-signal"><a href="#信号处理do-signal" class="headerlink" title="信号处理do_signal()"></a>信号处理do_signal()</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> fastcall <span class="hljs-title">do_signal</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">siginfo_t</span> info;<br>    <span class="hljs-type">int</span> signr;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">k_sigaction</span> ka;<br>    <span class="hljs-type">sigset_t</span> *oldset;<br><br>    ...<br>    signr = <span class="hljs-built_in">get_signal_to_deliver</span>(&amp;info, &amp;ka, regs, <span class="hljs-literal">NULL</span>);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数负责将用户空间的信号传递给进程。其中该函数接收一个指向 <code>pt_regs</code>结构的指针作为参数，其中包含了程序计数器、栈指针和所有通用寄存器，这些寄存器在信号处理时被保存。</p><h2 id="信号获取get-signal-to-deliver"><a href="#信号获取get-signal-to-deliver" class="headerlink" title="信号获取get_signal_to_deliver()"></a>信号获取get_signal_to_deliver()</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_signal_to_deliver</span><span class="hljs-params">(<span class="hljs-type">siginfo_t</span> *info, <span class="hljs-keyword">struct</span> k_sigaction *return_ka,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-keyword">struct</span> pt_regs *regs, <span class="hljs-type">void</span> *cookie)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">sigset_t</span> *mask = &amp;current-&gt;blocked;<br>    <span class="hljs-type">int</span> signr = <span class="hljs-number">0</span>;<br><br>    ...<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        ...<br>        <span class="hljs-comment">// 1. 从进程信号队列中获取一个信号</span><br>        signr = <span class="hljs-built_in">dequeue_signal</span>(current, mask, info); <br><br>        ...<br>        <span class="hljs-comment">// 2. 判断是否会生成 coredump 文件的信号</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sig_kernel_coredump</span>(signr)) &#123;<br>            <span class="hljs-comment">// 3. 调用 do_coredump() 函数生成 coredump 文件</span><br>            <span class="hljs-built_in">do_coredump</span>((<span class="hljs-type">long</span>)signr, signr, regs);<br>        &#125;<br>        ...<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>get_signal_to_deliver</code>函数主要完成以下三个工作：</p><ul><li>调用 <code>dequeue_signal</code>函数从进程的信号队列中获取一个信号</li><li>调用 <code>sig_kernel_coredump</code>函数判断信号是否会生成coredump文件</li><li>如果信号会生成coredump文件，那么就调用 <code>do_coredump</code>函数生成coredump文件</li></ul><h2 id="生成coredump文件"><a href="#生成coredump文件" class="headerlink" title="生成coredump文件"></a>生成coredump文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">do_coredump</span><span class="hljs-params">(<span class="hljs-type">long</span> signr, <span class="hljs-type">int</span> exit_code, <span class="hljs-keyword">struct</span> pt_regs *regs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> corename[CORENAME_MAX_SIZE + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mm_struct</span> *mm = current-&gt;mm;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">linux_binfmt</span> *binfmt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">inode</span> *inode;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file</span> *file;<br>    <span class="hljs-type">int</span> retval = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> fsuid = current-&gt;fsuid;<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ispipe = <span class="hljs-number">0</span>;<br><br>    binfmt = current-&gt;binfmt; <span class="hljs-comment">// 当前进程所使用的可执行文件格式（如ELF格式）</span><br><br>    ...<br>    <span class="hljs-comment">// 1. 判断当前进程可生成的 coredump 文件大小是否受到资源限制</span><br>    <span class="hljs-keyword">if</span> (current-&gt;signal-&gt;rlim[RLIMIT_CORE].rlim_cur &lt; binfmt-&gt;min_coredump)<br>        <span class="hljs-keyword">goto</span> fail_unlock;<br><br>    ...<br>    <span class="hljs-comment">// 2. 生成 coredump 文件名</span><br>    ispipe = format_corename(corename, core_pattern, signr);<br><br>    ...<br>    <span class="hljs-comment">// 3. 创建 coredump 文件</span><br>    file = <span class="hljs-built_in">filp_open</span>(corename, O_CREAT|<span class="hljs-number">2</span>|O_NOFOLLOW|O_LARGEFILE|flag, <span class="hljs-number">0600</span>);<br><br>    ...<br>    <span class="hljs-comment">// 4. 把进程的内存信息写入到 coredump 文件中</span><br>    retval = binfmt-&gt;<span class="hljs-built_in">core_dump</span>(signr, regs, file);<br><br>fail_unlock:<br>    ...<br>    <span class="hljs-keyword">return</span> retval;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>do_coredump</code>函数主要完成以下四个工作：</p><ul><li>判断当前进程可生成的coredump文件大小是否收到资源限制</li><li>如果不受限制调用 <code>format_corename</code>生成coredump文件的文件名</li><li>调用 <code>filp_open</code>函数创建coredump文件</li><li>根据当前进程所使用的可执行文件格式选择相应的方式填充coredump文件的内容</li><li>elf文件格式使用的是 <code>elf_core_dump</code>方法</li></ul><h1 id="coredump文件使用-准备阶段"><a href="#coredump文件使用-准备阶段" class="headerlink" title="coredump文件使用-准备阶段"></a>coredump文件使用-准备阶段</h1><h2 id="生成coredump文件到当前目录下"><a href="#生成coredump文件到当前目录下" class="headerlink" title="生成coredump文件到当前目录下"></a>生成coredump文件到当前目录下</h2><p>要让core文件生成在当前目录下，你可以通过设置 <code>/proc/sys/kernel/core_pattern</code>文件来指定core文件的保存位置和命名模式。以下是具体的步骤：</p><ol><li><p><strong>开启core文件生成</strong>：<br>使用 <code>ulimit -c unlimited</code>命令来确保系统允许生成core文件。</p></li><li><p><strong>设置core文件的命名模式</strong>：<br>使用 <code>echo</code>命令将core文件的命名模式设置为当前目录下。具体命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;./core-%e-%p-%t&#x27;</span> &gt; /proc/sys/kernel/core_pattern<br></code></pre></td></tr></table></figure><p>这个命令会将core文件统一生成到当前目录下，文件名为 <code>core-命令名-pid-时间戳</code>。</p></li><li><p><strong>参数解释</strong>：</p><ul><li><code>%p</code>：插入pid到文件名中，即进程ID。</li><li><code>%e</code>：插入产生core文件的命令名到文件名中。</li><li><code>%t</code>：插入Unix时间戳到文件名中，即core文件生成时的时间。</li></ul></li></ol><p>执行上述命令后，如果程序再次发生段错误，core文件将会生成在程序运行的当前目录下，并且文件名包含了程序名、进程ID和时间戳，这样你就可以更容易地识别和管理这些core文件了。</p><p>需要注意的是，修改 <code>/proc/sys/kernel/core_pattern</code>可能需要root权限，如果遇到权限问题，可以尝试使用 <code>sudo</code>命令来执行。同时，这些设置是临时的，重启系统后会恢复默认设置。如果需要永久设置，可以修改 <code>/etc/sysctl.conf</code>文件并添加相应的配置行，然后运行 <code>sysctl -p</code>来使设置生效。</p><h2 id="设置永久保存"><a href="#设置永久保存" class="headerlink" title="设置永久保存"></a>设置永久保存</h2><p>打开&#x2F;etc&#x2F;security&#x2F;limits.conf文件，在该文件的最后加上两行，配置后重启后生效。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@root</span> soft core unlimited<br><span class="hljs-variable">@root</span> hard core unlimited<br></code></pre></td></tr></table></figure><p>命名规则的修改在&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern中也只是临时的，这个也是动态加载和生成的。永久修改在&#x2F;etc&#x2F;sysctl.conf文件中，在该文件的最后加上两行：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">kernel.core_pattern</span> = ./core-%e-%p-%t<br><span class="hljs-attr">kernel.core_uses_pid</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以使用该命令，立即生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> su<br><span class="hljs-comment"># sysctl –p</span><br><span class="hljs-comment"># exit</span><br></code></pre></td></tr></table></figure><h2 id="coredump命名规则"><a href="#coredump命名规则" class="headerlink" title="coredump命名规则"></a>coredump命名规则</h2><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sas">产生的文件名为core-命令名-pid-时间戳<br>以下是参数列表:<br><span class="hljs-title function_">%p</span> - <span class="hljs-keyword">insert</span> pid <span class="hljs-keyword">into</span> <span class="hljs-keyword">filename</span> 添加pid<br><span class="hljs-title function_">%u</span> - <span class="hljs-keyword">insert</span> current uid <span class="hljs-keyword">into</span> <span class="hljs-keyword">filename</span> 添加当前uid<br><span class="hljs-title function_">%g</span> - <span class="hljs-keyword">insert</span> current gid <span class="hljs-keyword">into</span> <span class="hljs-keyword">filename</span> 添加当前gid<br><span class="hljs-title function_">%s</span> - <span class="hljs-keyword">insert</span> signal that caused the coredump <span class="hljs-keyword">into</span> the <span class="hljs-keyword">filename</span> 添加导致产生core的信号<br><span class="hljs-title function_">%t</span> - <span class="hljs-keyword">insert</span> UNIX time that the coredump occurred <span class="hljs-keyword">into</span> <span class="hljs-keyword">filename</span> 添加core文件生成时的unix时间<br><span class="hljs-title function_">%h</span> - <span class="hljs-keyword">insert</span> hostname <span class="hljs-keyword">where</span> the coredump happened <span class="hljs-keyword">into</span> <span class="hljs-keyword">filename</span> 添加主机名<br><span class="hljs-title function_">%e</span> - <span class="hljs-keyword">insert</span> coredumping executable name <span class="hljs-keyword">into</span> <span class="hljs-keyword">filename</span> 添加命令名<br></code></pre></td></tr></table></figure><h2 id="proc-sys-kernel-core-pattern"><a href="#proc-sys-kernel-core-pattern" class="headerlink" title="&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern"></a>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern</h2><p>&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern是一个位于&#x2F;proc伪文件系统中的文件，它用于定义系统在发生核心转储（coredump）时生成的核心文件（corefile）的命名模式和路径。</p><h1 id="示例1-段错误"><a href="#示例1-段错误" class="headerlink" title="示例1-段错误"></a>示例1-段错误</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> *p)</span></span><br><span class="hljs-function"></span>&#123;<br>    *p = <span class="hljs-number">0</span>;<br>&#125;<br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">func</span>(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写文件并编译运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gcc -g -o app main.c<br>$ ./app<br>Segmentation fault (core dumped)<br></code></pre></td></tr></table></figure><p>文件目录中产生coredump文件：core-app-20132-1733721582，使用coredump文件定位错误信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gdb ./app core-app-20132-1733721582<br>GNU gdb (Ubuntu 12.1-0ubuntu1~22.04.2) 12.1<br>Copyright (C) 2022 Free Software Foundation, Inc.<br>License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;<br>This is free software: you are free to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.<br>Type <span class="hljs-string">&quot;show copying&quot;</span> and <span class="hljs-string">&quot;show warranty&quot;</span> <span class="hljs-keyword">for</span> details.<br>This GDB was configured as <span class="hljs-string">&quot;x86_64-linux-gnu&quot;</span>.<br>Type <span class="hljs-string">&quot;show configuration&quot;</span> <span class="hljs-keyword">for</span> configuration details.<br>For bug reporting instructions, please see:<br>&lt;https://www.gnu.org/software/gdb/bugs/&gt;.<br>Find the GDB manual and other documentation resources online at:<br>    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.<br><br>For <span class="hljs-built_in">help</span>, <span class="hljs-built_in">type</span> <span class="hljs-string">&quot;help&quot;</span>.<br>Type <span class="hljs-string">&quot;apropos word&quot;</span> to search <span class="hljs-keyword">for</span> commands related to <span class="hljs-string">&quot;word&quot;</span>...<br>Reading symbols from ./app...<br>[New LWP 20132]<br>[Thread debugging using libthread_db enabled]<br>Using host libthread_db library <span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.<br>--Type &lt;RET&gt; <span class="hljs-keyword">for</span> more, q to quit, c to <span class="hljs-built_in">continue</span> without paging--c<br>Core was generated by `./app<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">Program terminated with signal SIGSEGV, Segmentation fault.</span><br><span class="hljs-string">#0  0x000055902ca68139 in func (p=0x0) at main.c:5</span><br><span class="hljs-string">5           *p = 0;</span><br></code></pre></td></tr></table></figure><p>可以看到程序是由于 <code>SIGSEGV</code>信号产生的coredump文件。接着查看coredump时的堆栈：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ bt<br>or<br>$ <span class="hljs-built_in">where</span><br>(gdb) <span class="hljs-built_in">where</span><br><span class="hljs-comment">#0  0x000055902ca68139 in func (p=0x0) at main.c:5</span><br><span class="hljs-comment">#1  0x000055902ca68154 in main () at main.c:10</span><br></code></pre></td></tr></table></figure><p>通过 <code>#0  0x000055902ca68139 in func (p=0x0) at main.c:5</code>可以定位到是由于 <code>func (p=0x0)</code>导致的错误信号。</p><p>接着可以使用 <code>disassemble</code>打开该帧函数的反汇编代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) disassemble<br>Dump of assembler code <span class="hljs-keyword">for</span> <span class="hljs-keyword">function</span> func:<br>   0x000055902ca68129 &lt;+0&gt;:     endbr64 <br>   0x000055902ca6812d &lt;+4&gt;:     push   %rbp<br>   0x000055902ca6812e &lt;+5&gt;:     mov    %rsp,%rbp<br>   0x000055902ca68131 &lt;+8&gt;:     mov    %rdi,-0x8(%rbp)<br>   0x000055902ca68135 &lt;+12&gt;:    mov    -0x8(%rbp),%rax<br>=&gt; 0x000055902ca68139 &lt;+16&gt;:    movl   <span class="hljs-variable">$0x0</span>,(%rax)<br>   0x000055902ca6813f &lt;+22&gt;:    nop<br>   0x000055902ca68140 &lt;+23&gt;:    pop    %rbp<br>   0x000055902ca68141 &lt;+24&gt;:    ret  <br>End of assembler dump.<br></code></pre></td></tr></table></figure><p>如上箭头位置表示coredump时该函数调用所在位置。</p><p>接着使用 <code>info registers</code> 查看当前寄存器的状态，特别是 <code>rdi</code> 寄存器，因为它包含了传递给 <code>func</code> 函数的第一个参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) info registers <br>rax            0x0                 0<br>rbx            0x0                 0<br>rcx            0x55902ca6adf8      94077712772600<br>rdx            0x7fff37b64018      140734128078872<br>rsi            0x7fff37b64008      140734128078856<br>rdi            0x0                 0<br>rbp            0x7fff37b63ee0      0x7fff37b63ee0<br>rsp            0x7fff37b63ee0      0x7fff37b63ee0<br>r8             0x7fe5c2aadf10      140624790216464<br>r9             0x7fe5c2acb040      140624790335552<br>r10            0x7fe5c2ac5908      140624790313224<br>r11            0x7fe5c2ae0660      140624790423136<br>r12            0x7fff37b64008      140734128078856<br>r13            0x55902ca68142      94077712761154<br>r14            0x55902ca6adf8      94077712772600<br>r15            0x7fe5c2aff040      140624790548544<br>rip            0x55902ca68139      0x55902ca68139 &lt;func+16&gt;<br>eflags         0x10246             [ PF ZF IF RF ]<br>cs             0x33                51<br>--Type &lt;RET&gt; <span class="hljs-keyword">for</span> more, q to quit, c to <span class="hljs-built_in">continue</span> without paging--<br></code></pre></td></tr></table></figure><p>可以看到 <code>rdi</code>寄存器指向了一个0地址。接着使用 <code>x/1x $rax</code>查看 <code>rax</code>寄存器指向的内存地址的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) x/1x <span class="hljs-variable">$rax</span><br>0x0:    Cannot access memory at address 0x0<br></code></pre></td></tr></table></figure><p>由于 <code>rax</code> 寄存器存储的是 <code>NULL</code>，这将显示一个不可访问的内存区域。</p><h1 id="寻找this指针和虚指针"><a href="#寻找this指针和虚指针" class="headerlink" title="寻找this指针和虚指针"></a>寻找this指针和虚指针</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdlib.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">base</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *basePStr;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dumpTest</span> : <span class="hljs-keyword">public</span> base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *childPStr;<br>&#125;;<br>base::<span class="hljs-built_in">base</span>()<br>&#123;<br>    basePStr = <span class="hljs-string">&quot;test_info&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">base::test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;basePStr&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dumpTest::test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;dumpTest&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">delete</span> childPStr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    dumpTest dump;<br>    dump.<span class="hljs-built_in">test</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码实现了一个简单的基类和子类，在main函数里定义了一个子类的实例化对象，并调用他的虚函数方法test，由于test里面没有初始化指针childPStr而直接删除，会造成coredump。</p><p>首先编译并运行代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ g++ -g -o app main.cpp<br>$ ./app<br>dumpTest<br>free(): invalid pointer<br>Aborted (core dumped)<br></code></pre></td></tr></table></figure><p>目录列表里产生了coredump文件：core-app-34711-1733723593</p><p>接着使用gdb打开coredump文件，同时使用 <code>bt</code>打开coredump堆栈信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ gdb ./app core-app-34711-1733723593<br>GNU gdb (Ubuntu 12.1-0ubuntu1~22.04.2) 12.1<br>Copyright (C) 2022 Free Software Foundation, Inc.<br>License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;<br>This is free software: you are free to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.<br>Type <span class="hljs-string">&quot;show copying&quot;</span> and <span class="hljs-string">&quot;show warranty&quot;</span> <span class="hljs-keyword">for</span> details.<br>This GDB was configured as <span class="hljs-string">&quot;x86_64-linux-gnu&quot;</span>.<br>Type <span class="hljs-string">&quot;show configuration&quot;</span> <span class="hljs-keyword">for</span> configuration details.<br>For bug reporting instructions, please see:<br>&lt;https://www.gnu.org/software/gdb/bugs/&gt;.<br>Find the GDB manual and other documentation resources online at:<br>    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.<br><br>For <span class="hljs-built_in">help</span>, <span class="hljs-built_in">type</span> <span class="hljs-string">&quot;help&quot;</span>.<br>Type <span class="hljs-string">&quot;apropos word&quot;</span> to search <span class="hljs-keyword">for</span> commands related to <span class="hljs-string">&quot;word&quot;</span>...<br>Reading symbols from ./app...<br>[New LWP 34711]<br>[Thread debugging using libthread_db enabled]<br>Using host libthread_db library <span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.<br>Core was generated by `./app<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">Program terminated with signal SIGABRT, Aborted.</span><br><span class="hljs-string">#0  __pthread_kill_implementation (no_tid=0, signo=6, threadid=139759220007872)</span><br><span class="hljs-string">    at ./nptl/pthread_kill.c:44</span><br><span class="hljs-string">44      ./nptl/pthread_kill.c: No such file or directory.</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">(gdb) bt</span><br><span class="hljs-string">#0  __pthread_kill_implementation (no_tid=0, signo=6, threadid=139759220007872)</span><br><span class="hljs-string">    at ./nptl/pthread_kill.c:44</span><br><span class="hljs-string">#1  __pthread_kill_internal (signo=6, threadid=139759220007872) at ./nptl/pthread_kill.c:78</span><br><span class="hljs-string">#2  __GI___pthread_kill (threadid=139759220007872, signo=signo@entry=6)</span><br><span class="hljs-string">    at ./nptl/pthread_kill.c:89</span><br><span class="hljs-string">#3  0x00007f1c3abe4476 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26</span><br><span class="hljs-string">#4  0x00007f1c3abca7f3 in __GI_abort () at ./stdlib/abort.c:79</span><br><span class="hljs-string">#5  0x00007f1c3ac2b676 in __libc_message (action=action@entry=do_abort, </span><br><span class="hljs-string">    fmt=fmt@entry=0x7f1c3ad7db77 &quot;%s\n&quot;) at ../sysdeps/posix/libc_fatal.c:155</span><br><span class="hljs-string">#6  0x00007f1c3ac42cfc in malloc_printerr (</span><br><span class="hljs-string">    str=str@entry=0x7f1c3ad7b744 &quot;free(): invalid pointer&quot;) at ./malloc/malloc.c:5664</span><br><span class="hljs-string">#7  0x00007f1c3ac44a44 in _int_free (av=&lt;optimized out&gt;, p=&lt;optimized out&gt;, have_lock=0)</span><br><span class="hljs-string">    at ./malloc/malloc.c:4439</span><br><span class="hljs-string">#8  0x00007f1c3ac47453 in __GI___libc_free (mem=&lt;optimized out&gt;) at ./malloc/malloc.c:3391</span><br><span class="hljs-string">#9  0x0000559355e2f2ab in dumpTest::test (this=0x7ffd2b1ddd50) at main.cpp:31</span><br><span class="hljs-string">#10 0x0000559355e2f2e1 in main () at main.cpp:37</span><br></code></pre></td></tr></table></figure><p>从堆栈信息可以看到，除了最后两帧，其他的都是libc的代码。</p><p>进入到第9帧，并查看堆栈寄存器信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) info f<br>Stack level 9, frame at 0x7fff871b7060:<br> rip = 0x563d0c5df2ab <span class="hljs-keyword">in</span> dumpTest::<span class="hljs-built_in">test</span> (main.cpp:32); saved rip = 0x563d0c5df2e1<br> called by frame at 0x7fff871b7090, <span class="hljs-built_in">caller</span> of frame at 0x7fff871b7040<br> <span class="hljs-built_in">source</span> language c++.<br> Arglist at 0x7fff871b7050, args: this=0x7fff871b7060<br> Locals at 0x7fff871b7050, Previous frame<span class="hljs-string">&#x27;s sp is 0x7fff871b7060</span><br><span class="hljs-string"> Saved registers:</span><br><span class="hljs-string">  rbp at 0x7fff871b7050, rip at 0x7fff871b7058</span><br></code></pre></td></tr></table></figure><p>通过 <code>this=0x7fff871b7060</code>可知，this指针指向0x7fff871b7060。</p><p>在 C++ 中，对象的内存布局通常如下：</p><ol><li>第一个位置是指向虚函数表（vtable）的指针，如果类有虚函数的话。</li><li>紧接着是对象的实际数据成员。</li></ol><p>虚函数表指针通常存储在对象内存的开始位置，由于this指针指向对象的起始位置，所以可以通过解引用this指针获取虚函数表的地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p *(void**)0x7fff871b7060<br><span class="hljs-variable">$2</span> = (void *) 0x563d0c5e1d38 &lt;vtable <span class="hljs-keyword">for</span> dumpTest+16&gt;<br>(gdb) x 0x563d0c5e1d38<br>0x563d0c5e1d38 &lt;_ZTV8dumpTest+16&gt;:      0x0c5df256<br>(gdb) shell <span class="hljs-built_in">echo</span> _ZTV8dumpTest | c++filt<br>vtable <span class="hljs-keyword">for</span> dumpTest<br></code></pre></td></tr></table></figure><p>打印this指针存储的地址，可以看到this指针指向的地址为 <code>0x563d0c5e1d38</code>该地址为 <code>&lt;vtable for dumpTest+16&gt;</code>即虚函数表偏移16个字节的位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) x 0x563d0c5e1d38-16<br>0x563d0c5e1d28 &lt;_ZTV8dumpTest&gt;: 0x00000000<br>(gdb) x *(void**)0x563d0c5e1d38<br>0x563d0c5df256 &lt;_ZN8dumpTest4testEv&gt;:   0xfa1e0ff3<br>(gdb) shell <span class="hljs-built_in">echo</span> _ZN8dumpTest4testEv | c++filt<br>dumpTest::<span class="hljs-built_in">test</span>()<br>(gdb) x *(void**)0x563d0c5e1d38-8<br>0x563d0c5df24e &lt;_ZN4base4testEv+56&gt;:    0xfffffe7e<br>(gdb) shell <span class="hljs-built_in">echo</span> _ZN4base4testEv | c++filt<br>base::<span class="hljs-built_in">test</span>()<br></code></pre></td></tr></table></figure><p>可以看到减去this指针指向的地址减去16字节的偏移量，正好就是虚函数表的地址 <code>0x563d0c5e1d28</code>，该内存单元存储的地址为 <code>0x00000000</code>。</p><p>当使用 <code>x *(void**)0x563d0c5e1d38</code>查看该内存地址处的内容时，可以看到存储的内容就是 <code>dumpTest::test()</code>；其往前偏移8个字节正好就是 <code>base::test()</code>，这也正好说明了，在继承关系中，基类的虚函数在子类虚函数的前面。</p><p>在实际问题中，C++程序的很多coredump问题都是和指针相关的，很多segmentfault都是由于指针被误删或者访问空指针、或者越界等造成的，而这些都一般意味着正在访问的对象的this指针可能已经被破坏了，此时，我们通过去寻找函数对应的对象的this指针、虚指针能验证我们的推测。之后再结合代码寻找问题所在。</p><h2 id="疑惑点解答"><a href="#疑惑点解答" class="headerlink" title="疑惑点解答"></a>疑惑点解答</h2><p><code>(void**)0x563d0c5e1d38</code>将地址 <code>0x563d0c5e1d38</code> 视为一个指向 <code>void*</code> 指针的指针（即 <code>void**</code>）,也就是说 <code>(void**)0x563d0c5e1d38</code>是一个指向void<em>类型的指针。</em></p><p><code>*(void**)0x563d0c5e1d38</code>是对 <code>void**</code>类型指针的解引用操作，得到的是一个 <code>void*</code>类型的值。这个值可以是一个函数地址，一个对象的地址，或者是虚函数表指针。</p><h1 id="GDB查看core进程的所有线程堆栈"><a href="#GDB查看core进程的所有线程堆栈" class="headerlink" title="GDB查看core进程的所有线程堆栈"></a>GDB查看core进程的所有线程堆栈</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM_THREADS 5</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">say_hello</span><span class="hljs-params">( <span class="hljs-type">void</span> *args )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>        cout&lt;&lt;<span class="hljs-string">&quot;hello...&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span> == count)<br>        &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">char</span> *pStr = <span class="hljs-string">&quot;hello&quot;</span>;<br>            <span class="hljs-keyword">delete</span> pStr;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">pthread_t</span> tids[NUM_THREADS];<br>    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_THREADS; ++i )<br>    &#123;<br>        count = i<span class="hljs-number">+1</span>;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pthread_create</span>( &amp;tids[i], <span class="hljs-literal">NULL</span>, say_hello, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span>( ret != <span class="hljs-number">0</span> )<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;pthread_create error:error_code=&quot;</span> &lt;&lt; ret &lt;&lt; endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NUM_THREADS; ++i )<br>    &#123;<br>        count = i<span class="hljs-number">+1</span>;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pthread_join</span>(tids[i], <span class="hljs-literal">NULL</span>); <br>    &#125;<br>    <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于代码中在count等于5的时候会delete一个未初始化的指针，所以会生成coredump文件。</p><p>首先使用GDB打开coredump文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb ./app core-app-178100-1733743589<br>GNU gdb (Ubuntu 12.1-0ubuntu1~22.04.2) 12.1<br>Copyright (C) 2022 Free Software Foundation, Inc.<br>License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;<br>This is free software: you are free to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.<br>Type <span class="hljs-string">&quot;show copying&quot;</span> and <span class="hljs-string">&quot;show warranty&quot;</span> <span class="hljs-keyword">for</span> details.<br>This GDB was configured as <span class="hljs-string">&quot;x86_64-linux-gnu&quot;</span>.<br>Type <span class="hljs-string">&quot;show configuration&quot;</span> <span class="hljs-keyword">for</span> configuration details.<br>For bug reporting instructions, please see:<br>&lt;https://www.gnu.org/software/gdb/bugs/&gt;.<br>Find the GDB manual and other documentation resources online at:<br>    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.<br><br>For <span class="hljs-built_in">help</span>, <span class="hljs-built_in">type</span> <span class="hljs-string">&quot;help&quot;</span>.<br>Type <span class="hljs-string">&quot;apropos word&quot;</span> to search <span class="hljs-keyword">for</span> commands related to <span class="hljs-string">&quot;word&quot;</span>...<br>Reading symbols from ./app...<br>[New LWP 178101]<br>[New LWP 178102]<br>[New LWP 178103]<br>[New LWP 178100]<br>[New LWP 178104]<br>[New LWP 178105]<br>[Thread debugging using libthread_db enabled]<br>Using host libthread_db library <span class="hljs-string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.<br>--Type &lt;RET&gt; <span class="hljs-keyword">for</span> more, q to quit, c to <span class="hljs-built_in">continue</span> without paging--c<br>Core was generated by `./app<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">Program terminated with signal SIGSEGV, Segmentation fault.</span><br><span class="hljs-string">#0  0x00007f7001fb4449 in arena_for_chunk (ptr=0x55f147223001 &lt;_IO_stdin_used+1&gt;) at ./malloc/arena.c:156</span><br><span class="hljs-string">156     ./malloc/arena.c: No such file or directory.</span><br><span class="hljs-string">[Current thread is 1 (Thread 0x7f7001e03640 (LWP 178101))]</span><br></code></pre></td></tr></table></figure><p>可以看到5个线程的LWP信息。</p><p>接着使用 <code>info threads</code>查看所有线程正在运行的指令信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) info threads<br>  Id   Target Id                          Frame <br>* 1    Thread 0x7f7001e03640 (LWP 178101) 0x00007f7001fb4449 <span class="hljs-keyword">in</span> arena_for_chunk (<br>    ptr=0x55f147223001 &lt;_IO_stdin_used+1&gt;) at ./malloc/arena.c:156<br>  2    Thread 0x7f7001602640 (LWP 178102) __GI___lll_lock_wake_private (<br>    futex=0x7f700212ba70 &lt;_IO_stdfile_1_lock&gt;) at ./nptl/lowlevellock.c:57<br>  3    Thread 0x7f7000e01640 (LWP 178103) futex_wait (private=0, expected=2, <br>    futex_word=0x7f700212ba70 &lt;_IO_stdfile_1_lock&gt;) at ../sysdeps/nptl/futex-internal.h:146<br>  4    Thread 0x7f7001e073c0 (LWP 178100) __futex_abstimed_wait_common64 (private=128, <br>    cancel=<span class="hljs-literal">true</span>, abstime=0x0, op=265, expected=178101, futex_word=0x7f7001e03910)<br>    at ./nptl/futex-internal.c:57<br>  5    Thread 0x7f7000600640 (LWP 178104) 0x00007f700202da7b <span class="hljs-keyword">in</span> munmap ()<br>    at ../sysdeps/unix/syscall-template.S:117<br>  6    Thread 0x7f6fffdff640 (LWP 178105) futex_wait (private=0, expected=2, <br>    futex_word=0x7f700212ba70 &lt;_IO_stdfile_1_lock&gt;) at ../sysdeps/nptl/futex-internal.h:146<br></code></pre></td></tr></table></figure><p>接着使用 <code>thread apply all bt</code>打开所有线程的堆栈信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) thread apply all bt<br><br>Thread 6 (Thread 0x7f6fffdff640 (LWP 178105)):<br><span class="hljs-comment">#0  futex_wait (private=0, expected=2, futex_word=0x7f700212ba70 &lt;_IO_stdfile_1_lock&gt;) at ../sysdeps/nptl/futex-internal.h:146</span><br><span class="hljs-comment">#1  __GI___lll_lock_wait_private (futex=0x7f700212ba70 &lt;_IO_stdfile_1_lock&gt;) at ./nptl/lowlevellock.c:34</span><br><span class="hljs-comment">#2  0x00007f7001f8f095 in __GI__IO_fwrite (buf=0x55f147223008, size=1, count=8, fp=0x7f700212a780 &lt;_IO_2_1_stdout_&gt;) at ./libio/iofwrite.c:37</span><br><span class="hljs-comment">#3  0x00007f7002274b65 in std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::__ostream_insert&lt;char, std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*, long) () from /lib/x86_64-linux-gnu/libstdc++.so.6</span><br><span class="hljs-comment">#4  0x00007f7002274ebb in std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*) () from /lib/x86_64-linux-gnu/libstdc++.so.6</span><br><span class="hljs-comment">#5  0x000055f14722229c in say_hello (args=0x0) at main.cpp:13</span><br><span class="hljs-comment">#6  0x00007f7001fa3ac3 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span><br><span class="hljs-comment">#7  0x00007f7002035850 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span><br><br>Thread 5 (Thread 0x7f7000600640 (LWP 178104)):<br><span class="hljs-comment">#0  0x00007f700202da7b in munmap () at ../sysdeps/unix/syscall-template.S:117</span><br><span class="hljs-comment">#1  0x00007f7001fb0cc5 in alloc_new_heap (size=135168, size@entry=2904, top_pad=top_pad@entry=131072, pagesize=pagesize@entry=4096, mmap_flags=mmap_flags@entry=16384) at ./malloc/arena.c:528</span><br><span class="hljs-comment">#2  0x00007f7001fb116c in new_heap (top_pad=131072, size=2904) at ./malloc/arena.c:576</span><br>--Type &lt;RET&gt; <span class="hljs-keyword">for</span> more, q to quit, c to <span class="hljs-built_in">continue</span> without paging--c<br><span class="hljs-comment">#3  _int_new_arena (size=640) at ./malloc/arena.c:744</span><br><span class="hljs-comment">#4  arena_get2 (size=size@entry=640, avoid_arena=avoid_arena@entry=0x0) at ./malloc/arena.c:963</span><br><span class="hljs-comment">#5  0x00007f7001fb3a41 in arena_get2 (avoid_arena=0x0, size=640) at ./malloc/arena.c:931</span><br><span class="hljs-comment">#6  tcache_init () at ./malloc/malloc.c:3244</span><br><span class="hljs-comment">#7  0x00007f7001fb44cf in tcache_init () at ./malloc/malloc.c:3241</span><br><span class="hljs-comment">#8  __GI___libc_free (mem=0x55f147223011) at ./malloc/malloc.c:3385</span><br><span class="hljs-comment">#9  0x000055f1472222da in say_hello (args=0x0) at main.cpp:17</span><br><span class="hljs-comment">#10 0x00007f7001fa3ac3 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span><br><span class="hljs-comment">#11 0x00007f7002035850 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span><br><br>Thread 4 (Thread 0x7f7001e073c0 (LWP 178100)):<br><span class="hljs-comment">#0  __futex_abstimed_wait_common64 (private=128, cancel=true, abstime=0x0, op=265, expected=178101, futex_word=0x7f7001e03910) at ./nptl/futex-internal.c:57</span><br><span class="hljs-comment">#1  __futex_abstimed_wait_common (cancel=true, private=128, abstime=0x0, clockid=0, expected=178101, futex_word=0x7f7001e03910) at ./nptl/futex-internal.c:87</span><br><span class="hljs-comment">#2  __GI___futex_abstimed_wait_cancelable64 (futex_word=futex_word@entry=0x7f7001e03910, expected=178101, clockid=clockid@entry=0, abstime=abstime@entry=0x0, private=private@entry=128) at ./nptl/futex-internal.c:139</span><br><span class="hljs-comment">#3  0x00007f7001fa5624 in __pthread_clockjoin_ex (threadid=140119044535872, thread_return=0x0, clockid=0, abstime=0x0, block=&lt;optimized out&gt;) at ./nptl/pthread_join_common.c:105</span><br><span class="hljs-comment">#4  0x000055f1472223b3 in main () at main.cpp:38</span><br><br>Thread 3 (Thread 0x7f7000e01640 (LWP 178103)):<br><span class="hljs-comment">#0  futex_wait (private=0, expected=2, futex_word=0x7f700212ba70 &lt;_IO_stdfile_1_lock&gt;) at ../sysdeps/nptl/futex-internal.h:146</span><br><span class="hljs-comment">#1  __GI___lll_lock_wait_private (futex=0x7f700212ba70 &lt;_IO_stdfile_1_lock&gt;) at ./nptl/lowlevellock.c:34</span><br><span class="hljs-comment">#2  0x00007f7001f96f05 in __GI__IO_putc (c=10, fp=0x7f700212a780 &lt;_IO_2_1_stdout_&gt;) at ./libio/putc.c:30</span><br><span class="hljs-comment">#3  0x00007f700227426a in std::ostream::put(char) () from /lib/x86_64-linux-gnu/libstdc++.so.6</span><br><span class="hljs-comment">#4  0x00007f7002274813 in std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::endl&lt;char, std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;) () from /lib/x86_64-linux-gnu/libstdc++.so.6</span><br><span class="hljs-comment">#5  0x000055f1472222ae in say_hello (args=0x0) at main.cpp:13</span><br><span class="hljs-comment">#6  0x00007f7001fa3ac3 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span><br><span class="hljs-comment">#7  0x00007f7002035850 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span><br><br>Thread 2 (Thread 0x7f7001602640 (LWP 178102)):<br><span class="hljs-comment">#0  __GI___lll_lock_wake_private (futex=0x7f700212ba70 &lt;_IO_stdfile_1_lock&gt;) at ./nptl/lowlevellock.c:57</span><br><span class="hljs-comment">#1  0x00007f7001f8f06d in _IO_acquire_lock_fct (p=&lt;synthetic pointer&gt;) at ./libio/libioP.h:884</span><br><span class="hljs-comment">#2  __GI__IO_fwrite (buf=&lt;optimized out&gt;, size=1, count=8, fp=0x7f700212a780 &lt;_IO_2_1_stdout_&gt;) at ./libio/iofwrite.c:37</span><br><span class="hljs-comment">#3  0x00007f7002274b65 in std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::__ostream_insert&lt;char, std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*, long) () from /lib/x86_64-linux-gnu/libstdc++.so.6</span><br><span class="hljs-comment">#4  0x00007f7002274ebb in std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::operator&lt;&lt; &lt;std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*) () from /lib/x86_64-linux-gnu/libstdc++.so.6</span><br><span class="hljs-comment">#5  0x000055f14722229c in say_hello (args=0x0) at main.cpp:13</span><br><span class="hljs-comment">#6  0x00007f7001fa3ac3 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span><br><span class="hljs-comment">#7  0x00007f7002035850 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span><br><br>Thread 1 (Thread 0x7f7001e03640 (LWP 178101)):<br><span class="hljs-comment">#0  0x00007f7001fb4449 in arena_for_chunk (ptr=0x55f147223001 &lt;_IO_stdin_used+1&gt;) at ./malloc/arena.c:156</span><br><span class="hljs-comment">#1  arena_for_chunk (ptr=0x55f147223001 &lt;_IO_stdin_used+1&gt;) at ./malloc/arena.c:160</span><br><span class="hljs-comment">#2  __GI___libc_free (mem=&lt;optimized out&gt;) at ./malloc/malloc.c:3390</span><br><span class="hljs-comment">#3  0x000055f1472222da in say_hello (args=0x0) at main.cpp:17</span><br><span class="hljs-comment">#4  0x00007f7001fa3ac3 in start_thread (arg=&lt;optimized out&gt;) at ./nptl/pthread_create.c:442</span><br><span class="hljs-comment">#5  0x00007f7002035850 in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:81</span><br></code></pre></td></tr></table></figure><p>查看指定线程堆栈信息 <code>thread apply 4 bt</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) thread apply 4 bt<br><br>Thread 4 (Thread 0x7f7001e073c0 (LWP 178100)):<br><span class="hljs-comment">#0  __futex_abstimed_wait_common64 (private=128, cancel=true, abstime=0x0, op=265, expected=178101, futex_word=0x7f7001e03910) at ./nptl/futex-internal.c:57</span><br><span class="hljs-comment">#1  __futex_abstimed_wait_common (cancel=true, private=128, abstime=0x0, clockid=0, expected=178101, futex_word=0x7f7001e03910) at ./nptl/futex-internal.c:87</span><br><span class="hljs-comment">#2  __GI___futex_abstimed_wait_cancelable64 (futex_word=futex_word@entry=0x7f7001e03910, expected=178101, clockid=clockid@entry=0, abstime=abstime@entry=0x0, private=private@entry=128) at ./nptl/futex-internal.c:139</span><br><span class="hljs-comment">#3  0x00007f7001fa5624 in __pthread_clockjoin_ex (threadid=140119044535872, thread_return=0x0, clockid=0, abstime=0x0, block=&lt;optimized out&gt;) at ./nptl/pthread_join_common.c:105</span><br><span class="hljs-comment">#4  0x000055f1472223b3 in main () at main.cpp:38</span><br></code></pre></td></tr></table></figure><p>进入指定线程栈空间：</p><ol><li>thread n</li><li>bt</li><li>i f</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) thread 4<br>[Switching to thread 4 (Thread 0x7f7001e073c0 (LWP 178100))]<br><span class="hljs-comment">#0  __futex_abstimed_wait_common64 (private=128, cancel=true, abstime=0x0, op=265, </span><br>    expected=178101, futex_word=0x7f7001e03910) at ./nptl/futex-internal.c:57<br>57      ./nptl/futex-internal.c: No such file or directory.<br><br><br>(gdb) bt<br><span class="hljs-comment">#0  __futex_abstimed_wait_common64 (private=128, cancel=true, abstime=0x0, op=265, </span><br>    expected=178101, futex_word=0x7f7001e03910) at ./nptl/futex-internal.c:57<br><span class="hljs-comment">#1  __futex_abstimed_wait_common (cancel=true, private=128, abstime=0x0, clockid=0, </span><br>    expected=178101, futex_word=0x7f7001e03910) at ./nptl/futex-internal.c:87<br><span class="hljs-comment">#2  __GI___futex_abstimed_wait_cancelable64 (futex_word=futex_word@entry=0x7f7001e03910, </span><br>    expected=178101, clockid=clockid@entry=0, abstime=abstime@entry=0x0, <br>    private=private@entry=128) at ./nptl/futex-internal.c:139<br><span class="hljs-comment">#3  0x00007f7001fa5624 in __pthread_clockjoin_ex (threadid=140119044535872, thread_return=0x0, </span><br>    clockid=0, abstime=0x0, block=&lt;optimized out&gt;) at ./nptl/pthread_join_common.c:105<br><span class="hljs-comment">#4  0x000055f1472223b3 in main () at main.cpp:38</span><br><br><br>(gdb) i f<br>Stack level 0, frame at 0x7ffebda6cb90:<br> rip = 0x7f7001fa0117 <span class="hljs-keyword">in</span> __futex_abstimed_wait_common64 (./nptl/futex-internal.c:57); <br>    saved rip = 0x7f7001fa5624<br> inlined into frame 1<br> <span class="hljs-built_in">source</span> language c.<br> Arglist at unknown address.<br> Locals at unknown address, Previous frame<span class="hljs-string">&#x27;s sp in rsp</span><br></code></pre></td></tr></table></figure><p>如上即可跳转到指定的线程中，并查看所在线程正在运行的堆栈信息和寄存器信息。</p><h1 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h1><p><a href="https://cloud.tencent.com/developer/article/1860631">coredump文件是如何生成的</a><br><a href="https://www.cnblogs.com/flyinggod/p/13415862.html">Linux生成coredump的方法及设置</a><br><a href="https://www.cnblogs.com/lidabo/p/14311900.html">gdb调试coredump</a><br><a href="https://blog.csdn.net/sunxiaopengsun/article/details/72974548">gdb调试示例-强烈推荐</a><br><a href="https://developers.redhat.com/articles/2022/01/10/gdb-developers-gnu-debugger-tutorial-part-2-all-about-debuginfo#">debuginfo</a>【这篇文章有很多不明白的名词，涉及到编译器和DWARF调试信息】<br><a href="https://imageslr.com/2023/gdb.html#coredump">GDB 入门笔记</a>【这是一篇非常全面的GDB入门笔记】<br><a href="https://sourceware.org/gdb/documentation/">GDB Documentation</a>【GDB官方文档】</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gdb</title>
    <link href="/2025/02/22/MissingSemester/gdb/"/>
    <url>/2025/02/22/MissingSemester/gdb/</url>
    
    <content type="html"><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>编译程序的时候：<br>1.打开编译选项（-g）<br>2.关掉编译器优化选项（-O0）<br>3.打开所有的warning（-Wall）</p><!-- more -# g++编译重要参数- -g 编译带调试信息的可执行文件，选项告诉GCC产生能被GNU调试器——gdb使用的调试信息。- -O[n] 优化源代码，一般使用-O2。省略掉代码中未使用的变量，将表达式用结果值代替等等。- -l 和 -L 分别表示指定库文件，指定库路径。库名或者库路径要紧跟在这两个[option]后，中间无空格。- -I 指定头文件搜索目录- -Wall 打印警告信息- -w 关闭警告信息- -std=c++11 设置编译标准- -o 指定输出文件名- -D 定义宏# 概述- help [comend]     查看命令帮助- run(r)            重新开始运行文件- start        单步运行程序- list(l)             查看源代码，list-n从第n行开始查看，list [functionname]查看具体函数- set          设置变量值- next(n)          单步调试，逐过程- step(s)           单步调试，逐语句- backtrace(bt)        查看函数调用的栈帧和层级关系- frame(f)切换函数栈帧- info(i)           查看函数内部局部变量数值- finish            结束当前函数，返回函数调用点- continus(c)    继续运行- print(p)  打印值或地址# 启动和退出gdb## 启动gdb<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 语法：gdb 可执行程序</span><br>$ gdb main<br></code></pre></td></tr></table></figure><h2 id="gdb中命令行传参（set-args）"><a href="#gdb中命令行传参（set-args）" class="headerlink" title="gdb中命令行传参（set args）"></a>gdb中命令行传参（set args）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动gdb之后</span><br><span class="hljs-comment"># 语法：set args 参数1 参数2 ...</span><br><span class="hljs-comment"># 通过gdb给应用程序设置命令行参数</span><br>(gdb) <span class="hljs-built_in">set</span> args 1 2 3<br><br><span class="hljs-comment"># 查看设置的命令行参数</span><br>(gdb) show args<br></code></pre></td></tr></table></figure><h2 id="gdb中启动程序（run-start）"><a href="#gdb中启动程序（run-start）" class="headerlink" title="gdb中启动程序（run&#x2F;start）"></a>gdb中启动程序（run&#x2F;start）</h2><ul><li>run（r）：如果程序设置了断点，会停在断点的位置，如果没有设置断点，程序执行到结束。</li><li>start：启动程序，程序运行到main函数的第一行。</li></ul><p>ps.<code>run</code>和 <code>start</code>在启动gdb之后只能执行其中一个，并只能执行一次。如果遇到断点需要继续执行，输入命令 <code>continue(c)</code></p><h2 id="退出gdb（quit）"><a href="#退出gdb（quit）" class="headerlink" title="退出gdb（quit）"></a>退出gdb（quit）</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lisp">(<span class="hljs-name">gdb</span>) quit<br>or<br>(<span class="hljs-name">gdb</span>) q<br></code></pre></td></tr></table></figure><h1 id="查看代码（list）"><a href="#查看代码（list）" class="headerlink" title="查看代码（list）"></a>查看代码（list）</h1><h2 id="在当前文件下查看代码"><a href="#在当前文件下查看代码" class="headerlink" title="在当前文件下查看代码"></a>在当前文件下查看代码</h2><p>通过list查看代码，每次只显示10行，如果需要继续查看后面的代码，直接按回车（即再次执行list指令）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 从第一行开始显示</span><br>(gdb) list<br><br><span class="hljs-comment"># 显示第n行的上下文</span><br>(gdb) list n<br><br><span class="hljs-comment"># 显示某个函数的上下文</span><br>(gdb) list &lt;<span class="hljs-keyword">function</span>-name&gt;<br></code></pre></td></tr></table></figure><h2 id="显示其他文件下的代码"><a href="#显示其他文件下的代码" class="headerlink" title="显示其他文件下的代码"></a>显示其他文件下的代码</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-comment"># 切换到指定的文件，并列出第n行对应的上下文</span><br>(gdb) list &lt;filename&gt;<span class="hljs-symbol">:n</span><br><br><span class="hljs-comment"># 切换到指定的文件，并列出函数的上下文</span><br>(gdb) list &lt;filename&gt;<span class="hljs-symbol">:&lt;function-name&gt;</span><br></code></pre></td></tr></table></figure><h2 id="设置显示的行数"><a href="#设置显示的行数" class="headerlink" title="设置显示的行数"></a>设置显示的行数</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 设置每次显示的行数</span><br>(gdb) <span class="hljs-built_in">set</span> listsize 行数<br><br><span class="hljs-comment"># 查看当前list一次能显示的行数</span><br>(gdb) show listsize<br></code></pre></td></tr></table></figure><h1 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h1><h2 id="设置断点（break）"><a href="#设置断点（break）" class="headerlink" title="设置断点（break）"></a>设置断点（break）</h2><ul><li>常规断点</li><li>条件断点</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-comment"># 在当前文件下设置断点</span><br>(gdb) b &lt;n&gt;<br>(gdb) b &lt;function-name&gt;<br><br><span class="hljs-comment"># 在其他文件上设置断点（比如当前在PC指针在main.c文件下，但是想在sub.c中设置断点）</span><br>(gdb) b &lt;filename&gt;<span class="hljs-symbol">:n</span><br>(gdb) b &lt;filename&gt;<span class="hljs-symbol">:&lt;function-name&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-comment"># 条件断点：只有满足某个条件后程序才会停在这个断点的位置上</span><br>(gdb) b <span class="hljs-variable">&lt;n&gt;</span> if 变量名==某个值<br></code></pre></td></tr></table></figure><h2 id="查看断点（info）"><a href="#查看断点（info）" class="headerlink" title="查看断点（info）"></a>查看断点（info）</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">(gdb) info <span class="hljs-keyword">b</span><br><span class="hljs-keyword"></span>Num     Type           <span class="hljs-keyword">Disp </span>Enb <span class="hljs-keyword">Address </span>           What<br><span class="hljs-number">1</span>       <span class="hljs-keyword">breakpoint </span>    keep y   <span class="hljs-number">0x0000000000400cb5</span> in main() <span class="hljs-built_in">at</span> test.cpp:<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><ul><li>Num：断点的编号</li><li>Enb：断点的状态，y表示使能，n表示未使能</li><li>What：断点所在文件，函数，行数</li></ul><h2 id="删除断点（delete）"><a href="#删除断点（delete）" class="headerlink" title="删除断点（delete）"></a>删除断点（delete）</h2><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-comment"># 删除一个断点</span><br>(gdb) d 断点编号<br><br><span class="hljs-comment"># 删除断点1,2,3</span><br>(gdb) d<span class="hljs-number"> 1 </span>2 3<br><br><span class="hljs-comment"># 删除一个范围的断点</span><br>(gdb) d 断点编号1-断点编号N<br><br><span class="hljs-comment"># 删除编号1到编号5的所有断点</span><br>(gdb) d 1-5<br></code></pre></td></tr></table></figure><h2 id="设置断点状态（enable-disable）"><a href="#设置断点状态（enable-disable）" class="headerlink" title="设置断点状态（enable&#x2F;disable）"></a>设置断点状态（enable&#x2F;disable）</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 设置断点无效</span><br>(gdb) <span class="hljs-built_in">disable</span> 断点编号<br><br><span class="hljs-comment"># 设置断点有效</span><br>(gdb) <span class="hljs-built_in">enable</span> 断点编号<br></code></pre></td></tr></table></figure><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><h2 id="继续运行（continue）"><a href="#继续运行（continue）" class="headerlink" title="继续运行（continue）"></a>继续运行（continue）</h2><p>遇到断点，程序停止，可以执行c指令继续向下运行，直到遇到下一个断点。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">(gdb) <span class="hljs-keyword">continue</span><br></code></pre></td></tr></table></figure><h2 id="手动打印信息"><a href="#手动打印信息" class="headerlink" title="手动打印信息"></a>手动打印信息</h2><h3 id="打印变量值（print）"><a href="#打印变量值（print）" class="headerlink" title="打印变量值（print）"></a>打印变量值（print）</h3><table><thead><tr><th align="center">格式化字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&#x2F;x</td><td align="center">十六进制</td></tr><tr><td align="center">&#x2F;d</td><td align="center">有符号十进制</td></tr><tr><td align="center">&#x2F;u</td><td align="center">无符号十进制</td></tr><tr><td align="center">&#x2F;o</td><td align="center">八进制</td></tr><tr><td align="center">&#x2F;t</td><td align="center">二进制</td></tr><tr><td align="center">&#x2F;f</td><td align="center">浮点型</td></tr><tr><td align="center">&#x2F;c</td><td align="center">字符型</td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">(gdb) <span class="hljs-selector-tag">p</span> 变量名<br># 以<span class="hljs-number">16</span>进制打印变量<span class="hljs-selector-tag">i</span><br>(gdb) <span class="hljs-selector-tag">p</span>/<span class="hljs-attribute">x</span> <span class="hljs-selector-tag">i</span><br></code></pre></td></tr></table></figure><h3 id="打印变量类型（ptype）"><a href="#打印变量类型（ptype）" class="headerlink" title="打印变量类型（ptype）"></a>打印变量类型（ptype）</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">(gdb) ptype 变量名<br><span class="hljs-comment"># 打印数组array的类型</span><br>(gdb) ptype<span class="hljs-built_in"> array</span><br><span class="hljs-built_in"></span>type = int[12]<br></code></pre></td></tr></table></figure><h2 id="查看内存（x）"><a href="#查看内存（x）" class="headerlink" title="查看内存（x）"></a>查看内存（x）</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">x &lt;addr&gt;<br><br># 查看函数<span class="hljs-function"><span class="hljs-keyword">fun</span>的地址,以16进制输出</span><br>(gdb) x/x <span class="hljs-function"><span class="hljs-keyword">fun</span></span><br></code></pre></td></tr></table></figure><h2 id="自动打印信息"><a href="#自动打印信息" class="headerlink" title="自动打印信息"></a>自动打印信息</h2><h3 id="设置某些变量自动打印变量值-display"><a href="#设置某些变量自动打印变量值-display" class="headerlink" title="设置某些变量自动打印变量值(display)"></a>设置某些变量自动打印变量值(display)</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">(gdb) <span class="hljs-attribute">display</span> 变量名<br><br># 以<span class="hljs-number">16</span>进制自动显示变量<span class="hljs-selector-tag">i</span>的值<br>(gdb) <span class="hljs-attribute">display</span>/<span class="hljs-attribute">x</span> <span class="hljs-selector-tag">i</span><br></code></pre></td></tr></table></figure><h3 id="查看自动显示列表-info-display"><a href="#查看自动显示列表-info-display" class="headerlink" title="查看自动显示列表(info display)"></a>查看自动显示列表(info display)</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">(gdb) info <span class="hljs-attribute">display</span><br>Auto-<span class="hljs-attribute">display</span> expressions now in effect:<br>Num Enb Expression<br><span class="hljs-number">2</span>:   y  array[i]<br></code></pre></td></tr></table></figure><ul><li>Num：变量&#x2F;表达式的编号（唯一）。</li><li>Enb：y表示激活状态，n表示禁用状态</li><li>Expression：变量&#x2F;表达式的名字</li></ul><h3 id="取消自动显示-undisplay"><a href="#取消自动显示-undisplay" class="headerlink" title="取消自动显示(undisplay)"></a>取消自动显示(undisplay)</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 删除自动显示列表中的变量或表达式</span><br>(gdb) undisplay 编号<br><br><span class="hljs-comment"># 禁用某个变量自动显示</span><br>(gdb) <span class="hljs-built_in">disable</span> display 编号<br><br><span class="hljs-comment"># 激活某个变量自动显示</span><br>(gdb) <span class="hljs-built_in">enable</span> display 编号<br></code></pre></td></tr></table></figure><h2 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h2><h3 id="step（s）"><a href="#step（s）" class="headerlink" title="step（s）"></a>step（s）</h3><p>命令被执行一次，代码向下运行一行，如果有函数，则会进入函数体内部。</p><h3 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h3><p>通过s单步调试进入函数体内部，如果想要跳出函数体，执行该命令。但是需要保证函数体内不能有有效断点，否则无法跳出。</p><h3 id="next"><a href="#next" class="headerlink" title="next"></a>next</h3><p>命令被执行一次，代码向下运行一行，不会进入函数体内部。</p><h3 id="until"><a href="#until" class="headerlink" title="until"></a>until</h3><p>通过until命令跳出循环体，需要满足以下条件：</p><ul><li>要跳出的函数体内部不能有有效的断点</li><li>必须要在循环体的开始&#x2F;结束行执行该命令</li></ul><h2 id="设置变量值"><a href="#设置变量值" class="headerlink" title="设置变量值"></a>设置变量值</h2><p>在循环体中，如果循环比较久，可以直接设置变量到最后两次循环，然后单步运行查看运行结果。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">(gdb) <span class="hljs-built_in">set</span> var 变量名=值<br><span class="hljs-comment"># 在100次的循环体中设置变量i为99</span><br>(gdb) <span class="hljs-built_in">set</span> var <span class="hljs-attribute">i</span>=99<br></code></pre></td></tr></table></figure><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="选择线程-t"><a href="#选择线程-t" class="headerlink" title="选择线程: t"></a>选择线程: t</h2><p><code>info thread</code>可以查看当前进程的所有线程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) info threads<br>  Id   Target Id            Frame <br>* 1    process 1537 <span class="hljs-string">&quot;example&quot;</span> main () at main.cpp:15<br></code></pre></td></tr></table></figure><p><code>thread/t</code>可以查看当前位于哪个线程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) t<br>[Current thread is 1 (process 3496)]<br></code></pre></td></tr></table></figure><p>在多线程程序里，可以通过 <code>t &#123;id&#125;</code>切换线程，每个线程都有独立的调用栈。</p><h2 id="查看堆栈-bt"><a href="#查看堆栈-bt" class="headerlink" title="查看堆栈: bt"></a>查看堆栈: bt</h2><p><code>backtrace/bt</code>可以查看调用栈，调用栈展示了从 <code>main()</code>入口到当前断点的所有函数调用路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) bt<br><span class="hljs-comment">#0  0x0 in (unknown) at :0</span><br><span class="hljs-comment">#1  0x1a796e7c in foo() at main.cpp:13</span><br><span class="hljs-comment">#2  0x6259058 in bar() at main.cpp:17</span><br><span class="hljs-comment">#3  0x6bb7580 in main() at main.cpp:83</span><br></code></pre></td></tr></table></figure><h2 id="选择栈帧-f"><a href="#选择栈帧-f" class="headerlink" title="选择栈帧: f"></a>选择栈帧: f</h2><p>每次函数调用，都会创建一个独立的栈帧，对应上面的 <code>#0</code>,<code>#1</code>…，默认在 <code>#0</code></p><p><code>frame/f</code>可以跳转到指定栈帧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) f 2<br><span class="hljs-comment">#2  bar() at main.cpp:17</span><br>17        int a = foo();<br></code></pre></td></tr></table></figure><p><code>up/down</code>可以向下层或上层跳转，对应编号的增大或减小。</p><h2 id="打印变量-p"><a href="#打印变量-p" class="headerlink" title="打印变量: p"></a>打印变量: p</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><code>print/p</code>可以打印一个变量值：数字，字符串，结构体，指针等变量类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p a // int a = 3;<br><span class="hljs-variable">$1</span> = 3<br></code></pre></td></tr></table></figure><p>打印出来的值会存在名为 <code>$1</code>,<code>$2</code>…的变量里，后续可以直接复用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p <span class="hljs-variable">$1</span> // 等价于 p a<br><span class="hljs-variable">$2</span> = 3<br></code></pre></td></tr></table></figure><h3 id="打印指针"><a href="#打印指针" class="headerlink" title="打印指针"></a>打印指针</h3><p>p后面直接跟一个指针类型的变量，打印的是指针的值，即指针所指向的地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p b // int* b = &amp;a;<br><span class="hljs-variable">$1</span> = (int *) 0x7ffd3dcfa27c<br></code></pre></td></tr></table></figure><p>可以用解引用运算符，打印指针指向的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p *b<br><span class="hljs-variable">$2</span> = 1<br></code></pre></td></tr></table></figure><p>如果是字符串指针，p会同时输出指针指向的地址和字符串的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">p str<br><span class="hljs-variable">$3</span> = (char*) 0x7ffc734ff250 <span class="hljs-string">&quot;hello,world&quot;</span><br></code></pre></td></tr></table></figure><p>如果只希望打印指针，可以使用说明符 <code>/a</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p/a str// /a表示address即把变量以地址的形式打印<br><span class="hljs-variable">$4</span> = 0x7ffc734ff250<br></code></pre></td></tr></table></figure><h4 id="地址字面量"><a href="#地址字面量" class="headerlink" title="地址字面量"></a>地址字面量</h4><p>p默认会把十六进制的字面量看成是数字，输出一个十进制的整数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p 0x7ffd3dcfa27c<br><span class="hljs-variable">$1</span> = 140725640471164<br>(gdb) p 140725640471164 == 0x7ffd3dcfa27c<br><span class="hljs-variable">$2</span> = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>如果想把数字解释为地址，打印地址上的内容，需要先指定变量类型，然后解引用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p *(int*)0x7ffd3dcfa27c<br><span class="hljs-variable">$3</span> = 1<br></code></pre></td></tr></table></figure><p>更简单的语法是：<code>&#123;TYPE&#125; ADDRESS</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p &#123;int&#125;0x7ffd3dcfa27c<br><span class="hljs-variable">$4</span> = 1<br></code></pre></td></tr></table></figure><h4 id="转换指针类型"><a href="#转换指针类型" class="headerlink" title="转换指针类型"></a>转换指针类型</h4><p>指针的类型可以转换，以不同的方式解释其指向的内存区域：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">// char* c = <span class="hljs-string">&quot;hello, world&quot;</span>;<br>(gdb) p c<br><span class="hljs-variable">$1</span> = (char *) 0x7ffc734ff250 <span class="hljs-string">&quot;hello, world&quot;</span>;<br>(gdb) p *(int*)c<br><span class="hljs-variable">$2</span> = 1819043176<br>(gdb) p &#123;int&#125;c<br><span class="hljs-variable">$3</span> = 1819043176<br></code></pre></td></tr></table></figure><p>打印内存可以发现，<code>1819043176</code>就是把hell四个字符解释成了一个整数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) x/w 0x7ffc734ff250    // 以 word 形式打印，4 个字节<br>0x7ffc734ff250:1819043176  // 上述 4 个字符的 ASCII 码转成整数<br></code></pre></td></tr></table></figure><p><code>1819043176</code> 对应的十六进制是 <code>0x6C6C6568</code>，恰好依次是 <code>l</code> , <code>l</code> , <code>e</code> 和 <code>h</code> 的 ASCII 码。</p><h4 id="打印结构体字段"><a href="#打印结构体字段" class="headerlink" title="打印结构体字段"></a>打印结构体字段</h4><p>如果指针 <code>p</code> 指向某个结构体，可以用 <code>p ptr-&gt;field</code> 打印字段的值。</p><p>在 GDB 里 <code>.</code> 和 <code>-&gt;</code> 是一样的，所以无论 <code>ptr</code> 是否是指针，都可以用 <code>p.field</code> 打印字段的值。</p><h3 id="打印数组"><a href="#打印数组" class="headerlink" title="打印数组"></a>打印数组</h3><p>语法：<code>p ELEMENT@LEN</code>。从ELEMENT的地址开始向后解释LEN大小的内存单元</p><h4 id="栈上数组"><a href="#栈上数组" class="headerlink" title="栈上数组"></a>栈上数组</h4><p>如果array是栈上数组，直接p array会打印数组的所有元素。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">// int array[] = &#123;1, 2, 3, 4&#125;;<br>(gdb) p array<br><span class="hljs-variable">$1</span> = &#123;1, 2, 3, 4&#125;<br></code></pre></td></tr></table></figure><p>也可以 <code>p array[INDEX]@LEN</code>，从某个下标开始打印指定的长度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p array[1]@3<br><span class="hljs-variable">$4</span> = &#123;2, 3, 4&#125;<br></code></pre></td></tr></table></figure><p>但是不能 <code>p array@3</code>，因为栈上数组array的类型是int[4]而不是int：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p array@3<br><span class="hljs-variable">$6</span> = &#123;&#123;1, 2, 3, 4&#125;, &#123;4096, 0, 89129472, 1043493597&#125;, &#123;1, 0, -136626800, 32767&#125;&#125;<br></code></pre></td></tr></table></figure><h4 id="堆上数组"><a href="#堆上数组" class="headerlink" title="堆上数组"></a>堆上数组</h4><p>如果array是堆上数组，可以使用：<code>p *array@LEN</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">// int* array = (int*)malloc(3 * sizeof(int));<br>(gdb) p *array@3 // *array 是数组的第一个元素，类型是 int<br><span class="hljs-variable">$1</span> = &#123;1, 2, 3&#125;<br></code></pre></td></tr></table></figure><p>或者 <code>p array[INDEX]@LEN</code>，从某个下标开始打印：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p array[1]@3 // array[1] 的类型是 int<br><span class="hljs-variable">$2</span> = &#123;2, 3, 4&#125;<br></code></pre></td></tr></table></figure><p>但是不能 <code>p array</code>，因为堆上数组array的类型是int*指针，值是一个地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p array<br><span class="hljs-variable">$3</span> = 0x55669a743eb0<br></code></pre></td></tr></table></figure><p>同理，<code>p array@LEN</code>会输出栈上相邻的内存地址（没有意义）：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">(gdb) p array<span class="hljs-symbol">@3</span><br>$4 = &#123;<span class="hljs-number">0x55669a743eb0</span>, <span class="hljs-number">0x55669a255330</span>, <span class="hljs-number">0x200000001</span>&#125;<br></code></pre></td></tr></table></figure><p>如果数组只有一个地址字面量，可以把它强制转换为指针类型，然后用同样的语法打印：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p ((int*)<span class="hljs-number">0</span>x55669a743eb0))[2]<br><span class="hljs-variable">$5</span> = 3<br></code></pre></td></tr></table></figure><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p>可以在p后面添加说明符，把一个变量解释为给定的类型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p foo // int foo = 98;<br><span class="hljs-variable">$1</span> = 98<br>(gdb) p/c foo // 将 98 解释为字符<br><span class="hljs-variable">$2</span> = 98 <span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><p>所有说明符：</p><ul><li>p&#x2F;a：将变量解释为指针address，使用十六进制打印</li><li>p&#x2F;c：将变量解释为字符，打印为字符</li><li>p&#x2F;o：使用八进制打印变量</li><li>p&#x2F;x：使用十六进制打印变量</li><li>p&#x2F;u：将变量解释为无符号整数unsigned，使用十进制打印</li><li>p&#x2F;s：将变量解释为字符串打印输出</li><li>help x：查看全部</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">o(octal), x(hex), d(decimal), u(unsigned decimal),<br>t(binary), f(float), a(address), i(instruction), <br>c(char), s(string) and z(hex, zero padded on the left)<br></code></pre></td></tr></table></figure><h3 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h3><h4 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h4><p>直接打印：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">// std::shared_ptr&lt;int&gt; ptr = std::make_shared&lt;int&gt;(1);<br>(gdb) p ptr<br><span class="hljs-variable">$1</span> = std::shared_ptr&lt;int&gt; (use count 1, weak count 0) = &#123;<br>  get() = 0x5596169122f0&#125;<br>(gdb) p *ptr<br><span class="hljs-variable">$2</span> = 1<br></code></pre></td></tr></table></figure><p>或者根据上面get()方法给出的地址打印：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p &#123;int&#125;0x5596169122f0<br><span class="hljs-variable">$3</span> = 1<br></code></pre></td></tr></table></figure><p>或者根据shared_ptr内部的私有变量 <code>_M_ptr</code>打印：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p ptr._M_ptr<br><span class="hljs-variable">$4</span> = 0x5596169122f0<br>(gdb) p *(ptr._M_ptr)<br><span class="hljs-variable">$5</span> = 1<br></code></pre></td></tr></table></figure><h4 id="std-vector"><a href="#std-vector" class="headerlink" title="std::vector"></a>std::vector</h4><p>直接打印：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">// std::vector&lt;int&gt; vec = &#123;1, 2, 3, 4&#125;;<br>(gdb) p vec<br><span class="hljs-variable">$1</span> = std::vector of length 4, capacity 4 = &#123;1, 2, 3, 4&#125;<br></code></pre></td></tr></table></figure><p>vector也有私有变量，保存了数据的实际存储位置：</p><ul><li><code>_M_imp1._M_start</code>：数组起始地址</li><li><code>_M_imp1._M_finish</code>：数组结束地址（数组最后一个元素的下一个）</li></ul><p>可以根据这个指针打印：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p &#123;int&#125;vec._M_impl._M_start<br><span class="hljs-variable">$2</span> = 1<br>(gdb) p &#123;int&#125;vec._M_impl._M_start@3<br><span class="hljs-variable">$3</span> = &#123;1, 2, 3&#125;<br>(gdb) p (&#123;int&#125;vec._M_impl._M_start)[2]<br><span class="hljs-variable">$4</span> = 3<br></code></pre></td></tr></table></figure><h4 id="std-string"><a href="#std-string" class="headerlink" title="std::string"></a>std::string</h4><p>直接打印：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p str<br><span class="hljs-variable">$1</span> = <span class="hljs-string">&quot;hello,world&quot;</span><br></code></pre></td></tr></table></figure><p>或者根据私有变量 <code>_M_dataplus._M_p</code>打印，其类型是char*：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p str._M_dataplus._M_p<br><span class="hljs-variable">$2</span> = (std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::pointer) 0x7ffc734ff250 <span class="hljs-string">&quot;hello,world&quot;</span><br></code></pre></td></tr></table></figure><h4 id="使用STL-Views插件"><a href="#使用STL-Views插件" class="headerlink" title="使用STL-Views插件"></a>使用STL-Views插件</h4><p>使用gdb打印set，stack，map等STL容器比较困难。gdb支持使用python编写的printer，<a href="https://sourceware.org/gdb/wiki/STLSupport">GDB官网</a>提供了STL容器的printer。</p><ol><li><a href="https://sourceware.org/gdb/wiki/STLSupport?action=AttachFile&do=view&target=stl-views-1.0.3.gdb">下载地址</a></li><li><a href="http://www.yolinux.com/TUTORIALS/GDB-Commands.html#STLDEREF">官方教程</a></li><li>把下载下来的文件放到home目录（wherever）</li><li>进入gdb</li><li>加载插件：source ~&#x2F;std-views-1.0.3.gdb</li></ol><p>进入gdb，加载插件，查看帮助：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) <span class="hljs-built_in">source</span> ~/stl-views-1.0.3.gdb<br>(gdb) <span class="hljs-built_in">help</span> pset<br>(gdb) <span class="hljs-built_in">help</span> pmap<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) pset s<br>(gdb) pset s int<br>(gdb) pset s int 20<br></code></pre></td></tr></table></figure><h3 id="如果打印内容被省略"><a href="#如果打印内容被省略" class="headerlink" title="如果打印内容被省略"></a>如果打印内容被省略</h3><p>打印字符串的时候，如果有重复的字符，可能会被合并成一个：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p <span class="hljs-string">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span><br><span class="hljs-variable">$1</span> = <span class="hljs-string">&#x27;a&#x27;</span> &lt;repeats 30 <span class="hljs-built_in">times</span>&gt;<br></code></pre></td></tr></table></figure><p>可以通过命令 <code>set print repeats 0</code>设置为不合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) <span class="hljs-built_in">set</span> <span class="hljs-built_in">print</span> repeats 0<br>(gdb) p <span class="hljs-string">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span><br><span class="hljs-variable">$2</span> = <span class="hljs-string">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span><br></code></pre></td></tr></table></figure><p>如果打印数组的时候元素过多，中间的元素会被省略，可以通过以下设置，设置为不省略：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> <span class="hljs-built_in">print</span> elements 0<br></code></pre></td></tr></table></figure><h3 id="查看历史变量"><a href="#查看历史变量" class="headerlink" title="查看历史变量"></a>查看历史变量</h3><p>通过p打印出来的值，会被存在名为$1,$2,$3…的变量里（<a href="https://sourceware.org/gdb/current/onlinedocs/gdb.html/Value-History.html#Value-History">value history</a>）后续可以直接复用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p a<br><span class="hljs-variable">$1</span> = 123<br>(gdb) p <span class="hljs-variable">$1</span> // 等价于 p a<br><span class="hljs-variable">$2</span> = 123<br></code></pre></td></tr></table></figure><p>一些特殊的变量：</p><ul><li><code>$</code>：最近打印的变量</li><li><code>$$</code>：<code>$</code>之前的变量，即倒数第二个</li><li><code>$$n</code>：最后一个变量往前的第n个变量比如 <code>$$0</code>就是 <code>$</code></li></ul><p>可以批量打印历史变量：</p><ul><li><code>show value</code>：打印最后10个历史变量</li><li><code>show value +</code>：这个命令是在 <code>show value</code>的基础上使用的，它会打印出紧随刚才 <code>show value</code>命令打印的10个历史变量之后的另外10个历史变量。这个命令用于当你想要查看更多历史变量时，而不仅仅是最近的10个。</li></ul><h2 id="打印内存-x"><a href="#打印内存-x" class="headerlink" title="打印内存: x"></a>打印内存: x</h2><p>x可以查看一个内存地址的值，以指定的格式打印。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) x/s 0x7ffc734ff250  // 以字符串形式打印<br>0x7ffc734ff250:<span class="hljs-string">&quot;hello,world&quot;</span><br></code></pre></td></tr></table></figure><p>x支持的格式化说明符：</p><ul><li>x&#x2F;c：将地址解释为字符char，打印为字符</li><li>x&#x2F;o：使用八进制打印变量</li><li>x&#x2F;x：使用十六进制打印变量</li><li>x&#x2F;u：将地址解释为无符号整数unsiged，使用十进制打印</li><li>x&#x2F;s：将地址解释为字符串</li><li>help x：查看全部</li></ul><p>x的完整语法：<code>x/FMT ADDRESS</code>，<code>F</code> &#x2F; <code>M</code> &#x2F; <code>T</code> 是可选的参数。</p><ul><li><code>F</code>：一个数字，表示输出几个内存单元，默认是 1</li><li><code>M</code>：格式化说明符，<code>o</code> &#x2F; <code>x</code> &#x2F; <code>d</code> &#x2F; <code>u</code> &#x2F; <code>s</code> 等</li><li><code>T</code>：一个内存单元的字节数，默认是 4 个字节，可选的是 b(byte), h(halfword), w(word), g(giant, 8 bytes)</li><li><code>ADDRESS</code>：一个内存地址，可以是一个字面量，也可以是一个指针类型的变量</li></ul><blockquote><p>例如，<code>x/3uh 0x1234</code> 表示从内存地址 0x1234 开始，以两字节为单位，输出 3 个无符号整数。</p></blockquote><h3 id="x和p的区别："><a href="#x和p的区别：" class="headerlink" title="x和p的区别："></a>x和p的区别：</h3><ol><li><p>传入一个数字，p会当作一个数字字面量，输出原始值得十进制；而x会当作一个地址，输出对应内存区域得值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p 0x10    // 字面量<br><span class="hljs-variable">$1</span> = 16        // 输出十进制值<br>(gdb) p/x 0x10  // 以十六进制形式输出<br><span class="hljs-variable">$2</span> = 0x10<br><br>(gdb) x/s 0x10  // 这个内存地址解释为字符串<br>0x10 <span class="hljs-string">&quot;hello, world&quot;</span>  <br>(gdb) x/c 0x10  // 把这个地址上的内容解释为单个字符<br>0x10:<span class="hljs-string">&#x27;h&#x27;</span><br>(gdb) x/d 0x10  // 把这个地址上的内容解释为整数<br>0x10:104<br></code></pre></td></tr></table></figure></li><li><p>传入一个指针，p会输出指针的值，即一个十六进制的地址；而x会输出指针指向的内存区域的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">（gdb) p str_pointer;<br><span class="hljs-variable">$1</span> = 0x7ffc<br><br>(gdb) x/s 0x7ffc<br>0x7ffc <span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="打印类型-ptype"><a href="#打印类型-ptype" class="headerlink" title="打印类型: ptype"></a>打印类型: ptype</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) ptype foo<br><span class="hljs-built_in">type</span> = int<br></code></pre></td></tr></table></figure><h2 id="打印各种信息-i"><a href="#打印各种信息-i" class="headerlink" title="打印各种信息: i"></a>打印各种信息: i</h2><ul><li><code>info locals</code>打印当前栈帧的局部变量</li><li><code>info args</code>：打印所有函数参数</li><li><code>info threads</code>：打印进程的线程信息</li><li><code>info registers</code>：打印当前线程的寄存器信息</li><li><code>info sharedlibrary</code>：打印当前加载的动态链接库</li><li><code>info proc mappings</code>：打印地址空间中的内存map，用来确定某个地址的类型</li><li><code>help info</code>：所有info支持的命令</li></ul><h2 id="存储变量-修改变量的值-set"><a href="#存储变量-修改变量的值-set" class="headerlink" title="存储变量&#x2F;修改变量的值: set"></a>存储变量&#x2F;修改变量的值: set</h2><p>set可以保存一个变量（<a href="https://sourceware.org/gdb/current/onlinedocs/gdb.html/Convenience-Vars.html">Convenience Variables</a>）方便后续使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">（gdb) <span class="hljs-built_in">set</span> <span class="hljs-variable">$foo</span> = *object_ptr<br></code></pre></td></tr></table></figure><p>查看所有存储的变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) show convenience<br>(gdb) show conv  // 简写形式<br></code></pre></td></tr></table></figure><p>set命令可以用于在运行时修改某个变量的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) <span class="hljs-built_in">set</span> foo.bar = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>修改变量值的使用场景：</p><ul><li>临时修复某个bug使程序可以继续运行</li><li>给变量设置不同的值，测试不同的case</li><li>循环中设置循环变量的值，直接快进到最后一轮查看结果</li></ul><h2 id="断点调试-b"><a href="#断点调试-b" class="headerlink" title="断点调试: b"></a>断点调试: b</h2><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><p>设置断点的方式有多种（<a href="https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_28.html">官方文档</a>）:</p><ul><li>在当前执行位置设置断点：<code>b</code></li><li>函数名：<code>b function</code></li><li>文件名+函数名：<code>b filename:function</code></li><li>当前文件行号：<code>b linenum</code></li><li>特定文件行号：<code>b filename:linenum</code></li><li>偏移量：<code>b +offset</code>&#x2F;<code>b -offset</code>，在当前栈帧执行位置的前后设置断点</li></ul><h3 id="删除断点-clear"><a href="#删除断点-clear" class="headerlink" title="删除断点: clear"></a>删除断点: clear</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) clear foo.cpp:14<br></code></pre></td></tr></table></figure><p>clear的语法和break相同，需要指定要删除的断点的位置：</p><ul><li>clear：删除当前指定位置上的所有断点</li><li>clear function</li><li>clear filename:function</li><li>clear linenum</li><li>clear filename:linenum</li><li>delete：删除所有断点，简写d</li></ul><p>设置临时断点：tbreak，参数同break，命中一次后自动删除</p><h3 id="启用-停用断点"><a href="#启用-停用断点" class="headerlink" title="启用&#x2F;停用断点"></a>启用&#x2F;停用断点</h3><p>停用断点：<code>disable</code></p><p>启用断点：<code>enable</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">停用断点：<span class="hljs-built_in">disable</span><br><br>(gdb) <span class="hljs-built_in">disable</span>      // 停用所有断点<br>(gdb) <span class="hljs-built_in">disable</span> NUM  // 停用编号为 n 的断点<br></code></pre></td></tr></table></figure><h3 id="继续运行-c"><a href="#继续运行-c" class="headerlink" title="继续运行: c"></a>继续运行: c</h3><p>命中断点之后程序会停止运行，此时可以通过 <code>continue</code>命令继续运行程序，简写 <code>c</code></p><h3 id="查看所有断点-i-b"><a href="#查看所有断点-i-b" class="headerlink" title="查看所有断点: i b"></a>查看所有断点: i b</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) i b<br>(gdb) info breakpoints<br></code></pre></td></tr></table></figure><p>会以表格的形式展示断点编号，是否是临时断点，是否enable，断点位置等信息。</p><h3 id="在函数返回前中断"><a href="#在函数返回前中断" class="headerlink" title="在函数返回前中断"></a>在函数返回前中断</h3><p>有时候希望在函数返回前中断，从而检查函数的返回值，或者检查函数是在哪一个 <code>return</code>语句返回的。</p><ol><li><p>方式一：先正向执行直到函数返回，然后再反向执行设置断点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) record<br>(gdb) fin<br>(gdb) reverse-step<br></code></pre></td></tr></table></figure><p>record：这个命令用于开启GDB的记录功能。当你执行 <code>record</code>命令后，GDB会开始记录程序的执行历史，包括函数调用、变量值的变化等。</p><p>fin：这个命令用于结束当前的记录会话。在执行完 <code>record</code>命令并让程序运行到你想要检查的函数返回之后，使用 <code>fin</code>命令来停止记录。</p><p>reverse-step：这个命令用于执行反向单步执行。在停止记录后，你可以使用 <code>reverse-step</code>命令来反向步进，检查函数返回前的状态。</p></li><li><p>方式二：所有函数无论有多少条return语句，在编译成汇编指令后，一定是只有一条 <code>retq</code>指令，因此可以在汇编指令中找到 <code>retq</code>所在位置打断点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">int <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;<br>  <span class="hljs-built_in">return</span> foo(0);<br>&#125;<br><br>(gdb) disas foo  // 查看汇编<br>Dump of assembler code <span class="hljs-keyword">for</span> <span class="hljs-keyword">function</span> foo:<br>   0x0000000000400448 &lt;+0&gt;: push   %rbp<br>   0x0000000000400449 &lt;+1&gt;: mov    %rsp,%rbp<br>   ...<br>   0x0000000000400473 &lt;+43&gt;:    jmp    0x40047c &lt;foo+52&gt;<br>   0x0000000000400480 &lt;+56&gt;:    retq   // 这里就是函数的返回指令<br>End of assembler dump.<br><br>(gdb) b *0x0000000000400480  // 在 retq 指令打断点<br>Breakpoint 1 at 0x400480<br><br>(gdb) r  // 运行程序，直到命中断点<br>Breakpoint 1, 0x0000000000400480 <span class="hljs-keyword">in</span> foo ()<br><br>(gdb) p var<br><span class="hljs-variable">$1</span> = 42<br></code></pre></td></tr></table></figure></li></ol><h3 id="监控断点-watch"><a href="#监控断点-watch" class="headerlink" title="监控断点: watch"></a>监控断点: watch</h3><p>GDB可以监控一个变量，直到它被修改时才触发断点，<a href="https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_29.html#SEC30">官方文档</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) watch foo<br>(gdb) watch bar.var<br></code></pre></td></tr></table></figure><p>如果想在变量被读取时中断，可以使用 <code>rwatch</code> 或 <code>awatch</code>：</p><ul><li>rwatch：仅当变量被读取时中断</li><li>awatch：当变量被读取或写入时中断</li></ul><p>查看所有的watchpoints:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) info watchpoints<br></code></pre></td></tr></table></figure><h3 id="条件断点-b…if"><a href="#条件断点-b…if" class="headerlink" title="条件断点: b…if"></a>条件断点: b…if</h3><p>常规断点（breakpoints）和监控断点（watchpoints）都可以绑定一个条件，只有在满足条件时才触发断点，<a href="https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_33.html#SEC34">官方文档</a>：</p><p>“条件”是一个布尔表达式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) b foo.cpp:123 <span class="hljs-keyword">if</span> bar == 1<br>(gdb) b foo.cpp:123 <span class="hljs-keyword">if</span> bar == 1 &amp;&amp; foo &lt; 2<br></code></pre></td></tr></table></figure><p>如果要判断两个字符串是否相等，可以使用gdb的内置函数 <code>$_streu</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) b foo.cpp:123 <span class="hljs-keyword">if</span> <span class="hljs-variable">$_streq</span>(some_str, <span class="hljs-string">&quot;hello_world&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="断点命令列表-commands"><a href="#断点命令列表-commands" class="headerlink" title="断点命令列表: commands"></a>断点命令列表: commands</h3><p>可以通过commands命令给断点绑定一组自定义命令，当命中断点后会自动执行，打印变量的值，或者设置另一个断点。</p><p>语法：先制定要绑定的断点的编号，然后输入自定义命令，最后以end结束：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">（gdb) commands 1<br>（gdb) p foo<br>（gdb) end<br></code></pre></td></tr></table></figure><p>断点编号可以通过 <code>i b</code>或者 <code>i wat</code> 获取，如果不给commands传入任何编号，默认绑定到最近触发的断点上。</p><p><code>commands</code>的应用场景之一是收集信息。比如在某行代码后面插入一行debug日志，打印变量或者调用栈。由于每次命中断点后，必须输入 <code>cont</code>命令才会继续运行程序，因此可以在 <code>end</code>前加一个 <code>cont</code>命令，这样程序就可以无需干预自动执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) b foo.cpp:123<br>(gdb) commands<br>(gdb) p bar<br>(gdb) cont<br>(gdb) end<br></code></pre></td></tr></table></figure><p><code>commands</code>的另一个应用场景是临时修复一个bug，以便让程序正常运行。比如在某一行错误代码后面，给变量设置正确的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) b foo.cpp:123<br>(gdb) commands<br>(gdb) silent  // 这个命令后面的命令不会有任何输出<br>(gdb) <span class="hljs-built_in">set</span> x = y + 4<br>(gdb) cont<br>(gdb) end<br></code></pre></td></tr></table></figure><h2 id="运行程序-n-s-n-fin-u"><a href="#运行程序-n-s-n-fin-u" class="headerlink" title="运行程序: n&#x2F;s&#x2F;n&#x2F;fin&#x2F;u"></a>运行程序: n&#x2F;s&#x2F;n&#x2F;fin&#x2F;u</h2><ul><li>run&#x2F;r：启动程序，直到遇到第一个断点或运行结束</li><li>start：启动程序，临时停在main()的第一行</li><li>next&#x2F;n：逐行执行，如果某一行是函数，不会进入函数内部，而是执行完整个函数</li><li>step&#x2F;s：逐行执行，如果某一行是函数，则会进入函数的第一行</li><li>continue&#x2F;c：从断点位置继续执行，直到遇到下一个断点或运行结束</li><li>finish&#x2F;fin：执行到函数结束，停在return后的下一条语句</li><li>until&#x2F;u<ul><li>不加任何参数：执行直到当前语句结束，比如在for循环里，until会跳到for循环体的下一行，准备开始下一次迭代。这样，你可以逐个检查循环的每次迭代，而不需要每次都手动继续执行。</li><li>加参数：执行直到指定位置，参数语法同break，等价于tbreak+continue</li></ul></li><li>quit&#x2F;q：退出GDB</li></ul><p>直接回车会重复上一次执行的命令。</p><h2 id="输出日志-set-logging"><a href="#输出日志-set-logging" class="headerlink" title="输出日志: set logging"></a>输出日志: set logging</h2><p>可以把所有输出打印到日志里，作进一步分析。</p><p>需要执行以下两个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) <span class="hljs-built_in">set</span> logging file gdb.txt<br>(gdb) <span class="hljs-built_in">set</span> logging on<br>copying output to gdb.txt<br></code></pre></td></tr></table></figure><p>这样任何命令的输出便会写到 <code>gdb.txt</code>文件中，前提是shell拥有该文件的写入权限。</p><p>配合以下命令，确保输出完整内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> <span class="hljs-built_in">print</span> repeats 0       // 否则相同的连续字符会被合并<br><span class="hljs-built_in">set</span> <span class="hljs-built_in">print</span> elements 0      // 否则过长的数组会被省略<br><span class="hljs-built_in">set</span> height 0              // 否则如果一页显示不完，会停下来要求 <span class="hljs-built_in">continue</span><br><span class="hljs-built_in">set</span> width 0  <br></code></pre></td></tr></table></figure><h1 id="配置文件-gdbinit"><a href="#配置文件-gdbinit" class="headerlink" title="配置文件: ~&#x2F;.gdbinit"></a>配置文件: ~&#x2F;.gdbinit</h1><p>可以把一些常用的配置、插件、自定义命令放在 <code>~/.gdbinit</code></p><p>Github 上有一些开箱即用的 <code>~/.gdbinit</code> 文件：</p><ul><li><a href="https://github.com/gdbinit/Gdbinit/blob/master/gdbinit">https://github.com/gdbinit/Gdbinit/blob/master/gdbinit</a></li><li><a href="https://github.com/cyrus-and/gdb-dashboard">gdb-dashboard</a>：可视化界面、丰富的功能</li><li><a href="https://github.com/hugsy/gef">gef</a>：可视化界面、丰富的功能</li><li><a href="https://github.com/pwndbg/pwndbg">pwndbg</a></li></ul><p>gdb-dashboard 使用笔记：</p><ul><li>使用 <code>-output</code> 命令将某些组件在其他终端显示，比如终端 A 执行 gdb 命令，终端 B 显示断点、变量值、调用栈。在终端输入 <code>tty</code> 命令就可以查看当前终端的序号。</li><li>介绍文章：<a href="https://zhuanlan.zhihu.com/p/435918702">https://zhuanlan.zhihu.com/p/435918702</a></li></ul><h1 id="加载插件"><a href="#加载插件" class="headerlink" title="加载插件"></a>加载插件</h1><p>GDB 可以使用 <a href="https://sourceware.org/gdb/onlinedocs/gdb/Python-API.html">Python API</a> 来实现自定义脚本。脚本可以直接写在 <code>~/.gdbinit</code>，或者写在一个单独的文件中，然后通过 <code>source</code> 命令加载。</p><p>网上有很多可用的插件，比如 <a href="https://sourceware.org/gdb/wiki/STLSupport">STL views</a> 提供了一些打印 STL 容器的命令。</p><h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>调用栈（call stack）被分成若干个栈帧（stack frame），每个栈帧包括一次函数调用相关的所有数据：函数的参数，函数的局部变量，函数的返回地址等。</p><p>程序启动时只有一个栈帧即main函数，又称初始栈帧或最外层栈帧。每次函数调用都会创建一个新栈帧，每次函数返回时，一个栈帧也会被弹出。当前执行的函数所对应的栈帧又称最内层栈帧。</p><p>GDB给每个栈帧分配了一个数字，最内层栈帧的编号为0，外层栈帧一次加1。可以通过 <code>bt</code>命令查看所有栈帧，通过 <code>f</code>命令加上编号进入到对应的栈帧。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li><code>gdb -p 8043</code>启动gdb附加到进程ID(PID)为8043的进程上。附加成功后可以使用gdb提供的各种调试命令检查和控制该进程的执行。</li><li><code>bt full</code>查看详细调用栈信息，会把frame中的入参和局部变量显示出来。</li><li><code>./exec &amp;</code>后面的&amp;表示把程序放在后台运行，从而立即返回命令行，可以执行下一步操作，而不需要等待程序运行。</li><li><code>ps -e</code>列出当前系统上所有的进程。<code>ps</code>显示系统上的进程状态，<code>-e</code>表示显示所有的进程列表不仅仅是当前用户的进程</li></ul><h1 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h1><ul><li><a href="https://sourceware.org/gdb/">GDB官网</a></li><li><a href="https://sourceware.org/gdb/onlinedocs/gdb/">Debugging with GDB</a></li><li><a href="https://www.brendangregg.com/blog/2016-08-09/gdb-example-ncurses.html">gdb debug full examples</a></li><li><a href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html">100个 GDB 小技巧</a></li><li><a href="https://pernos.co/">在线 GDB 平台</a></li><li><a href="https://imageslr.com/2023/gdb.html#coredump">GDB 入门</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FTP</title>
    <link href="/2025/02/22/NetworkCommunications/FTP/"/>
    <url>/2025/02/22/NetworkCommunications/FTP/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h1><ol><li>根据网络作用分类：<ul><li>广域网WAN</li><li>城域网MAN</li><li>局域网LAN</li><li>个人局域网PAN</li></ul></li><li>根据网络使用者分类：<ul><li>公用网</li><li>专用网</li></ul></li></ol><span id="more"></span><h1 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h1><ol><li>速率：网络中两台主机之间的数据传输速率，又称比特率或数据率；</li><li>带宽：通信线路传输数据的能力；</li><li>吞吐量：单位时间通过某个网络的数据总量；</li><li>时延：报文从一个网络的一个节点传送到另一个节点所需要的时间；</li><li>时延带宽积：信道中正在传输的数据总量；</li><li>往返时间(Round-Trip Time)：发送端发送数据到其接收到确认反馈的时间；</li><li>信道利用率：某个信道有数据通过的时间百分比；</li><li>网络利用率：整个网络中信道利用率的加权平均值。</li></ol><h1 id="FTP模型"><a href="#FTP模型" class="headerlink" title="FTP模型"></a>FTP模型</h1><p>FTP文件传输协议，位于应用层，基于C&#x2F;S架构。</p><p>FTP系统和其他C&#x2F;S系统的区别在于，客户端和服务器同时建立了两条连接：</p><ul><li>一条用于控制信号的传输</li><li>一条用于数据的传输</li></ul><p>控制连接一般用21号端口。</p><h1 id="FTP传输方式"><a href="#FTP传输方式" class="headerlink" title="FTP传输方式"></a>FTP传输方式</h1><h2 id="主动传输"><a href="#主动传输" class="headerlink" title="主动传输"></a>主动传输</h2><ol><li>客户端与服务器的21号端口建立TCP控制连接；</li><li>用户在控制通道中使用 <code>PORT</code>命令向服务器发送本地IP和端口（数据传输）；</li><li>服务器<strong>主动</strong>连接客户端发送来的指定端口，建立数据连接。</li></ol><h2 id="被动传输"><a href="#被动传输" class="headerlink" title="被动传输"></a>被动传输</h2><ol><li>客户端与服务器的21号端口建立TCP控制连接；</li><li>用户在控制通道中发送 <code>PASV</code>命令请求服务器开启一个用于数据传输的端口；</li><li>服务器收到命令之后，开启一个大于1024的端口，并将其IP和端口发送给客户端；</li><li>客户端收到IP和端口后，主动连接到服务器的该端口，建立数据连接。</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络通信</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>makefile</title>
    <link href="/2025/02/22/MissingSemester/makefile/"/>
    <url>/2025/02/22/MissingSemester/makefile/</url>
    
    <content type="html"><![CDATA[<h1 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h1><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">target</span>:depend<br>    commend<br></code></pre></td></tr></table></figure><p>每条规则由三部分组成：目标（target），依赖（depend），命令（comment）</p><ul><li>目标：目标可以有多个</li><li>依赖：依赖可有可无</li><li>命令：前面要有Tab缩进，shell命令</li></ul><span id="more"></span><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>make命令执行的时候根据时间戳判定是否执行makefile文件中相关规则的命令。</p><ul><li>目标是通过依赖生成的，目标时间戳&gt;所有依赖时间戳，则不会执行规则中的命令</li><li>目标时间戳&lt;某些依赖的时间戳，则执行规则中的命令</li><li>目标文件不存在，执行规则中的命令</li></ul><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 定义变量（必须要同时赋值）</span><br>变量名=变量值<br><br><span class="hljs-comment"># 取变量值</span><br><span class="hljs-variable">$(</span>变量名)<br></code></pre></td></tr></table></figure><h2 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h2><table><thead><tr><th align="center">变量名</th><th align="center">含义</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">AR</td><td align="center">生成静态库程序</td><td align="center">ar</td></tr><tr><td align="center">AS</td><td align="center">汇编编译器</td><td align="center">as</td></tr><tr><td align="center">CC</td><td align="center">C语言编译器</td><td align="center">cc</td></tr><tr><td align="center">CPP</td><td align="center">C语言预编译器</td><td align="center">$(CC) -E</td></tr><tr><td align="center">CXX</td><td align="center">C++编译器</td><td align="center">g++</td></tr><tr><td align="center">RM</td><td align="center">删除文件程序</td><td align="center">rm -f</td></tr><tr><td align="center">ARFLAGS</td><td align="center">生成静态库程序的选项</td><td align="center">无</td></tr><tr><td align="center">ASFLAGS</td><td align="center">汇编语言编译器编译选项</td><td align="center">无</td></tr><tr><td align="center">CFLAGS</td><td align="center">C语言编译器的编译选项</td><td align="center">无</td></tr><tr><td align="center">CPPFLAGS</td><td align="center">C语言预编译器的编译选项</td><td align="center">无</td></tr><tr><td align="center">CXXFLAGS</td><td align="center">C++编译器的编译选项</td><td align="center">无</td></tr></tbody></table><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 示例：</span><br>obj=main.o sub.o add.o<br>target=calc<br>CFLAGS=-O3<br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(obj)</span><br>    <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(obj)</span> -o <span class="hljs-variable">$(target)</span> <span class="hljs-variable">$(CFLAGS)</span><br></code></pre></td></tr></table></figure><h2 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h2><table><thead><tr><th align="center">变量</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">$@</td><td align="center">目标文件(target)的完整名称</td></tr><tr><td align="center">$&lt;</td><td align="center">第一个依赖文件的名称</td></tr><tr><td align="center">$^</td><td align="center">所有依赖文件的名称，以空格分开，不包含重复依赖</td></tr><tr><td align="center">$*</td><td align="center">目标文件的名称，不包含扩展名</td></tr><tr><td align="center">$?</td><td align="center">依赖项中，所有比目标文件时间戳晚的依赖文件，以空格分开</td></tr></tbody></table><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 示例：</span><br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(obj)</span><br>    gcc <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><h1 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h1><p>使用模式匹配前：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">calc:add.o  div.o  main.o  mult.o  sub.o</span><br>        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc<br><br><span class="hljs-section">add.o:add.c</span><br>        gcc add.c -c<br><br><span class="hljs-section">div.o:div.c</span><br>        gcc div.c -c<br><br><span class="hljs-section">main.o:main.c</span><br>        gcc main.c -c<br><br><span class="hljs-section">sub.o:sub.c</span><br>        gcc sub.c -c<br><br><span class="hljs-section">mult.o:mult.c</span><br>        gcc mult.c -c<br></code></pre></td></tr></table></figure><p>使用模式匹配后：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">calc:add.o  div.o  main.o  mult.o  sub.o</span><br>        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc<br><br><span class="hljs-section">%.o:%.c</span><br>gcc <span class="hljs-variable">$&lt;</span> -c<br></code></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h2><p>函数功能:获取指定目录下指定类型的文件名，其返回值是以空格分割的指定目录下符合条件的文件名列表。<br>.<br>├── include<br>│   └── head.h<br>├── main.c<br>├── Makefile<br>└── src<br>    ├── add.c<br>    ├── div.c<br>    ├── mult.c<br>    └── sub.c</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 语法：</span><br><span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> 目录列表)</span><br><br><span class="hljs-comment"># 示例：</span><br>src=<span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.c ./src/*.c)</span><br></code></pre></td></tr></table></figure><h2 id="patsubst"><a href="#patsubst" class="headerlink" title="patsubst"></a>patsubst</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 语法：</span><br><span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> &lt;pattern&gt;, &lt;replacement&gt;, &lt;text&gt;)</span><br><br><span class="hljs-comment"># 示例：将变量src中的所有文件名的后缀替换成.o</span><br>obj=<span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o, <span class="hljs-variable">$(src)</span>)</span><br></code></pre></td></tr></table></figure><h1 id="makefile示例"><a href="#makefile示例" class="headerlink" title="makefile示例"></a>makefile示例</h1><p>.<br>├── include<br>│   └── head.h<br>├── main.c<br>├── Makefile<br>└── src<br>    ├── add.c<br>    ├── div.c<br>    ├── mult.c<br>    └── sub.c</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 定义变量</span><br>target=main<br>include=./<span class="hljs-keyword">include</span><br>CFLAGS=-O3 -g -Wall<br><br><span class="hljs-comment"># 搜索源文件</span><br>src=<span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> *.c ./src/*.c)</span><br><br><span class="hljs-comment"># 替换成.o结尾</span><br>obj=<span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c, %.o, <span class="hljs-variable">$(src)</span>)</span><br><br><span class="hljs-comment"># 对汇编文件进行链接</span><br><span class="hljs-variable">$(target)</span>:<span class="hljs-variable">$(obj)</span><br>   gcc <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-comment"># 对源文件进行逐个汇编</span><br><span class="hljs-section">%.o:%.c</span><br>   gcc <span class="hljs-variable">$&lt;</span> -c -I<span class="hljs-variable">$(include)</span> -o <span class="hljs-variable">$@</span><br><br><span class="hljs-comment"># clean</span><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><span class="hljs-section">clean:</span><br>   rm <span class="hljs-variable">$(obj)</span> <span class="hljs-variable">$(target)</span> -f<br></code></pre></td></tr></table></figure><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="递归扩展变量（-）"><a href="#递归扩展变量（-）" class="headerlink" title="递归扩展变量（&#x3D;）"></a>递归扩展变量（&#x3D;）</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: all</span><br>foo = <span class="hljs-variable">$(bar)</span><br>bar = <span class="hljs-variable">$(hello)</span><br>hello = world<br><br><span class="hljs-section">all:</span><br>    @echo <span class="hljs-variable">$(foo)</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make<br>world<br></code></pre></td></tr></table></figure><h2 id="简单扩展变量（-）"><a href="#简单扩展变量（-）" class="headerlink" title="简单扩展变量（:&#x3D;）"></a>简单扩展变量（:&#x3D;）</h2><p>对于这种变量，make只对其进行一次扫描和扩展。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: all</span><br>x = foo<br>y = <span class="hljs-variable">$(x)</span> b<br>x = later<br><br>xx := foo<br>yy := <span class="hljs-variable">$(xx)</span> b<br>xx := later<br><br><span class="hljs-section">all:</span><br>    $echo <span class="hljs-string">&quot;x = <span class="hljs-variable">$(y)</span>, xx = <span class="hljs-variable">$(yy)</span>&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make<br>x = later b, xx = foo b<br></code></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://subingwen.cn/linux/makefile/">爱编程的大丙</a><br><a href="https://www.cnblogs.com/paul-617/p/15501875.html">makefile详解</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IO多路复用</title>
    <link href="/2025/02/22/NetworkCommunications/IOMultiplexing/"/>
    <url>/2025/02/22/NetworkCommunications/IOMultiplexing/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol><li>文件描述符</li><li>IO多路复用<ol><li>select</li><li>poll</li><li>epoll</li></ol></li></ol><span id="more"></span><h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><h3 id="文件描述符-1"><a href="#文件描述符-1" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>服务器端有两种文件描述符：负责监听的文件描述符，负责通信的文件描述符：</p><p>监听文件描述符：</p><ol><li>Read Buffer：存储客户端的连接请求 -&gt; accept()</li><li>Write Buffer：当服务器接收到客户端的连接请求时，需要对其进行回应</li></ol><p>通信文件描述符：</p><ol><li>Read Buffer：存储客户端发送的通信数据 -&gt; read()</li><li>Write Buffer：存储要给客户端发送的数据 -&gt; write()</li></ol><p>accept(), read(), write()三个函数都是阻塞函数，以accept()为例：</p><ul><li>当Read Buffer内有数据时即有连接请求时，解除阻塞，建立连接；</li><li>当Read Buffer内没有数据时，则一直阻塞；</li></ul><p>在单线程下，是不能同时处理这三个函数的，如果有一个函数发生阻塞，另外两个也只能阻塞。解决办法：</p><ol><li>多线程</li><li>多进程</li><li>IO多路复用</li></ol><h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>使用IO多路复用函数委托内核检测服务器端所有的文件描述符（通信和监听两类)，这个检测过程会导致进程&#x2F;线程阻塞，如果检测到已就绪的文件描述符就解除阻塞，并将这些已就绪的文件描述符传出。相当于本来有三个地方会阻塞，现在把三个集合到一起进行检测，从而只有一个地方会阻塞，这样在阻塞期间可以同时对三者进行检测。</p><p>处理流程：</p><ol><li>用IO多路复用函数委托内核检测服务器端所有的文件描述符</li><li>根据类型对传出的所有已就绪文件描述符进行判断，并做出不同的处理<ol><li>监听的文件描述符：和客户端建立连接<ol><li>此时调用accept()是不会导致程序阻塞的，因为IO多路复用函数已经检测过了，确定此时监听的文件描述符是就绪的即有新的请求</li></ol></li><li>通信的文件描述符：调用通信函数和已建立连接的客户端通信<ol><li>此时调用read()&#x2F;recv()函数不会阻塞程序，因为通信的文件描述符是就绪的即读缓冲区以有数据</li><li>此时调用write()&#x2F;send()函数不会阻塞程序，因为写缓存不满，可以写数据</li></ol></li></ol></li><li>对文件描述符进行下一轮的检测，循环往复</li></ol><p>与多进程和多线程技术相比，I&#x2F;O多路复用技术的最大优势是系统开销小，系统不必创建进程&#x2F;线程，也不必维护这些进程&#x2F;线程，从而大大减小了系统的开销。</p><h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><ol><li>可以跨平台；</li><li>使用select能够检测的最大文件描述符个数有上限，默认是1024；</li><li>fd_set不可以重用；</li><li>待测集合需要频繁在用户区和内核区之间进行数据的拷贝；</li><li>内核对select传递进来的待测集合的检测方式是线性的；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> &#123;<br>    <span class="hljs-type">time_t</span>      tv_sec;         <span class="hljs-comment">/* seconds */</span><br>    <span class="hljs-type">suseconds_t</span> tv_usec;        <span class="hljs-comment">/* microseconds */</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="hljs-keyword">struct</span> timeval * timeout)</span></span>;<br></code></pre></td></tr></table></figure><p>函数参数：</p><ul><li>nfds：委托内核检测的这三个集合中最大的文件描述符加1<ul><li>内核需要现行便利这些集合中的文件描述符，这个值是循环结束的条件；</li><li>在Windows中这个参数是无效的，指定为-1</li></ul></li><li>readfds：文件描述符的集合，内核只检测这个集合中文件描述符对应的读缓冲区<ul><li>传入传出参数，如果不需要可以指定为NULL</li></ul></li><li>writefds：文件描述符的集合, 内核只检测这个集合中文件描述符对应的写缓冲区<ul><li>传入传出参数，如果不需要使用这个参数可以指定为NULL</li></ul></li><li>exceptfds：文件描述符的集合, 内核检测集合中文件描述符是否有异常状态<ul><li>传入传出参数，如果不需要使用这个参数可以指定为NULL</li></ul></li><li>timeout：超时时长，用来强制解除select()函数的阻塞的<ul><li>NULL：函数检测不到就绪的文件描述符会一直阻塞。</li><li>等待固定时长（秒）：函数检测不到就绪的文件描述符，在指定时长之后强制解除阻塞，函数返回0</li><li>不等待：函数不会阻塞，直接将该参数对应的结构体初始化为0即可。</li></ul></li></ul><p>返回值：</p><ul><li>大于0：成功，返回集合中已就绪的文件描述符的总个数</li><li>等于-1：函数调用失败</li><li>等于0：超时，没有检测到就绪的文件描述符</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将文件描述符fd从set集合中删除，即将fd对应的标志位置设置为0</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FD_CLR</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *set)</span></span>;<br><br><span class="hljs-comment">// 判断文件描述符fd是否在set集合中，即读取fd对应的标志位是否为1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FD_ISSET</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *set)</span></span>;<br><br><span class="hljs-comment">// 将文件描述符fd添加到set集合中，即将fd对应的标志位设置为1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FD_SET</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, fd_set *set)</span></span>;<br><br><span class="hljs-comment">// 将set集合中所有的文件描述符对应的标志为设置为0</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FD_ZERO</span><span class="hljs-params">(fd_set *set)</span></span>;<br></code></pre></td></tr></table></figure><h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h1>]]></content>
    
    
    <categories>
      
      <category>NetworkCommunications</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git2</title>
    <link href="/2025/02/22/MissingSemester/git-2/"/>
    <url>/2025/02/22/MissingSemester/git-2/</url>
    
    <content type="html"><![CDATA[<ol><li>git核心概念</li><li>整体流程</li><li>分析</li><li>命令大全</li></ol><span id="more"></span><h1 id="git核心概念"><a href="#git核心概念" class="headerlink" title="git核心概念"></a>git核心概念</h1><ul><li>工作目录：项目目录；</li><li>暂存区：准备下次提交的文件列表；</li><li>仓库：存储项目历史记录的地方，可以是本地的，也可以是远程服务器上的；</li><li>本地仓库：本地电脑存储历史记录的区域；</li><li>远程仓库：托管在服务器上的代码副本；</li></ul><h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1. 创建仓库"></a>1. 创建仓库</h3><p>使用当前目录作为Git仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git init<br></code></pre></td></tr></table></figure><p>该命令执行完后会在当前目录生成一个.git目录。</p><h3 id="2-新建本地文件"><a href="#2-新建本地文件" class="headerlink" title="2. 新建本地文件"></a>2. 新建本地文件</h3><p>本地增加文件url.c、README.md，使用git status查看文件状态，有2个未跟踪的在文件</p><p><img src="/../../image/git-1.png" alt="img"></p><h3 id="3-提交文件到暂存区"><a href="#3-提交文件到暂存区" class="headerlink" title="3. 提交文件到暂存区"></a>3. 提交文件到暂存区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add .<br></code></pre></td></tr></table></figure><p>添加所有文件到暂存区。</p><h3 id="4-提交改动"><a href="#4-提交改动" class="headerlink" title="4. 提交改动"></a>4. 提交改动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit -m <span class="hljs-string">&quot;代码提交信息&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/../../image/git-2.png" alt="img"></p><p>新增的两个文件，已经提交到HEAD，但是还没到远端仓库。</p><h3 id="5-推送到远端仓库"><a href="#5-推送到远端仓库" class="headerlink" title="5. 推送到远端仓库"></a>5. 推送到远端仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin master<br></code></pre></td></tr></table></figure><p>如果你还没有克隆现有仓库，并欲将你的仓库 连接到某个远程服务器 ，你可以使用如下命令添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin &lt;server&gt;<br></code></pre></td></tr></table></figure><p>这样就可以将改动推送到所添加的服务器上了。</p><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><p>分支是用来将特性开发绝缘开来的，在创建仓库的时候，master时默认的分支。</p><p>在其他分支上进行开发，完成后再将它们合并到主分支上。</p><h3 id="1-查看分支"><a href="#1-查看分支" class="headerlink" title="1. 查看分支"></a>1. 查看分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch<br></code></pre></td></tr></table></figure><p>没有参数时，git branch会列出在本地的分支。</p><h3 id="2-创建分支"><a href="#2-创建分支" class="headerlink" title="2. 创建分支"></a>2. 创建分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch new-branch-name<br></code></pre></td></tr></table></figure><p><img src="/../../image/git-3.png" alt="img"></p><ol><li>多了一个分支test</li><li>当前分支为主分支master，前面的*表示活动分支</li></ol><h3 id="3-切换分支"><a href="#3-切换分支" class="headerlink" title="3. 切换分支"></a>3. 切换分支</h3><p>刚刚的branch命令只是单纯的创建一个新分支。使用checkout命令来更改分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>或者使用以下命令，创建一个分支并同时切换过去（相当于上面两步合在一起)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h3 id="4-分支合并"><a href="#4-分支合并" class="headerlink" title="4. 分支合并"></a>4. 分支合并</h3><p>在分支test上进行修改并提交，当分支任务完成后，切换到主分支并合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout master<br>$ git merge <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p><img src="/../../image/git-4.png" alt="img"></p><ol><li>合并之后可以看到，主分支多了一个新的commit</li><li>对其他分支的更改不会反映在主分支上。如果想将更改提交到主分支，则需切换回master分支，然后使用合并。</li></ol><h3 id="5-删除分支"><a href="#5-删除分支" class="headerlink" title="5. 删除分支"></a>5. 删除分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -d <span class="hljs-built_in">test</span><br>git branch -D <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h2 id="替换本地改动"><a href="#替换本地改动" class="headerlink" title="替换本地改动"></a>替换本地改动</h2><p>如果操作失误，可以使用如下命令替换掉本地改动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout &lt;filename&gt;<br></code></pre></td></tr></table></figure><p>此命令会使用HEAD中的最新内容替换掉当前工作目录中的文件，已添加到暂存区的改动以及新文件不会受到影响。</p><p><img src="/../../image/gitcheckout.bmp" alt="img"></p><p>当我修改了一个文件，该文件还没有提交到暂存区，我想撤回修改，则可以执行该命令。</p><blockquote><p>假如想丢弃在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将本地主分支指向它：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git fetch origin<br>$ git reset --hard origin/master<br></code></pre></td></tr></table></figure><h2 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h2><p>当我们不想要之前提交的修改时，就会用到这个命令，比如一个错误的提交或者引入一个bug的提交，这个时候就可以使用命令：<code>git reset</code>，它可以让我们不再使用当前台面上的文件，让我们可以控制HEAD应该指向的位置。</p><h3 id="1-软重置"><a href="#1-软重置" class="headerlink" title="1. 软重置"></a>1. 软重置</h3><p>软重置会将HEAD移动至指定的提交，而不会移除该提交之后加入的修改；</p><p><img src="/../../image/gitresetsoft.bmp" alt="img"></p><p>通过 <code>git status</code>可以看到，仍然可以访问到在之前提交上做过的修改，可以修复这些文件，之后再重新提交。</p><h3 id="2-硬重置"><a href="#2-硬重置" class="headerlink" title="2. 硬重置"></a>2. 硬重置</h3><p>有时候我们并不想保留特定提交引入的修改，且再也不需要访问他们了，Git应该直接将整体状态直接重置到特定提交之前的状态：包括在工作目录中和暂存文件上的修改。</p><p><img src="/../../image/gitresethard.bmp" alt="img"></p><p>可以看到所有提交的信息都已经被移除了，工作区文件恢复到恢复到特定状态，打开文件可以看到所有添加的信息都不存在了。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch<br>* station-computer<br><br>$ git branch -a<br>* station-computer<br>  remotes/origin/master<br>  remotes/origin/station-computer<br>  remotes/origin/zhm-old-computer<br></code></pre></td></tr></table></figure><p>当前本地仓库只有一个名为 <code>station-computer</code>的分支，并且处于激活状态；</p><p>远程仓库 <code>origin</code>有三个分支：<code>master</code>，<code>station-computer</code>，<code>zhm-old-computer</code>；</p><h3 id="1-为什么-git-branch只显示一个本地分支？"><a href="#1-为什么-git-branch只显示一个本地分支？" class="headerlink" title="1. 为什么 git branch只显示一个本地分支？"></a>1. 为什么 <code>git branch</code>只显示一个本地分支？</h3><p><code>git branch</code>命令默认只显示本地分支，在当前仓库中，只有一个本地分支 <code>station-computer</code>;</p><h3 id="2-如何操作其他远程分支？"><a href="#2-如何操作其他远程分支？" class="headerlink" title="2. 如何操作其他远程分支？"></a>2. 如何操作其他远程分支？</h3><h4 id="操作远程-master分支"><a href="#操作远程-master分支" class="headerlink" title="操作远程 master分支"></a>操作远程 <code>master</code>分支</h4><ol><li><p>创建并切换到本地 <code>master</code>分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b master origin/master<br></code></pre></td></tr></table></figure><p>这条命令会在本地创建一个新的 <code>master</code>分支，并将其与远程 <code>master</code>分支建立跟踪关系，然后切换到该分支。</p></li><li><p>拉取远程 <code>master</code>分支的最新变更</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin master<br></code></pre></td></tr></table></figure><p>这条命令会拉取远程 <code>master</code>分支的最新变更并合并到本地 <code>master</code>分支。</p></li></ol><h4 id="操作远程-zhm-old-computer分支"><a href="#操作远程-zhm-old-computer分支" class="headerlink" title="操作远程 zhm-old-computer分支"></a>操作远程 <code>zhm-old-computer</code>分支</h4><ol><li><p>创建并切换到本地 <code>zhm-old-computer</code>分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b zhm-old-computer origin/zhm-old-computer<br></code></pre></td></tr></table></figure><p>这条命令会在本地创建一个新的 <code>zhm-old-computer</code>分支，并将其与远程的 <code>zhm-old-computer</code>分支建立跟踪关系，然后切换到该分支。</p></li><li><p>拉取远程 <code>zhm-old-computer</code>分支的最新变更</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git pull origin zhm-old-computer<br></code></pre></td></tr></table></figure><p>这条命令会拉取远程 <code>zhm-old-computer</code>分支的最新变更并合并到本地 <code>zhm-old-computer</code>分支。</p></li></ol><h3 id="3-其他操作"><a href="#3-其他操作" class="headerlink" title="3. 其他操作"></a>3. 其他操作</h3><ul><li>删除远程分支<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin --delete master<br>$ git push origin --delete zhm-old-computer<br></code></pre></td></tr></table></figure></li></ul><h1 id="命令大全"><a href="#命令大全" class="headerlink" title="命令大全"></a>命令大全</h1><h3 id="1-仓库"><a href="#1-仓库" class="headerlink" title="1. 仓库"></a>1. 仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在当前目录新建一个Git代码库</span><br>$ git init<br><br><span class="hljs-comment"># 新建一个目录，将其初始化为Git代码库</span><br>$ git init [project-name]<br><br><span class="hljs-comment"># 下载一个项目和它的整个代码历史</span><br>$ git <span class="hljs-built_in">clone</span> [url]<br></code></pre></td></tr></table></figure><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 显示当前的Git配置</span><br>$ git config --list<br><br><span class="hljs-comment"># 编辑Git配置文件</span><br>$ git config -e [--global]<br><br><span class="hljs-comment"># 设置提交代码时的用户信息</span><br>$ git config [--global] user.name <span class="hljs-string">&quot;[name]&quot;</span><br>$ git config [--global] user.email <span class="hljs-string">&quot;[email address]&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-增加-删除文件"><a href="#3-增加-删除文件" class="headerlink" title="3. 增加&#x2F;删除文件"></a>3. 增加&#x2F;删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 添加指定文件到暂存区</span><br>$ git add [file1] [file2] ...<br><br><span class="hljs-comment"># 添加指定目录到暂存区，包括子目录</span><br>$ git add [<span class="hljs-built_in">dir</span>]<br><br><span class="hljs-comment"># 添加当前目录的所有文件到暂存区</span><br>$ git add .<br><br><span class="hljs-comment"># 添加每个变化前，都会要求确认</span><br><span class="hljs-comment"># 对于同一个文件的多处变化，可以实现分次提交</span><br>$ git add -p<br><br><span class="hljs-comment"># 删除工作区文件，并且将这次删除放入暂存区</span><br>$ git <span class="hljs-built_in">rm</span> [file1] [file2] ...<br><br><span class="hljs-comment"># 停止追踪指定文件，但该文件会保留在工作区</span><br>$ git <span class="hljs-built_in">rm</span> --cached [file]<br><br><span class="hljs-comment"># 改名文件，并且将这个改名放入暂存区</span><br>$ git <span class="hljs-built_in">mv</span> [file-original] [file-renamed]<br></code></pre></td></tr></table></figure><h3 id="4-代码提交"><a href="#4-代码提交" class="headerlink" title="4. 代码提交"></a>4. 代码提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 提交暂存区到仓库区</span><br>$ git commit -m [message]<br><br><span class="hljs-comment"># 提交暂存区的指定文件到仓库区</span><br>$ git commit [file1] [file2] ... -m [message]<br><br><span class="hljs-comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br>$ git commit -a<br><br><span class="hljs-comment"># 提交时显示所有diff信息</span><br>$ git commit -v<br><br><span class="hljs-comment"># 使用一次新的commit，替代上一次提交</span><br><span class="hljs-comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br>$ git commit --amend -m [message]<br><br><span class="hljs-comment"># 重做上一次commit，并包括指定文件的新变化</span><br>$ git commit --amend [file1] [file2] ...<br></code></pre></td></tr></table></figure><h3 id="5-分支"><a href="#5-分支" class="headerlink" title="5. 分支"></a>5. 分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有本地分支</span><br>$ git branch<br><br><span class="hljs-comment"># 列出所有远程分支</span><br>$ git branch -r<br><br><span class="hljs-comment"># 列出所有本地分支和远程分支</span><br>$ git branch -a<br><br><span class="hljs-comment"># 新建一个分支，但依然停留在当前分支</span><br>$ git branch [branch-name]<br><br><span class="hljs-comment"># 新建一个分支，并切换到该分支</span><br>$ git checkout -b [branch]<br><br><span class="hljs-comment"># 新建一个分支，指向指定commit</span><br>$ git branch [branch] [commit]<br><br><span class="hljs-comment"># 新建一个分支，与指定的远程分支建立追踪关系</span><br>$ git branch --track [branch] [remote-branch]<br><br><span class="hljs-comment"># 切换到指定分支，并更新工作区</span><br>$ git checkout [branch-name]<br><br><span class="hljs-comment"># 切换到上一个分支</span><br>$ git checkout -<br><br><span class="hljs-comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br>$ git branch --set-upstream [branch] [remote-branch]<br><br><span class="hljs-comment"># 合并指定分支到当前分支</span><br>$ git merge [branch]<br><br><span class="hljs-comment"># 选择一个commit，合并进当前分支</span><br>$ git cherry-pick [commit]<br><br><span class="hljs-comment"># 删除分支</span><br>$ git branch -d [branch-name]<br><br><span class="hljs-comment"># 删除远程分支</span><br>$ git push origin --delete [branch-name]<br>$ git branch -dr [remote/branch]<br></code></pre></td></tr></table></figure><h3 id="6-标签"><a href="#6-标签" class="headerlink" title="6. 标签"></a>6. 标签</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有tag</span><br>$ git tag<br><br><span class="hljs-comment"># 新建一个tag在当前commit</span><br>$ git tag [tag]<br><br><span class="hljs-comment"># 新建一个tag在指定commit</span><br>$ git tag [tag] [commit]<br><br><span class="hljs-comment"># 删除本地tag</span><br>$ git tag -d [tag]<br><br><span class="hljs-comment"># 删除远程tag</span><br>$ git push origin :refs/tags/[tagName]<br><br><span class="hljs-comment"># 查看tag信息</span><br>$ git show [tag]<br><br><span class="hljs-comment"># 提交指定tag</span><br>$ git push [remote] [tag]<br><br><span class="hljs-comment"># 提交所有tag</span><br>$ git push [remote] --tags<br><br><span class="hljs-comment"># 新建一个分支，指向某个tag</span><br>$ git checkout -b [branch] [tag]<br></code></pre></td></tr></table></figure><h3 id="7-查看信息"><a href="#7-查看信息" class="headerlink" title="7. 查看信息"></a>7. 查看信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 显示有变更的文件</span><br>$ git status<br><br><span class="hljs-comment"># 显示当前分支的版本历史</span><br>$ git <span class="hljs-built_in">log</span><br><br><span class="hljs-comment"># 显示commit历史，以及每次commit发生变更的文件</span><br>$ git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span><br><br><span class="hljs-comment"># 搜索提交历史，根据关键词</span><br>$ git <span class="hljs-built_in">log</span> -S [keyword]<br><br><span class="hljs-comment"># 显示某个commit之后的所有变动，每个commit占据一行</span><br>$ git <span class="hljs-built_in">log</span> [tag] HEAD --pretty=format:%s<br><br><span class="hljs-comment"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br>$ git <span class="hljs-built_in">log</span> [tag] HEAD --grep feature<br><br><span class="hljs-comment"># 显示某个文件的版本历史，包括文件改名</span><br>$ git <span class="hljs-built_in">log</span> --follow [file]<br>$ git whatchanged [file]<br><br><span class="hljs-comment"># 显示指定文件相关的每一次diff</span><br>$ git <span class="hljs-built_in">log</span> -p [file]<br><br><span class="hljs-comment"># 显示过去5次提交</span><br>$ git <span class="hljs-built_in">log</span> -5 --pretty --oneline<br><br><span class="hljs-comment"># 显示所有提交过的用户，按提交次数排序</span><br>$ git shortlog -sn<br><br><span class="hljs-comment"># 显示指定文件是什么人在什么时间修改过</span><br>$ git blame [file]<br><br><span class="hljs-comment"># 显示暂存区和工作区的差异</span><br>$ git diff<br><br><span class="hljs-comment"># 显示暂存区和上一个commit的差异</span><br>$ git diff --cached [file]<br><br><span class="hljs-comment"># 显示工作区与当前分支最新commit之间的差异</span><br>$ git diff HEAD<br><br><span class="hljs-comment"># 显示两次提交之间的差异</span><br>$ git diff [first-branch]...[second-branch]<br><br><span class="hljs-comment"># 显示今天你写了多少行代码</span><br>$ git diff --shortstat <span class="hljs-string">&quot;@&#123;0 day ago&#125;&quot;</span><br><br><span class="hljs-comment"># 显示某次提交的元数据和内容变化</span><br>$ git show [commit]<br><br><span class="hljs-comment"># 显示某次提交发生变化的文件</span><br>$ git show --name-only [commit]<br><br><span class="hljs-comment"># 显示某次提交时，某个文件的内容</span><br>$ git show [commit]:[filename]<br><br><span class="hljs-comment"># 显示当前分支的最近几次提交</span><br>$ git reflog<br></code></pre></td></tr></table></figure><h3 id="8-远程同步"><a href="#8-远程同步" class="headerlink" title="8. 远程同步"></a>8. 远程同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下载远程仓库的所有变动</span><br>$ git fetch [remote]<br><br><span class="hljs-comment"># 显示所有远程仓库</span><br>$ git remote -v<br><br><span class="hljs-comment"># 显示某个远程仓库的信息</span><br>$ git remote show [remote]<br><br><span class="hljs-comment"># 增加一个新的远程仓库，并命名</span><br>$ git remote add [shortname] [url]<br><br><span class="hljs-comment"># 取回远程仓库的变化，并与本地分支合并</span><br>$ git pull [remote] [branch]<br><br><span class="hljs-comment"># 上传本地指定分支到远程仓库</span><br>$ git push [remote] [branch]<br><br><span class="hljs-comment"># 强行推送当前分支到远程仓库，即使有冲突</span><br>$ git push [remote] --force<br><br><span class="hljs-comment"># 推送所有分支到远程仓库</span><br>$ git push [remote] --all<br></code></pre></td></tr></table></figure><h3 id="9-撤销"><a href="#9-撤销" class="headerlink" title="9.撤销"></a>9.撤销</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 恢复暂存区的指定文件到工作区</span><br>$ git checkout [file]<br><br><span class="hljs-comment"># 恢复某个commit的指定文件到暂存区和工作区</span><br>$ git checkout [commit] [file]<br><br><span class="hljs-comment"># 恢复暂存区的所有文件到工作区</span><br>$ git checkout .<br><br><span class="hljs-comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br>$ git reset [file]<br><br><span class="hljs-comment"># 重置暂存区与工作区，与上一次commit保持一致</span><br>$ git reset --hard<br><br><span class="hljs-comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br>$ git reset [commit]<br><br><span class="hljs-comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br>$ git reset --hard [commit]<br><br><span class="hljs-comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br>$ git reset --keep [commit]<br><br><span class="hljs-comment"># 新建一个commit，用来撤销指定commit</span><br><span class="hljs-comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br>$ git revert [commit]<br><br><span class="hljs-comment"># 暂时将未提交的变化移除，稍后再移入</span><br>$ git stash<br>$ git stash pop<br></code></pre></td></tr></table></figure><h3 id="10-其他"><a href="#10-其他" class="headerlink" title="10. 其他"></a>10. 其他</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成一个可供发布的压缩包</span><br>$ git archive<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络编程代码</title>
    <link href="/2025/02/22/NetworkCommunications/code/"/>
    <url>/2025/02/22/NetworkCommunications/code/</url>
    
    <content type="html"><![CDATA[<h1 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h1><ol><li>单线程以及多线程C&#x2F;S</li><li>使用select实现单线程以及多线程C&#x2F;S</li><li>使用poll实现单线程以及多线程C&#x2F;S</li><li>使用epoll实现单线程以及多线程C&#x2F;S</li></ol><span id="more"></span><h1 id="单线程C-S"><a href="#单线程C-S" class="headerlink" title="单线程C&#x2F;S"></a>单线程C&#x2F;S</h1><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PORT 25500</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 创建监听套接字socket</span><br>    <span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(sockfd == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 绑定本地IP和端口bind</span><br>    sockaddr_in addr;<br>    addr.sin_family = AF_INET;<br>    addr.sin_port = <span class="hljs-built_in">htons</span>(PORT);<br>    addr.sin_addr.s_addr = INADDR_ANY;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">bind</span>(sockfd, (sockaddr*)&amp;addr, <span class="hljs-built_in">sizeof</span>(addr));<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;bind&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置监听listen</span><br>    ret = <span class="hljs-built_in">listen</span>(sockfd, <span class="hljs-number">128</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;listen&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 建立连接</span><br>    <span class="hljs-type">socklen_t</span> addrlen = <span class="hljs-built_in">sizeof</span>(addr);<br>    <span class="hljs-type">int</span> cfd = <span class="hljs-built_in">accept</span>(sockfd, (sockaddr*)&amp;addr, &amp;addrlen);<br>    <span class="hljs-keyword">if</span>(cfd == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;accept&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buffer));<br>            <span class="hljs-type">ssize_t</span> len = <span class="hljs-built_in">read</span>(cfd, buffer, <span class="hljs-built_in">sizeof</span>(buffer));<br>            <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;read&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)&#123;<br>                std::cout&lt;&lt;<span class="hljs-string">&quot;客户端断开连接....&quot;</span>&lt;&lt;std::endl;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; ++i)&#123;<br>                    <span class="hljs-keyword">if</span>(buffer[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; buffer[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) &#123;<br>                        buffer[i] -= <span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-string">&#x27;A&#x27;</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-built_in">write</span>(cfd, buffer, len);<br>            &#125;<br>        &#125;<br>    &#125;<br>    ret = <span class="hljs-built_in">close</span>(sockfd);<br>    ret = <span class="hljs-built_in">close</span>(cfd);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;close&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><code>#include&lt;arpa/inet.h&gt;</code>包含了一些字节序转换函数；</li><li><code>#include&lt;sys/socket.h&gt;</code>包含了套接字通信函数；</li><li><code>#include&lt;unistd.h&gt;</code>包含了read，write，close等函数；</li><li><code>#include&lt;string.h&gt;</code>包含了memset等函数；</li><li>文件描述符会按照从小到达的顺序创建，比如这个程序sockfd将为3，cfd将为4；</li><li>文件描述符0为stdin：标准输入；</li><li>文件描述符1为stdout：标准输出；</li><li>文件描述符2为stderr：标准错误输出；</li><li>函数具体参数没必要特意去记，熟练使用man文档查阅</li></ol><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PORT 25500</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> serverIP <span class="hljs-string">&quot;49.123.87.90&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> cfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(cfd == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> ret;<br>    sockaddr_in addr;<br>    addr.sin_family = AF_INET;<br>    addr.sin_port = <span class="hljs-built_in">htons</span>(PORT);<br>    <span class="hljs-comment">// addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);</span><br>    ret = <span class="hljs-built_in">inet_pton</span>(AF_INET, serverIP, &amp;addr.sin_addr.s_addr);<br>    ret = <span class="hljs-built_in">connect</span>(cfd, (sockaddr*)&amp;addr, <span class="hljs-built_in">sizeof</span>(addr));<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;connect&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> sendbuffer[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">char</span> recvbuffer[<span class="hljs-number">1024</span>];<br>        <span class="hljs-built_in">sprintf</span>(sendbuffer, <span class="hljs-string">&quot;data: %d\n&quot;</span>, i++);<br>        <span class="hljs-built_in">write</span>(cfd, sendbuffer, <span class="hljs-built_in">strlen</span>(sendbuffer)<span class="hljs-number">+1</span>);<br>        <span class="hljs-built_in">read</span>(cfd, recvbuffer, <span class="hljs-built_in">sizeof</span>(recvbuffer));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;send buf: %s&quot;</span>, sendbuffer);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv buf: %s\n&quot;</span>, recvbuffer);<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    ret = <span class="hljs-built_in">close</span>(cfd);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;close&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>ip从主机字节序转换到网络字节序<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// way-1</span><br>addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br><br><span class="hljs-comment">// way-2</span><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">inet_pton</span>(AF_INET, serverIP, &amp;addr.sin_addr.s_addr);<br></code></pre></td></tr></table></figure></li></ol><h1 id="多线程C-S"><a href="#多线程C-S" class="headerlink" title="多线程C&#x2F;S"></a>多线程C&#x2F;S</h1>]]></content>
    
    
    <categories>
      
      <category>NetworkCommunications</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>socket</title>
    <link href="/2025/02/22/NetworkCommunications/socket_Linux/"/>
    <url>/2025/02/22/NetworkCommunications/socket_Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="多客户端通讯问题"><a href="#多客户端通讯问题" class="headerlink" title="多客户端通讯问题"></a>多客户端通讯问题</h1><ul><li>多线程</li><li>多进程</li><li>IO转接+多线程</li><li>libevent</li></ul><span id="more"></span><h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Linux</span><br>$ ifconfig<br><br><span class="hljs-comment"># Windows</span><br>$ ipconfig<br><br><span class="hljs-comment"># 测试网络</span><br>$ ping www.baidu.com<br></code></pre></td></tr></table></figure><h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><p>socket是用于连接客户端和服务器进程的中间件。二者通过socket向网络发出请求或者回应，完成通信过程。</p><ul><li>流式套接字（SOCK_STREAM）</li><li>数据报套接字（SOCK_DGRAM）</li><li>原始套接字（SOCK_RAW）</li></ul><p>服务端（server）：建立socket，申明自身的IP和Port并绑定到socket，使用listen监听，然后不断用accept去查看是否有连接。如果有，捕获socket并通过recv获取消息的内容，完成通信之后调用close关闭对应的accept到的socket。</p><p>客户端（client）：建立socket，通过IP和Port确定目标服务器，使用connect连接到服务器，send发送消息，等待处理，完成通信后调用close关闭socket。</p><h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><p>端口是定位主机上某一个进程的。unsigned short（0-65535）<br>计算机中所有的进程都需要关联一个端口吗？一个端口可以被重复使用吗？</p><ol><li>不需要，如果这个进程不需要进行网络通信，那么进程就不需要绑定端口。</li><li>一个端口只能给某一个进程使用，多个进程不能够同时使用同一个端口。</li></ol><p>网络分层模型：</p><ul><li>接口层</li><li>网络层（IP）</li><li>传输层（TCP&#x2F;UDP）</li><li>应用层（HTTP）</li></ul><p>网络通信中三个重要的组成部分：</p><ul><li>服务器</li><li>客户端</li><li>IP，端口，通信数据</li></ul><p>字节序：</p><ul><li>大端（网络字节序）：数据低位存内存高位</li><li>小端（主机字节序）：数据低位存内存低位</li></ul><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">例如：<span class="hljs-number">0x12345678</span><br>大端：<span class="hljs-number">0x12345678</span><br>小端：<span class="hljs-number">0x78563412</span><br></code></pre></td></tr></table></figure><h2 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-comment">// 主机字节序转网络字节序（小端转大端）</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">htons</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> hostshort)</span>;<br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">htonl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> hostlong)</span>;<br><br><span class="hljs-comment">// 网络字节序转主机字节序（大端转小端）</span><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">ntohs</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> netshort)</span>;<br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">ntohl</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> netlong)</span>;<br></code></pre></td></tr></table></figure><p>IPv4是32位的（uint32_t）<br>端口是16位的（uint16_t）</p><h2 id="IP地址转换"><a href="#IP地址转换" class="headerlink" title="IP地址转换"></a>IP地址转换</h2><p>IP地址本质上是一个整型数，但是在使用中是通过一个字符串来描述的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-comment">// 主机字节序的IP地址转换为网络字节序IP地址</span><br><span class="hljs-comment">// 主机字节序的IP地址是一个字符串</span><br><span class="hljs-comment">// 网络字节序的IP地址是一个整型</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">inet_pton</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* src, <span class="hljs-type">void</span>* dst)</span>;<br></code></pre></td></tr></table></figure><ol><li>参数<ul><li>af：地址族协议<ul><li>AF_INET：ipv4</li><li>AF_INET6：ipv6</li></ul></li><li>src：传入参数，点分十进制的ip地址</li><li>dst：传出参数，大端整型IP</li></ul></li><li>返回值：成功返回1，失败返回0&#x2F;-1</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-comment">// 网络字节序IP地址转换为主机字节序IP地址</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title function_">inet_ntop</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* src, <span class="hljs-type">char</span> *dst, <span class="hljs-type">socklen_t</span> size)</span>;<br></code></pre></td></tr></table></figure><ol><li>参数<ul><li>af：地址族协议<ul><li>AF_INET：ipv4</li><li>AF_INET6：ipv6</li></ul></li><li>src：传入参数,这个指针指向的内存中存储了大端的整形IP地址</li><li>dst：传出参数,存储转换得到的小端的点分十进制的IP地址</li><li>size: 修饰dst参数的,标记dst指向的内存中最多可以存储多少个字节</li></ul></li><li>返回值：<ul><li>成功: 指针指向第三个参数对应的内存地址,通过返回值也可以直接取出转换得到的IP字符串。</li><li>失败：返回NULL</li></ul></li></ol><h2 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h2><p>TCP是一个面向连接的，安全的，流式传输协议。（传输层协议）</p><ul><li>面向连接：是一个双向连接，通过三次握手完成连接，通过四次挥手断开连接；</li><li>安全：TCP通信过程中，会对发送的每一个数据包进行校验，如果发现数据丢失，会自动重传；</li><li>流式传输：发送端和接收端处理数据的速度，数据的量都可以不一致。</li></ul><p><img src="/../../image/TCP%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B.bmp" alt="TCP通信流程"></p><p><img src="/../../image/TCP%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E7%AE%80%E5%8C%96%E7%89%88.bmp" alt="img"></p><h3 id="服务器通信流程"><a href="#服务器通信流程" class="headerlink" title="服务器通信流程"></a>服务器通信流程</h3><ol><li>创建用于监听的套接字（一个文件描述符）<ul><li>socket()</li></ul></li><li>将得到的用于监听的文件描述符和本地IP端口进行绑定<ul><li>bind()</li></ul></li><li>设置监听（监听的是客户端的连接）<ul><li>listen()</li></ul></li><li>等待并接受客户端的连接请求，建立新的连接，会得到一个新的文件描述符（通信的文件描述符），没有新的连接请求就阻塞<ul><li>accept()</li></ul></li><li>通信，读写操作默认都是阻塞的<ul><li>read()&#x2F;recv()</li><li>write()&#x2F;send()</li></ul></li><li>断开连接，关闭套接字<ul><li>close()</li></ul></li></ol><h3 id="客户端通信流程"><a href="#客户端通信流程" class="headerlink" title="客户端通信流程"></a>客户端通信流程</h3><ol><li>创建一个通信的套接字<ul><li>socket()</li></ul></li><li>连接服务器，需要知道服务器绑定的IP和端口<ul><li>connect()</li></ul></li><li>通信<ul><li>read()&#x2F;recv()</li><li>write()&#x2F;send()</li></ul></li><li>断开连接，关闭文件描述符（套接字）<ul><li>close()</li></ul></li></ol><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>在TCP服务器端有两类文件描述符：</p><ol><li>监听的文件描述符<ul><li>只需要一个</li><li>负责检测客户端的连接请求，检测到之后调用accept就可以建立新的连接</li></ul></li><li>通信的文件描述符<ul><li>负责和建立简介的客户端通信</li><li>如果有N个客户端和服务器建立了新的连接，通信的文件描述符就有N个。每个客户端和服务器都对应一个通信的文件描述符</li></ul></li></ol><p>文件描述符的内存结构：</p><ol><li>一个文件描述符对应两块内存（由内核管理），一块内存为读缓冲区，另一块为写缓冲区</li><li>读数据：通过文件描述符将内存中的数据读出，这块内存称之为读缓冲区</li><li>写数据：通过文件描述符将数据写入到某块内存中，这块内存称之为写缓冲区</li></ol><p>监听的文件描述符：</p><ol><li>客户端的连接请求会发送会发送到服务器端监听的文件描述符的读缓冲区中</li><li>读缓冲区中有数据，说明有新的客户端连接</li><li>调用accept函数，这个函数会检测监听文件描述符的读缓冲区<ul><li>检测不到数据，函数阻塞</li><li>检测到数据，解除阻塞，建立新的连接</li></ul></li></ol><p>通信的文件描述符：</p><ol><li>客户端和服务器端都有通信的文件描述符：</li><li>发送数据：调用函数write&#x2F;send，数据进入到内核中<ul><li>数据并没有被发送出去，而是将数据写入到了通信的文件描述符对应的写缓冲区中</li><li>内核检测到通信的文件描述符写缓冲区中有数据，内核会将数据发送到网络中</li></ul></li><li>接收数据：调用函数read&#x2F;recv，从内核中读数据<ul><li>数据进入到通信的文件描述符的读缓冲区中（如何进入不需要程序员处理）</li><li>使用通信的文件描述符，将数据冲读缓冲区中读出</li></ul></li></ol><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/winsock/winsock-functions">Windows</a></p><p><a href="https://man.archlinux.org/man/socket.7.zh_CN">Linux</a></p>]]></content>
    
    
    <categories>
      
      <category>网络通信</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>socket-Windows</title>
    <link href="/2025/02/22/NetworkCommunications/socket_Win/"/>
    <url>/2025/02/22/NetworkCommunications/socket_Win/</url>
    
    <content type="html"><![CDATA[<h1 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h1><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><ol><li>初始化Winsock</li><li>创建套接字</li><li>绑定套接字</li><li>侦听客户端的套接字</li><li>接收来自客户端的连接</li><li>接收和发送数据</li><li>断开连接</li></ol><span id="more"></span><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol><li>初始化Winsock</li><li>创建套接字</li><li>连接到该服务器</li><li>发送和接收数据</li><li>断开连接</li></ol><h1 id="Windows下使用CMake"><a href="#Windows下使用CMake" class="headerlink" title="Windows下使用CMake"></a>Windows下使用CMake</h1><ol><li><p>CMake</p><ul><li><a href="https://cmake.org/download/">CMake官网</a>下载并安装</li><li>无需重启，更新环境变量指令：refreshenv</li></ul></li><li><p>make</p><ul><li>安装<a href="https://github.com/niXman/mingw-builds-binaries/releases">MinGW</a></li><li>添加环境变量：bin目录添加到PATH</li><li>bin目录中mingw-make.exe重命名为make.exe</li></ul></li><li><p>编译指令</p><ul><li>cmake -G “Unix Makefiles” -DCMAKE_BUILD_TYPE&#x3D;Release ..</li><li>make</li></ul></li></ol><h1 id="Winsock入门"><a href="#Winsock入门" class="headerlink" title="Winsock入门"></a>Winsock入门</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;winsock2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ws2tcpip.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;Ws2_32.lib&quot;</span>)</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>winsock2.h头文件包含大多数Winsock函数，结构和定义</li><li>ws2tcpip.h头文件包含了用于处理TCP&#x2F;IP网络协议的特定功能</li><li>对于winsock2.h需要连接到ws2_32.lib</li></ol><h2 id="初始化Winsock"><a href="#初始化Winsock" class="headerlink" title="初始化Winsock"></a>初始化Winsock</h2><p>调用Winsock函数（应用程序或DLL）的所有进程，都必须在调用Winsock函数之前初始化Windows套接字DLL，从而确保Winsock在系统上受支持。</p><ol><li><p>创建名为wsaDate的WSADATA对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">WSADATA wsaData;<br></code></pre></td></tr></table></figure></li><li><p>调用<a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winsock/nf-winsock-wsastartup">WSAStartup</a>并将其值作为整数返回，并检查错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> iResult;<br><br><span class="hljs-comment">// Initialize Winsock</span><br>iResult = <span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>), &amp;wsaData);<br><span class="hljs-keyword">if</span> (iResult != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WSAStartup failed: %d\n&quot;</span>, iResult);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ul><li>WSAStartup函数用于初始化Winsock DLL，在调用任何Winsock函数之前，必须成功调用该函数。</li><li>MAKEWORD(2,2)指定所需的Winsock的版本号，这里表示版本2.2</li></ul><h2 id="为客户端创建套接字"><a href="#为客户端创建套接字" class="headerlink" title="为客户端创建套接字"></a>为客户端创建套接字</h2><p>初始化之后，必须实例化socket对象，以供客户端使用。</p><ol><li><p>声明包含sockaddr结构的addrinfo对象并初始化这些值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span> *result = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span> *ptr = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span> hints;<br><span class="hljs-built_in">ZeroMemory</span>(&amp;hints, <span class="hljs-built_in">sizeof</span>(hints));<br>hints.ai_family   = AF_INET;<br>hints.ai_socktype = SOCK_STREAM;<br>hints.ai_protocol = IPPROTO_TCP;<br></code></pre></td></tr></table></figure></li><li><p>调用getaddrinfo函数，请求传递的服务器名称的IP地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">char</span> *node = <span class="hljs-string">&quot;baidu.com&quot;</span>;<br><span class="hljs-type">char</span> *service = <span class="hljs-string">&quot;http&quot;</span>;<br><br><span class="hljs-comment">// Resolve the server address and port</span><br>iResult = <span class="hljs-built_in">getaddrinfo</span>(node, service, &amp;hints, &amp;result);<br><span class="hljs-keyword">if</span> (iResult != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;getaddrinfo failed: %d\n&quot;</span>, iResult);<br>    <span class="hljs-built_in">WSACleanup</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;WinSock2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;WS2tcpip.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;Ws2_32.lib&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFAULT_PORT <span class="hljs-string">&quot;27015&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    WSADATA WSAData;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span>* result = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span>* ptr = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span>  hints;<br>    <span class="hljs-type">char</span> *node = <span class="hljs-string">&quot;baidu.com&quot;</span>;<br>    <span class="hljs-type">char</span> *service = <span class="hljs-string">&quot;http&quot;</span>;<br><br>    <span class="hljs-comment">// 初始化Winsock</span><br>    <span class="hljs-type">int</span> iResult = <span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>), &amp;WSAData);<br>    <span class="hljs-keyword">if</span>(iResult != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WSAStartup is failed:%d...\n&quot;</span>, iResult);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置hints结构</span><br>    <span class="hljs-built_in">ZeroMemory</span>(&amp;hints, <span class="hljs-built_in">sizeof</span>(hints));<br>    hints.ai_family = AF_INET;<br>    hints.ai_socktype = SOCK_STREAM;<br>    hints.ai_protocol = IPPROTO_TCP;<br><br>    <span class="hljs-comment">//解析地址</span><br>    iResult = <span class="hljs-built_in">getaddrinfo</span>(node, service, &amp;hints, &amp;result);<br>    <span class="hljs-keyword">if</span> (iResult != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;getaddrinfo failed: %d\n&quot;</span>, iResult);<br>        <span class="hljs-built_in">WSACleanup</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历结果链表</span><br>    <span class="hljs-keyword">for</span> (ptr = result; ptr != <span class="hljs-literal">NULL</span>; ptr = ptr-&gt;ai_next) &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> *ipv4 = (<span class="hljs-keyword">struct</span> sockaddr_in *)ptr-&gt;ai_addr;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;IP Address: %s\n&quot;</span>, <span class="hljs-built_in">inet_ntoa</span>(ipv4-&gt;sin_addr));<br>    &#125;<br><br>    <span class="hljs-comment">// 清理</span><br>    <span class="hljs-built_in">freeaddrinfo</span>(result);<br>    <span class="hljs-built_in">WSACleanup</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="连接到套接字"><a href="#连接到套接字" class="headerlink" title="连接到套接字"></a>连接到套接字</h2><p>调用connect函数，将创建的套接字和sockaddr结构作为参数传递。 检查常规错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++">iResult = <span class="hljs-built_in">connect</span>( ConnectSocket, ptr-&gt;ai_addr, (<span class="hljs-type">int</span>)ptr-&gt;ai_addrlen);<br><span class="hljs-keyword">if</span> (iResult == SOCKET_ERROR) &#123;<br>    <span class="hljs-built_in">closesocket</span>(ConnectSocket);<br>    ConnectSocket = INVALID_SOCKET;<br>&#125;<br><br><span class="hljs-built_in">freeaddrinfo</span>(result);<br><br><span class="hljs-keyword">if</span> (ConnectSocket == INVALID_SOCKET) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unable to connect to server!\n&quot;</span>);<br>    <span class="hljs-built_in">WSACleanup</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="在客户端上发送和接收数据"><a href="#在客户端上发送和接收数据" class="headerlink" title="在客户端上发送和接收数据"></a>在客户端上发送和接收数据</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFAULT_BUFLEN 512</span><br><span class="hljs-type">int</span> recvbuflen = DEFAULT_BUFLEN;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *sendbuf = <span class="hljs-string">&quot;this is a test&quot;</span>;<br><span class="hljs-type">char</span> recvbuf[DEFAULT_BUFLEN];<br><span class="hljs-type">int</span> iResult;<br><br><span class="hljs-comment">// Send an initial buffer</span><br>iResult = <span class="hljs-built_in">send</span>(ConnectSocket, sendbuf, (<span class="hljs-type">int</span>) <span class="hljs-built_in">strlen</span>(sendbuf), <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (iResult == SOCKET_ERROR) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;send failed: %d\n&quot;</span>, <span class="hljs-built_in">WSAGetLastError</span>());<br>    <span class="hljs-built_in">closesocket</span>(ConnectSocket);<br>    <span class="hljs-built_in">WSACleanup</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Bytes Sent: %ld\n&quot;</span>, iResult);<br><br><span class="hljs-comment">// shutdown the connection for sending since no more data will be sent</span><br><span class="hljs-comment">// the client can still use the ConnectSocket for receiving data</span><br>iResult = <span class="hljs-built_in">shutdown</span>(ConnectSocket, SD_SEND);<br><span class="hljs-keyword">if</span> (iResult == SOCKET_ERROR) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;shutdown failed: %d\n&quot;</span>, <span class="hljs-built_in">WSAGetLastError</span>());<br>    <span class="hljs-built_in">closesocket</span>(ConnectSocket);<br>    <span class="hljs-built_in">WSACleanup</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// Receive data until the server closes the connection</span><br><span class="hljs-keyword">do</span> &#123;<br>    iResult = <span class="hljs-built_in">recv</span>(ConnectSocket, recvbuf, recvbuflen, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (iResult &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Bytes received: %d\n&quot;</span>, iResult);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (iResult == <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Connection closed\n&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv failed: %d\n&quot;</span>, <span class="hljs-built_in">WSAGetLastError</span>());<br>&#125; <span class="hljs-keyword">while</span> (iResult &gt; <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;WinSock2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;WS2tcpip.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;Ws2_32.lib&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFAULT_PORT <span class="hljs-string">&quot;27015&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFAULT_BUFLEN 512</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    WSADATA WSAData;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span>* result = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span>* ptr = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span>  hints;<br>    <span class="hljs-type">char</span> *node = <span class="hljs-string">&quot;baidu.com&quot;</span>;<br>    <span class="hljs-type">char</span> *service = <span class="hljs-string">&quot;http&quot;</span>;<br>    SOCKET ConnectSocket = INVALID_SOCKET;<br><br>    <span class="hljs-comment">// 初始化Winsock</span><br>    <span class="hljs-type">int</span> iResult = <span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>), &amp;WSAData);<br>    <span class="hljs-keyword">if</span>(iResult != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WSAStartup is failed:%d...\n&quot;</span>, iResult);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置hints结构</span><br>    <span class="hljs-built_in">ZeroMemory</span>(&amp;hints, <span class="hljs-built_in">sizeof</span>(hints));<br>    hints.ai_family = AF_INET;<br>    hints.ai_socktype = SOCK_STREAM;<br>    hints.ai_protocol = IPPROTO_TCP;<br><br>    <span class="hljs-comment">//解析地址</span><br>    iResult = <span class="hljs-built_in">getaddrinfo</span>(node, service, &amp;hints, &amp;result);<br>    <span class="hljs-keyword">if</span> (iResult != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;getaddrinfo failed: %d\n&quot;</span>, iResult);<br>        <span class="hljs-built_in">WSACleanup</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历结果链表</span><br>    <span class="hljs-keyword">for</span> (ptr = result; ptr != <span class="hljs-literal">NULL</span>; ptr = ptr-&gt;ai_next) &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> *ipv4 = (<span class="hljs-keyword">struct</span> sockaddr_in *)ptr-&gt;ai_addr;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;IP Address: %s\n&quot;</span>, <span class="hljs-built_in">inet_ntoa</span>(ipv4-&gt;sin_addr));<br>        ConnectSocket = <span class="hljs-built_in">socket</span>(ptr-&gt;ai_family, ptr-&gt;ai_socktype, ptr-&gt;ai_protocol);<br>        <span class="hljs-keyword">if</span> (ConnectSocket == INVALID_SOCKET) &#123;<br>            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// Create socket failed, try next address</span><br>        &#125;<br><br>        iResult = <span class="hljs-built_in">connect</span>(ConnectSocket, ptr-&gt;ai_addr, (<span class="hljs-type">int</span>)ptr-&gt;ai_addrlen);<br>        <span class="hljs-keyword">if</span> (iResult == SOCKET_ERROR) &#123;<br>            <span class="hljs-built_in">closesocket</span>(ConnectSocket);<br>            ConnectSocket = INVALID_SOCKET;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">freeaddrinfo</span>(result);<br>    <span class="hljs-keyword">if</span> (ConnectSocket == INVALID_SOCKET) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unable to connect to server!\n&quot;</span>);<br>        <span class="hljs-built_in">WSACleanup</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> recvbuflen = DEFAULT_BUFLEN;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *sendbuf = <span class="hljs-string">&quot;this is a test&quot;</span>;<br>    <span class="hljs-type">char</span> recvbuf[DEFAULT_BUFLEN];<br><br>    <span class="hljs-comment">// Send an initial buffer</span><br>    iResult = <span class="hljs-built_in">send</span>(ConnectSocket, sendbuf, (<span class="hljs-type">int</span>)<span class="hljs-built_in">strlen</span>(sendbuf), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (iResult == SOCKET_ERROR) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;send failed: %d\n&quot;</span>, <span class="hljs-built_in">WSAGetLastError</span>());<br>        <span class="hljs-built_in">closesocket</span>(ConnectSocket);<br>        <span class="hljs-built_in">WSACleanup</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Bytes Sent: %ld\n&quot;</span>, iResult);<br><br>    iResult = <span class="hljs-built_in">shutdown</span>(ConnectSocket, SD_SEND);<br>    <span class="hljs-keyword">if</span> (iResult == SOCKET_ERROR) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;shutdown failed: %d\n&quot;</span>, <span class="hljs-built_in">WSAGetLastError</span>());<br>        <span class="hljs-built_in">closesocket</span>(ConnectSocket);<br>        <span class="hljs-built_in">WSACleanup</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        iResult = <span class="hljs-built_in">recv</span>(ConnectSocket, recvbuf, recvbuflen, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (iResult &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Bytes received: %d\n&quot;</span>, iResult);<br>            recvbuf[iResult] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">// Null-terminate the received data</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received data: %s\n&quot;</span>, recvbuf);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (iResult == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Connection closed\n&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv failed: %d\n&quot;</span>, <span class="hljs-built_in">WSAGetLastError</span>());<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (iResult &gt; <span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">closesocket</span>(ConnectSocket);<br>    iResult = <span class="hljs-built_in">WSACleanup</span>();<br>    <span class="hljs-keyword">if</span> (iResult != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WSACleanup failed: %d\n&quot;</span>, iResult);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="断开客户端的连接"><a href="#断开客户端的连接" class="headerlink" title="断开客户端的连接"></a>断开客户端的连接</h2><ol><li><p>当客户端将数据发送到服务器后，可以调用shutdown函数，指定SD_SEND关闭套接字的发送端。 这允许服务器释放此套接字的某些资源。 客户端应用程序仍可接收套接字上的数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// shutdown the send half of the connection since no more data will be sent</span><br>iResult = <span class="hljs-built_in">shutdown</span>(ConnectSocket, SD_SEND);<br><span class="hljs-keyword">if</span> (iResult == SOCKET_ERROR) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;shutdown failed: %d\n&quot;</span>, <span class="hljs-built_in">WSAGetLastError</span>());<br>    <span class="hljs-built_in">closesocket</span>(ConnectSocket);<br>    <span class="hljs-built_in">WSACleanup</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>客户端应用程序完成接收数据后，调用closesocket函数关闭套接字，使用Windows套接字DLL完成客户端应用程序时，调用WSACleanup函数释放资源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// cleanup</span><br><span class="hljs-built_in">closesocket</span>(ConnectSocket);<br><span class="hljs-built_in">WSACleanup</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li></ol><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/winsock/about-clients-and-servers">Windows套接字</a></p><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/_winsock/">Windows Socket API-us</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winsock/nf-winsock-wsastartup">Windows Socket API-zh</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mat</title>
    <link href="/2025/02/22/OpenCV/Mat/"/>
    <url>/2025/02/22/OpenCV/Mat/</url>
    
    <content type="html"><![CDATA[<h1 id="Mat数据"><a href="#Mat数据" class="headerlink" title="Mat数据"></a>Mat数据</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">include &lt;iostream&gt;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/opencv.hpp&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cv::Mat a;     <span class="hljs-comment">//默认构造函数                                       </span><br>    cv::Mat b = cv::<span class="hljs-built_in">Mat</span>();  <span class="hljs-comment">//默认构造函数</span><br>    cv::Mat c = cv::<span class="hljs-built_in">Mat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, CV_8UC1);  <span class="hljs-comment">//指定类型的二维数组</span><br>    cv::Mat d = cv::<span class="hljs-built_in">Mat</span>(cv::<span class="hljs-built_in">Size</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>),CV_8UC1); <span class="hljs-comment">//指定类型的二维数组</span><br>    cv::Mat e = cv::<span class="hljs-built_in">Mat</span>(cv::<span class="hljs-built_in">Size</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), CV_32FC2, cv::<span class="hljs-built_in">Scalar</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));   <span class="hljs-comment">//指定初始化值</span><br>    cv::Mat f = cv::<span class="hljs-built_in">Mat</span>(cv::<span class="hljs-built_in">Size</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), CV_8UC3, cv::<span class="hljs-built_in">Scalar</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">//指定初始化值</span><br><br>    cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;e = &quot;</span> &lt;&lt; e &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;f = &quot;</span> &lt;&lt; f &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-keyword">project</span>(OpenCVExample)<br><br><span class="hljs-keyword">find_package</span>(OpenCV REQUIRED)<br><span class="hljs-keyword">add_executable</span>(app matbuild.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(app <span class="hljs-variable">$&#123;OpenCV_LIBS&#125;</span>)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./app <br>a = []<br>b = []<br>c = [  0,   0,   0;<br>   0,   0,   0;<br>   0,   0,   0]<br>d = [  0,   0,   0;<br>   0,   0,   0;<br>   0,   0,   0]<br>e = [1, 2, 1, 2, 1, 2;<br> 1, 2, 1, 2, 1, 2;<br> 1, 2, 1, 2, 1, 2]<br>f = [  1,   2,   3,   1,   2,   3,   1,   2,   3;<br>   1,   2,   3,   1,   2,   3,   1,   2,   3;<br>   1,   2,   3,   1,   2,   3,   1,   2,   3]<br></code></pre></td></tr></table></figure><ol><li><p>默认构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cv::<span class="hljs-built_in">Mat</span>()<br></code></pre></td></tr></table></figure><p>创建的是一个空的cv::Mat对象，需要在后续使用中为其分配数据；</p></li><li><p>指定类型的二维数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cv::<span class="hljs-built_in">Mat</span>(<span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols, <span class="hljs-type">int</span> type);<br></code></pre></td></tr></table></figure><p>rows和cols分别是矩阵的行数和列数，type是矩阵的数据类型和通道数，例如 <code>CV_8UC3</code>；</p></li><li><p>指定类型的二维数组，大小由size指定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cv::<span class="hljs-built_in">Mat</span>(cv::Size size, <span class="hljs-type">int</span> type);<br></code></pre></td></tr></table></figure></li><li><p>指定类型的二维数组，并指定初始化值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cv::<span class="hljs-built_in">Mat</span>(<span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols, <span class="hljs-type">int</span> type, <span class="hljs-type">const</span> Scalar&amp; s);<br></code></pre></td></tr></table></figure><p>创建一个指定大小和类型的矩阵，并用Scalar类型的值s初始化矩阵的所有元素，Scalar可以是一个标量值或一个包含多个值的数据，用于初始化多通道矩阵；</p></li><li><p>指定类型的二维数组，并指定初始化值，大小由size指定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cv::<span class="hljs-built_in">Mat</span>(cv::Size size, <span class="hljs-type">int</span> type, <span class="hljs-type">const</span> Scalar&amp; s);<br></code></pre></td></tr></table></figure></li><li><p>指定类型的多维数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cv::<span class="hljs-built_in">Mat</span>(<span class="hljs-type">int</span> ndims, <span class="hljs-type">const</span> <span class="hljs-type">int</span>* sizes, <span class="hljs-type">int</span> type);<br></code></pre></td></tr></table></figure></li><li><p>从其他矩阵创建子矩阵</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cv::<span class="hljs-built_in">Mat</span>(<span class="hljs-type">const</span> Mat&amp; m, <span class="hljs-type">const</span> Range&amp; rowRange, <span class="hljs-type">const</span> Range&amp; colRange);<br></code></pre></td></tr></table></figure><p>创建一个矩阵的子矩阵，m是原始矩阵，rowRange和colRange分别是子矩阵的行范围和列范围；</p></li><li><p>指定类型的多维数组，并指定预先存储的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cv::<span class="hljs-built_in">Mat</span>(<span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols, <span class="hljs-type">int</span> type, <span class="hljs-type">void</span>* data, <span class="hljs-type">size_t</span> step=AUTO_STEP)<br></code></pre></td></tr></table></figure><p>使用现有的内存数据创建一个矩阵，data是指向数据的指针，step是每行数据的字节大小，如果step为AUTO_STEP则自动计算步长；</p></li></ol><h2 id="类matlab函数"><a href="#类matlab函数" class="headerlink" title="类matlab函数"></a>类matlab函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/opencv.hpp&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cv::Mat Me = cv::Mat::<span class="hljs-built_in">eye</span>(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, CV_64F);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Me = &quot;</span> &lt;&lt; Me &lt;&lt; endl;<br>    cv::Mat Mo = cv::Mat::<span class="hljs-built_in">ones</span>(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, CV_64F);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Mo = &quot;</span> &lt;&lt; Mo &lt;&lt; endl;<br>    cv::Mat Mz = cv::Mat::<span class="hljs-built_in">zeros</span>(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, CV_64F);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Mz = &quot;</span> &lt;&lt; Mz &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br>输出：<br>$ ./app <br>Me = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>;<br> <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>;<br> <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>;<br> <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br>Mo = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>;<br> <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>;<br> <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>;<br> <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br>Mz = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>;<br> <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>;<br> <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>;<br> <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h2 id="自定义数据"><a href="#自定义数据" class="headerlink" title="自定义数据"></a>自定义数据</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/opencv.hpp&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cv::Mat m = (cv::<span class="hljs-built_in">Mat_</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>);<br>    cout&lt;&lt;m&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="clone-方法"><a href="#clone-方法" class="headerlink" title=".clone()方法"></a>.clone()方法</h1><p>.clone()方法用于创建一个cv::Mat对象的完整副本，它会复制矩阵的所有数据，包括大小，类型和内容。使用.clone()可以确保新矩阵与原始矩阵完全独立，对新矩阵的修改，不会影响原始矩阵。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cv::Mat mat1 = cv::Mat::<span class="hljs-built_in">ones</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, CV_8UC1); <br>cv::Mat mat2 = mat<span class="hljs-number">1.</span><span class="hljs-built_in">clone</span>(); <span class="hljs-comment">// 创建 mat1 的副本</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OpenCV</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu24.04 install opencv</title>
    <link href="/2025/02/22/OpenCV/Ubuntu24.04%20install%20opencv/"/>
    <url>/2025/02/22/OpenCV/Ubuntu24.04%20install%20opencv/</url>
    
    <content type="html"><![CDATA[<ol><li><a href="https://opencv.org/releases/">opencv</a>官网下载opencv-4.10.0的source文件并解压</li><li>下载<a href="">opencv_contrib</a>并解压，将opencv_contrib移动到opencv的文件夹中</li><li>安装依赖项</li></ol><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get install build-essential<br><span class="hljs-built_in">sudo</span> apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev<br><span class="hljs-built_in">sudo</span> apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev<br></code></pre></td></tr></table></figure><p>4.编译并安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D WITH_TBB=ON -D BUILD_SHARED_LIBS=OFF -D WITH_OPENMP=ON -D ENABLE_PRECOMPILED_HEADERS=OFF ..<br><br>$ make -j8<br>$ <span class="hljs-built_in">sudo</span> make install<br></code></pre></td></tr></table></figure><p>5.测试代码<br>编写测试代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;opencv2/opencv.hpp&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span></span>&#123;<br>    <span class="hljs-function">cv::Mat <span class="hljs-title">src</span><span class="hljs-params">(<span class="hljs-number">300</span>,<span class="hljs-number">500</span>,CV_8UC3,cv::Scalar::all(<span class="hljs-number">255</span>))</span></span>;<br>    cv::<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;hello-opencv&quot;</span>,src);<br>    cv::<span class="hljs-built_in">waitKey</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>编写CMakeLists.txt文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs CMake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><span class="hljs-keyword">project</span>(Sample)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)<br><span class="hljs-keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="hljs-variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>)<br> <br><span class="hljs-keyword">find_package</span>(OpenCV REQUIRED)<br><span class="hljs-keyword">set</span>(OpenCV_LIB_DIR <span class="hljs-variable">$&#123;OpenCV_INSTALL_PATH&#125;</span>/lib)<br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;OpenCV版本: $&#123;OpenCV_VERSION&#125;&quot;</span>)<br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;    头文件目录：$&#123;OpenCV_INCLUDE_DIRS&#125;&quot;</span>)<br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;    库文件目录：$&#123;OpenCV_LIB_DIR&#125;&quot;</span>)<br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;    库文件列表：$&#123;OpenCV_LIBS&#125;&quot;</span>)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)<br><span class="hljs-keyword">link_directories</span>(<span class="hljs-variable">$&#123;OpenCV_LIB_DIR&#125;</span>)<br><span class="hljs-keyword">add_executable</span>(main main.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(main <span class="hljs-variable">$&#123;OpenCV_LIBS&#125;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>project</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多线程基础</title>
    <link href="/2025/02/22/OperatingSystem/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/02/22/OperatingSystem/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>并发</p><ol><li>多线程</li><li>多进程</li></ol><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>线程是轻量级的进程，在Linux环境下，线程的本质仍然是进程。操作系统会以进程为单位，分配系统资源。进程是资源分配的最小单位，线程是操作系统调度执行的最小单位。</p><span id="more"></span><p>线程和进程的区别：</p><ol><li>进程有自己独立的地址空间，多个线程公用同一个地址空间<ul><li>在一个地址空间中多个线程共享资源有：代码段，堆区，全局数据区，打开的文件（文件描述符）</li><li>在一个地址空间中多个线程独享资源有：栈区，寄存器</li></ul></li><li>线程是程序的最小执行单位，进程是操作系统中资源分配的最小单位<ul><li>每个进程对应一个虚拟地址空间，一个进程只能抢一个CPU时间片</li><li>一个地址空间中可以划分出多个线程，可以抢占更多的时间片</li></ul></li><li>CPU的调度和切换：线程的上下文切换比进程快的多<ul><li>上下文切换：进程和线程分时复用CPU时间片，在切换之前会将上一个任务的状态进行保存，下次切换回这个任务的时候，加载这个状态继续运行任务从保存到再次加载这个过程就是一次上下文切换。</li><li>线程更加廉价，启动速度更快，退出也快，对系统资源的冲击小</li></ul></li></ol><p>在处理多任务程序的时候，使用多线程比使用多进程更有优势，但是线程并不是越多越好：</p><ol><li>文件IO操作：文件IO对CPU使用率不高，线程数 &#x3D; 2 * CPU核心数</li><li>处理复杂算法：线程数 &#x3D; CPU核心数</li></ol><p>什么时候用多进程？</p><ul><li>在处理一个程序的时候，需要去启动另一个程序的时候，使用多进程。</li></ul><p>并发的话，优先考虑多线程。</p><h1 id="线程函数"><a href="#线程函数" class="headerlink" title="线程函数"></a>线程函数</h1><p>头文件 &lt;pthread.h&gt;</p><h2 id="线程ID"><a href="#线程ID" class="headerlink" title="线程ID"></a>线程ID</h2><p>每个线程都有一个唯一的线程ID</p><ul><li>类型：pthread_t</li><li>无符号长整形</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 返回当前线程的ID</span><br><span class="hljs-type">pthread_t</span> <span class="hljs-title function_">pthread_self</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *thread, <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr, <span class="hljs-type">void</span>*(*start_routine)(<span class="hljs-type">void</span>*), <span class="hljs-type">void</span> *arg)</span>;<br></code></pre></td></tr></table></figure><ol><li>参数<ul><li>thread：传出参数，线程创建成功，会将线程ID写入到这个指针指向的内存中</li><li>attr：线程属性，一般使用默认属性，写NULL</li><li>start_routine：函数指针，子线程的处理动作</li><li>arg：作为实参传递到start_routine指向的函数内部</li></ul></li><li>返回值：线程创建成功返回0，创建失败返回对应的错误号</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">myPrintf</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子线程id:%ld\n&quot;</span>, pthread_self());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子线程中i = %d\n&quot;</span>, i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> pRet = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;主线程中i = %d\n&quot;</span>, i);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father_pthread_id:%ld\n&quot;</span>, pthread_self());<br>    pRet = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, myPrintf, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;son_pthread_id:%ld\n&quot;</span>, tid);<br>    sleep(<span class="hljs-number">1</span>);   <span class="hljs-comment">// 延迟一秒（CPU挂起）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>子线程被创建出来之后需要抢cpu时间片,抢不到就不能运行，如果主线程退出了,虚拟地址空间就被释放了,子线程就一并被销毁了。但是如果某一个子线程退出了,主线程仍在运行,虚拟地址空间依旧存在。在没有人为干预的情况下，虚拟地址空间的生命周期和主线程是一样的，与子线程无关。</p><h2 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h2><p>调用该函数，当前线程马上退出，并且不会影响到其他线程的正常运行，不管是子线程还是主线程中都可以使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span> *retval)</span><br></code></pre></td></tr></table></figure><p>参数：</p><ul><li>线程退出的时候携带的数据，当前子线程的主线程会得到该数据，如果不需要指定为NULL即可。</li></ul><h2 id="线程回收"><a href="#线程回收" class="headerlink" title="线程回收"></a>线程回收</h2><p>子线程退出的时候，其内核资源由主线程进行回收（非内核资源例如栈，代码区资源会在子线程退出的时候，自动释放）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">void</span> **retval)</span>;<br></code></pre></td></tr></table></figure><ol><li>阻塞函数<ul><li>如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源回收，函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。</li></ul></li><li>参数：<ul><li>thread：要回收的子线程的线程ID</li><li>retval：二级指针，指向一级指针的地址，是一个传出参数，这个地址中存储了pthread_exit()传递出的数据，如果不需要这个参数，可以指定为NULL</li></ul></li><li>返回值：<ul><li>线程回收成功返回0，回收失败返回错误码</li></ul></li><li>用法：<ul><li>在子线程退出的时候使用pthread_exit(void* retval)的参数将数据传出，在回收这个子线程的时候通过pthread_join(pthread_t thread, void **retval)的第二个参数来接收子线程传递出的数据。</li><li>需要注意的是，在进行数据回收的时候，不能回收子线程栈上的数据，因为如果多个线程共用同一个虚拟地址空间，每个线程在栈区都有一块属于自己的内存，相当于栈区被这几个线程平分了，当线程退出，线程在栈区的内存也就被回收了，因此随着子线程的退出，写入到栈区的数据也就被释放了。</li><li>可以使用全局变量</li><li>也可以使用主线程栈</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> old;<br>    <span class="hljs-type">char</span>* name;<br>&#125;;<br><br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子线程id:%ld\n&quot;</span>, pthread_self());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子线程中i = %d\n&quot;</span>, i);<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span>* <span class="hljs-title">p</span> =</span> (<span class="hljs-keyword">struct</span> Person*)arg;<br>    p -&gt; old = <span class="hljs-number">10</span>;<br>    p -&gt; name = <span class="hljs-string">&quot;zhang&quot;</span>;<br>    pthread_exit(arg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;主线程中i = %d\n&quot;</span>, i);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father_pthread_id:%ld\n&quot;</span>, pthread_self());<br><br>    <span class="hljs-type">int</span> pRet = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> <span class="hljs-title">p1</span>;</span>   <span class="hljs-comment">// 主线程栈</span><br>    <span class="hljs-type">void</span>* ptr = <span class="hljs-literal">NULL</span>;   <span class="hljs-comment">// 传回参数</span><br>    pRet = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, &amp;p1);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;son_pthread_id:%ld\n&quot;</span>, tid);<br>    pthread_join(tid, &amp;ptr);<br>    <span class="hljs-comment">// 因为ptr是一个void*类型，如果不想这么写，也可以通过类型转换，将ptr转成Person指针</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name:%s\n&quot;</span>, p1.name);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;old:%d\n&quot;</span>, p1.old);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h2><p>线程分离之后，子线程退出的时候，其占用的内核资源就会被系统的其他进程接管并回收。优势在于，不需要在主线程进行阻塞，等待子线程结束，由主线程回收子线程资源。搭配pthread_exit()函数，可以实现主线程退出，子线程依然有其他线程进行资源的回收。<br>在某些情况下，程序中的主线程也有自己的业务流程，如果想让主线程负责子线程的资源回收，调用pthread_join()函数，子要子线程不退出，主线程就会一直被阻塞，主线程的任务也不能推进。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_detach</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread)</span>;<br></code></pre></td></tr></table></figure><p>参数：<br>    - thread：要分离的子线程ID</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-comment">// 子线程的处理代码</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">working</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">9</span>; ++i)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child == i: = %d\n&quot;</span>, i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 1. 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br>    pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, working, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);<br>    <span class="hljs-comment">// 2. 子线程不会执行下边的代码, 主线程执行</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; ++i)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d\n&quot;</span>, i);<br>    &#125;<br>    <span class="hljs-comment">// 设置子线程和主线程分离</span><br>    pthread_detach(tid);<br>    <span class="hljs-comment">// 让主线程自己退出即可</span><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h2><p>在某些情况下，在一个线程中杀死另一个线程：<br>step1：在线程A中调用pthread_cancel(pthreadB_ID)函数，指定杀死线程B，这个时候线程B并不会直接被杀死<br>step2：在线程B中若执行一次系统调用（从用户区切换到内核区），线程B自动被杀死，否则线程B可以一直运行下去</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cancel</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread)</span></span>;<br></code></pre></td></tr></table></figure><ol><li>参数：要杀死的线程的线程ID</li><li>返回值：函数调用成功返回0，调用失败返回错误码</li></ol><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-comment">// 子线程的处理代码</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">working</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span><br>&#123;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">9</span>; ++i)<br>    &#123;<br>        j++;<br>    &#125;<br>    <span class="hljs-comment">// 这个函数会调用系统函数, 因此这是个间接的系统调用</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;我是子线程, 线程ID: %ld\n&quot;</span>, pthread_self());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">9</span>; ++i)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; child i: %d\n&quot;</span>, i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 1. 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br>    pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, working, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子线程创建成功, 线程ID: %ld\n&quot;</span>, tid);<br>    <span class="hljs-comment">// 2. 子线程不会执行下边的代码, 主线程执行</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;我是主线程, 线程ID: %ld\n&quot;</span>, pthread_self());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; ++i)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i = %d\n&quot;</span>, i);<br>    &#125;<br>    <span class="hljs-comment">// 杀死子线程, 如果子线程中做系统调用, 子线程就结束了</span><br>    pthread_cancel(tid);<br>    <span class="hljs-comment">// 让主线程自己退出即可</span><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程ID比较"><a href="#线程ID比较" class="headerlink" title="线程ID比较"></a>线程ID比较</h2><p>在Linux中线程ID本质是一个无符号长整型，因此可以直接使用比较操作符比较这两个线程的ID，但是线程库是可以跨平台使用的，在某些平台上pthread_t可能不是一个单纯的整型，这种情况下比较两个线程的ID就要使用线程比较函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_equal</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> t1, <span class="hljs-type">pthread_t</span> t2)</span>;<br></code></pre></td></tr></table></figure><ol><li>参数：t1和t2是要比较的线程的线程ID</li><li>返回值：如果两个线程ID相等返回非0值，否则返回0</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线程同步</title>
    <link href="/2025/02/22/OperatingSystem/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <url>/2025/02/22/OperatingSystem/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>避免多个线程同时访问并修改同一块内存，造成数据冲突。线程同步的结果是，如果多个线程都要访问并修改同一块内存时，依次只让一个进程进行访问，其余进程阻塞，直到所有进程执行完毕。<br>阻塞：意味着失去CPU时间片</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 50</span><br><span class="hljs-type">int</span> number = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">ThreadWorkingA</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; MAX; i++)&#123;<br>        <span class="hljs-type">int</span> cur = number;<br>        cur++;<br>        usleep(<span class="hljs-number">10</span>);<br>        number = cur;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread A id = %ld, nummber = %d\n&quot;</span>, pthread_self(), number);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">ThreadWorkingB</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; MAX; i++)&#123;<br>        <span class="hljs-type">int</span> cur = number;<br>        cur++;<br>        usleep(<span class="hljs-number">10</span>);<br>        number = cur;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread B id = %ld, nummber = %d\n&quot;</span>, pthread_self(), number);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">pthread_t</span> p1, p2;<br>    pthread_create(&amp;p1, <span class="hljs-literal">NULL</span>, ThreadWorkingA, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;p2, <span class="hljs-literal">NULL</span>, ThreadWorkingB, <span class="hljs-literal">NULL</span>);<br>    pthread_join(p1, <span class="hljs-literal">NULL</span>);<br>    pthread_join(p2, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序运行时，每次都不能运行到number&#x3D;100，这是因为线程A修改了cur数据之后，CPU被挂起，导致没有及时修改number数据，不能及时更新到物理内存中，线程B此时从物理内存中读取到的数据不是最新状态，只能从旧数据开始累加。</p><h1 id="线程同步方式"><a href="#线程同步方式" class="headerlink" title="线程同步方式"></a>线程同步方式</h1><p>多个线程访问共享资源的时候，很容易出现问题，因此需要进行线程同步，常用的线程同步方式有四种：</p><ol><li>互斥锁</li><li>读写锁</li><li>条件变量</li><li>信号量</li></ol><p>共享资源&#x2F;临界资源：</p><ul><li>全局数据区</li><li>堆区变量</li></ul><p>确定临界资源之后，与临界资源相关的上下文代码块被称为临界区，确定好临界区之后，就可以进行线程同步了。</p><ol><li>在临界区代码块起始位置，添加加锁函数，对临界区上锁</li><li>在临界区代码块的结束位置，添加解锁函数，对临界区解锁</li><li>通过锁机制可以保证临界区代码最多只能同时有一个线程访问，即并行访问变成了串行访问</li></ol><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><h3 id="互斥锁类型"><a href="#互斥锁类型" class="headerlink" title="互斥锁类型"></a>互斥锁类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">pthread_mutex_t</span> mutex;<br></code></pre></td></tr></table></figure><p>创建的锁对象中保存了这把锁的状态信息：锁定还是打开，如果是锁定状态还记录了给这把锁加锁的线程信息（线程ID）。一个互斥锁变量，只能被一个线程锁定，被锁定之后，其他线程再对互斥锁变量加锁，就会被阻塞，直到这把锁被解锁。一般情况下，一个共享资源对应一把互斥锁，锁的个数和线程个数无关。</p><h3 id="互斥锁初始化"><a href="#互斥锁初始化" class="headerlink" title="互斥锁初始化"></a>互斥锁初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_init</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *resrict mutex, <span class="hljs-type">const</span> <span class="hljs-type">pthread_mutexattr_t</span> *<span class="hljs-keyword">restrict</span> attr)</span>;<br></code></pre></td></tr></table></figure><ol><li>restrict<ul><li>关键字，用来修饰指针，只有这个关键字修饰的指针可以访问指向的内存空间，其他指针不行</li></ul></li><li>参数：<ul><li>mutex：互斥锁变量的地址</li><li>attr：互斥锁的属性，一般使用默认属性，指定为NULL</li></ul></li><li>返回值<ul><li>函数调用成功返回0，调用失败返回对应的错误号</li></ul></li></ol><h3 id="释放互斥锁资源"><a href="#释放互斥锁资源" class="headerlink" title="释放互斥锁资源"></a>释放互斥锁资源</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li>mutex：互斥锁的地址</li></ul><p>返回值：</p><ul><li>如果函数调用成功返回0，否则返回错误号</li></ul><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br></code></pre></td></tr></table></figure><p>这个函数的调用，首先会判断参数mutex互斥锁中的状态是不是锁定状态：</p><ul><li>如果这个锁没有被锁定，是打开状态，则这个线程可以加锁成功，并在这个锁中记录是哪个线程加锁成功了</li><li>如果这个锁处于被锁定状态，还没有被开锁，那其他线程用这个锁的时候，就会加锁失败，并阻塞在这把锁上</li><li>当这把锁被开锁之后，那些阻塞在这把锁上的线程就解除阻塞，并通过竞争的方式抢占这把锁，没抢到的线程继续阻塞</li></ul><h3 id="尝试加锁"><a href="#尝试加锁" class="headerlink" title="尝试加锁"></a>尝试加锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_trylock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br></code></pre></td></tr></table></figure><p>调用这个函数对互斥锁变量加锁有两种情况：</p><ol><li>如果这把锁没有被锁定，是打开的，则线程加锁成功</li><li>如果锁变量被锁住了，加锁失败，直接返回错误码，并且调用这个函数加锁的线程不会被阻塞</li></ol><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br></code></pre></td></tr></table></figure><p>不是所有线程都可以对互斥锁解锁，而是哪个线程加的锁，哪个线程才能解锁成功。</p><h3 id="互斥锁使用示例"><a href="#互斥锁使用示例" class="headerlink" title="互斥锁使用示例"></a>互斥锁使用示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 50</span><br><span class="hljs-type">int</span> number = <span class="hljs-number">0</span>;<br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">ThreadWorkingA</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; MAX; i++)&#123;<br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-type">int</span> cur = number;<br>        cur++;<br>        number = cur;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread A id = %ld, nummber = %d\n&quot;</span>, pthread_self(), number);<br>        pthread_mutex_unlock(&amp;mutex);<br>        usleep(<span class="hljs-number">5</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">ThreadWorkingB</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; MAX; i++)&#123;<br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-type">int</span> cur = number;<br>        cur++;<br>        usleep(<span class="hljs-number">10</span>);<br>        number = cur;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread B id = %ld, nummber = %d\n&quot;</span>, pthread_self(), number);<br>        pthread_mutex_unlock(&amp;mutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">pthread_t</span> p1, p2;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">start</span>, <span class="hljs-title">end</span>;</span> <br>    gettimeofday(&amp;start, <span class="hljs-literal">NULL</span>); <br><br>    pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;p1, <span class="hljs-literal">NULL</span>, ThreadWorkingA, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;p2, <span class="hljs-literal">NULL</span>, ThreadWorkingB, <span class="hljs-literal">NULL</span>);<br>    pthread_join(p1, <span class="hljs-literal">NULL</span>);<br>    pthread_join(p2, <span class="hljs-literal">NULL</span>);<br>    pthread_mutex_destroy(&amp;mutex);<br><br>    gettimeofday(&amp;end, <span class="hljs-literal">NULL</span>); <br>    <span class="hljs-type">long</span> seconds = end.tv_sec - start.tv_sec;<br>    <span class="hljs-type">long</span> micros = seconds * <span class="hljs-number">1000000</span> + end.tv_usec - start.tv_usec;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Elapsed time: %ld microseconds\n&quot;</span>, micros);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>加锁前：Elapsed time: 5095 microseconds<br>加锁后：Elapsed time: 10915 microseconds</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁：所有线程都被阻塞，并且线程的阻塞无法解开（可以解锁的线程也被阻塞了）。<br>造成死锁的场景如下：</p><ol><li>加锁之后忘记解锁；</li><li>重复加锁；</li><li>程序中有多个共享资源，互相加锁，导致互相被阻塞</li></ol><p>解决方法：</p><ol><li>对共享资源访问完之后，一定要解锁，或者在加锁的时候使用trylock()</li><li>如果程序中有多把锁，可以控制对锁的访问顺序，或者在对其他互斥锁进行加锁操作之前，先释放当前线程拥有的互斥锁</li><li>引入专门用于死锁检测的模块</li></ol><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>读写锁是互斥锁的升级版，在做读操作的时候可以提高程序的执行效率，如果所有的线程都是读操作，那么读是并行的。</p><ol><li>读锁是共享的</li><li>写锁是独占的</li><li>使用读写锁分别对两个临界区加了读锁和写锁，两个线程要同时访问这两个临界区，访问写锁临界区的线程继续运行，访问读锁的临界区的线程阻塞。因为写锁比读锁的优先级高。</li></ol><h3 id="读写锁类型"><a href="#读写锁类型" class="headerlink" title="读写锁类型"></a>读写锁类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">pthread_rwlock_t</span> rwlock;<br></code></pre></td></tr></table></figure><p>读写锁中保存了这把锁的状态信息：</p><ul><li>锁的状态：锁定&#x2F;打开</li><li>锁定的是什么操作：读操作&#x2F;写操作，使用读写锁锁定了写操作之后，需要先解锁才能执行写操作，反之亦然。不能使用一把锁同时进行读锁定和写锁定。</li><li>哪个线程将这把锁锁上的</li></ul><h3 id="读写锁初始化"><a href="#读写锁初始化" class="headerlink" title="读写锁初始化"></a>读写锁初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_init</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *<span class="hljs-keyword">restrict</span> rwlock, <span class="hljs-type">const</span> <span class="hljs-type">pthread_rwlockattr_t</span> *<span class="hljs-keyword">restrict</span> attr)</span>;<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li>rwlock：读写锁的地址，传出参数</li><li>attr：读写锁属性，一般使用默认属性，指定为NULL</li></ul><h3 id="释放读写锁占用的系统资源"><a href="#释放读写锁占用的系统资源" class="headerlink" title="释放读写锁占用的系统资源"></a>释放读写锁占用的系统资源</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li>rwlock：读写锁的地址</li></ul><p>返回值：</p><ul><li>如果函数调用成功返回0，否则返回错误号</li></ul><h3 id="读操作加锁"><a href="#读操作加锁" class="headerlink" title="读操作加锁"></a>读操作加锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_rdlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br></code></pre></td></tr></table></figure><p>调用该函数的时候，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用该函数依然可以加锁成功，因为读锁是共享的；但是如果读写锁已经锁定了写操作，那么调用这个函数的线程就会被阻塞。</p><h3 id="写操作加锁"><a href="#写操作加锁" class="headerlink" title="写操作加锁"></a>写操作加锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_wrlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br></code></pre></td></tr></table></figure><p>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作或者写操作，调用这个函数的线程就会被阻塞。</p><h3 id="尝试读操作加锁"><a href="#尝试读操作加锁" class="headerlink" title="尝试读操作加锁"></a>尝试读操作加锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_tryrdlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br></code></pre></td></tr></table></figure><p>这个函数可以有效的避免死锁，如果加读锁失败，不会阻塞当前线程，直接返回错误号。<br>调用该函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功；如果读写锁已经锁定了写操作，调用这个函数加锁失败，对应的线程不会被阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。</p><h3 id="尝试写操作加锁"><a href="#尝试写操作加锁" class="headerlink" title="尝试写操作加锁"></a>尝试写操作加锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_trywrlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br></code></pre></td></tr></table></figure><p>调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作或者写操作，调用这个函数加锁失败，但是线程不会阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。</p><h3 id="读-写锁解锁"><a href="#读-写锁解锁" class="headerlink" title="读&#x2F;写锁解锁"></a>读&#x2F;写锁解锁</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_rwlock_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_rwlock_t</span> *rwlock)</span>;<br></code></pre></td></tr></table></figure><h3 id="读写锁的使用"><a href="#读写锁的使用" class="headerlink" title="读写锁的使用"></a>读写锁的使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> count 50</span><br><span class="hljs-type">int</span> number = <span class="hljs-number">0</span>;<br><span class="hljs-type">pthread_rwlock_t</span> rwlock;<br><span class="hljs-comment">// pthread_mutex_t mutex;</span><br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">WriteThread</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>    &#123;   <br>        pthread_rwlock_wrlock(&amp;rwlock);<br>        <span class="hljs-comment">// pthread_mutex_lock(&amp;mutex);</span><br>        <span class="hljs-type">int</span> cur = number;<br>        cur ++;<br>        usleep(<span class="hljs-number">5</span>);<br>        number = cur;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;++写操作完毕，number = %d, tid = %ld\n&quot;</span>, number, pthread_self());<br>        <span class="hljs-comment">// pthread_mutex_unlock(&amp;mutex);</span><br>        pthread_rwlock_unlock(&amp;rwlock);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">ReadThread</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>    &#123;<br>        pthread_rwlock_rdlock(&amp;rwlock);<br>        <span class="hljs-comment">// pthread_mutex_lock(&amp;mutex);</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--读操作完毕，number = %d, tid = %ld\n&quot;</span>, number, pthread_self());<br>        <span class="hljs-comment">// pthread_mutex_unlock(&amp;mutex);</span><br>        pthread_rwlock_unlock(&amp;rwlock);<br>        usleep(<span class="hljs-number">5</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">start</span>, <span class="hljs-title">end</span>;</span><br>    gettimeofday(&amp;start, <span class="hljs-literal">NULL</span>);<br>    pthread_rwlock_init(&amp;rwlock, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// pthread_mutex_init(&amp;mutex, NULL);</span><br>    <span class="hljs-type">pthread_t</span> wtid[<span class="hljs-number">3</span>];<br>    <span class="hljs-type">pthread_t</span> rtid[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++)&#123;<br>        pthread_create(&amp;wtid[i], <span class="hljs-literal">NULL</span>, WriteThread, <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++)&#123;<br>        pthread_create(&amp;rtid[i], <span class="hljs-literal">NULL</span>, ReadThread, <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++)&#123;<br>        pthread_join(wtid[i], <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++)&#123;<br>        pthread_join(rtid[i], <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// pthread_mutex_destroy(&amp;mutex);</span><br>    pthread_rwlock_destroy(&amp;rwlock);<br><br>    gettimeofday(&amp;end, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">long</span> seconds = end.tv_sec - start.tv_sec;<br>    <span class="hljs-type">long</span> micros = seconds*<span class="hljs-number">1000000</span> + end.tv_usec - start.tv_usec;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Elapsed time: %ld microseconds\n&quot;</span>, micros);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>w&#x3D;3, r&#x3D;20<br>读写锁运行时间：读写锁 - Elapsed time: 42484 microseconds<br>互斥锁运行时间：互斥锁 - Elapsed time: 44594 microseconds</p><p>w&#x3D;3, r&#x3D;100<br>读写锁 - Elapsed time: 123020 microseconds<br>互斥锁 - Elapsed time: 125475 microseconds</p><p>w&#x3D;0, r&#x3D;100<br>读写锁 - Elapsed time: 108057 microseconds<br>互斥锁 - Elapsed time: 113061 microseconds</p><p>w&#x3D;0, r&#x3D;1000<br>读写锁 - Elapsed time: 1006307 microseconds<br>互斥锁 - Elapsed time: 939342 microseconds</p><p>w&#x3D;0, r&#x3D;1000（把延时加到锁里面，对比非常明显）<br>读写锁 - Elapsed time: 977554 microseconds<br>互斥锁 - Elapsed time: 4813041 microseconds</p><p>无论是读写锁还是互斥锁，它们在操作系统层面都有开销。这个开销包括上下文切换、锁的获取和释放等。如果不将延时放入上锁的代码内，系统层面的开销占据了主导地位，使得读写锁的性能优势不明显。</p><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><ol><li>条件变量的主要作用不是处理线程同步，而是进行线程的阻塞。</li><li>条件变量一般需要配合互斥锁来使用。</li><li>假设一共有1-26个线程，共同访问同一把互斥锁，如果其中一个线程加锁成功，那么其余的25个线程访问互斥锁都阻塞，所有线程都只能顺序访问临界区</li><li>条件变量只有满足指定条件下才会阻塞线程，如果条件不满足，多个线程可以同时进入临界区，同时读写资源（也会出现共享资源中的数据混乱）</li></ol><h3 id="条件变量类型"><a href="#条件变量类型" class="headerlink" title="条件变量类型"></a>条件变量类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">pthread_cond_t</span> cond;<br></code></pre></td></tr></table></figure><p>里面记录了被条件变量阻塞的线程的线程信息，以便在解除阻塞的时候使用。</p><h3 id="条件变量初始化"><a href="#条件变量初始化" class="headerlink" title="条件变量初始化"></a>条件变量初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_init</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *<span class="hljs-keyword">restrict</span> cond, <span class="hljs-type">const</span> <span class="hljs-type">pthread_condattr_t</span> *<span class="hljs-keyword">restrict</span> attr)</span>;<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li>cond：条件变量的地址，传出参数</li><li>attr：条件变量的属性，一般使用默认属性，指定为NULL</li></ul><h3 id="条件变量销毁并释放资源"><a href="#条件变量销毁并释放资源" class="headerlink" title="条件变量销毁并释放资源"></a>条件变量销毁并释放资源</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span>;<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li>cond：条件变量的地址</li></ul><h3 id="条件变量的线程阻塞函数"><a href="#条件变量的线程阻塞函数" class="headerlink" title="条件变量的线程阻塞函数"></a>条件变量的线程阻塞函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_wait</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *<span class="hljs-keyword">restrict</span> cond, <span class="hljs-type">pthread_mutex_t</span> *<span class="hljs-keyword">restrict</span> mutex)</span>;<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li>cond：条件变量的地址</li><li>mutex：互斥锁的地址</li></ul><p>函数在阻塞线程的时候，需要一个互斥锁参数，这个互斥锁的功能主要是进行线程同步，让线程顺序进入临界区，避免出现共享资源的数据混乱，该函数会对互斥锁做以下几件事情：</p><ol><li>在阻塞线程的时候，如果线程已经对互斥锁mutex上锁，那么该函数会将这把锁打开，从而避免死锁</li><li>当线程解除阻塞的时候，函数内部会帮助这个线程再次将这个mutex互斥锁上锁，继续向下访问临界区</li></ol><h3 id="条件变量的线程阻塞函数（定时解除）"><a href="#条件变量的线程阻塞函数（定时解除）" class="headerlink" title="条件变量的线程阻塞函数（定时解除）"></a>条件变量的线程阻塞函数（定时解除）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_timewait</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *<span class="hljs-keyword">restrict</span> cond, <span class="hljs-type">pthread_mutex_t</span> *<span class="hljs-keyword">restrict</span> mutex, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timespec *<span class="hljs-keyword">restrict</span> abstime)</span>;<br></code></pre></td></tr></table></figure><p>将线程阻塞一定的时间，时间到达之后，线程解除阻塞。<br>其中struct timespec的结构为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 表示的时间为从1971.1.1到某个时间点的时间</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> &#123;</span><br>    <span class="hljs-type">time_t</span> tv_sec;  <span class="hljs-comment">// 秒</span><br>    <span class="hljs-type">long</span> tv_nsec;   <span class="hljs-comment">// 纳秒</span><br>&#125;<br></code></pre></td></tr></table></figure><p>timespec参数的赋值方式比较麻烦：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">time_t</span> mytime = time(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 1971.1.1 0:0:0到当前的总秒数</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">tmsp</span>;</span><br>tmsp.tv_sec = time(<span class="hljs-literal">NULL</span>) + <span class="hljs-number">100</span>; <span class="hljs-comment">// 线程阻塞100s</span><br>tmsp.tv_nsec = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h3 id="条件变量的唤醒阻塞函数"><a href="#条件变量的唤醒阻塞函数" class="headerlink" title="条件变量的唤醒阻塞函数"></a>条件变量的唤醒阻塞函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 唤醒阻塞在条件变量上的线程（至少一个，总数不定，相当于随机唤醒几个被阻塞在条件变量上的线程）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_signal</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span>;<br><br><span class="hljs-comment">// 唤醒被阻塞在条件变量上的线程，被阻塞的线程全部解除阻塞</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cond_broadcast</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span> *cond)</span>;<br></code></pre></td></tr></table></figure><p>上述两个唤醒阻塞函数的区别是，第一个是随机唤醒几个被阻塞在条件变量上的线程，第二个是唤醒所有被阻塞在条件变量上的线程。因为条件变量搭配互斥锁使用，很多情况下，即使将阻塞在条件变量上的互斥锁全部唤醒，当其中一个线程抢占到互斥锁之后，其余线程也会立马进行阻塞状态。以及如果，当消费者远远大于生产者的数目，当生产者供不应求的时候，也没必要唤醒全部被条件变量阻塞的线程，因为唤醒之后，又会立马因为供不应求，再次陷入阻塞。</p><h3 id="条件变量的使用"><a href="#条件变量的使用" class="headerlink" title="条件变量的使用"></a>条件变量的使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 5</span><br><span class="hljs-type">pthread_cond_t</span> cond;<br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 链表（仓库）</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> number;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span>    <br>&#125;;<br><br><span class="hljs-comment">// 指向头节点的指针</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">HEAD</span> =</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 生产者</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;   <span class="hljs-comment">//  一直生产</span><br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-comment">// 创建新节点（生产）</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newNode</span> =</span> (<span class="hljs-keyword">struct</span> Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>        newNode -&gt; next = HEAD;<br>        newNode -&gt;number = ++total;<br>        HEAD = newNode;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>, newNode-&gt;number, pthread_self());<br>        pthread_mutex_unlock(&amp;mutex);<br>        pthread_cond_broadcast(&amp;cond);<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 消费者</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;   <br>        pthread_mutex_lock(&amp;mutex);<br>        <br>        <span class="hljs-comment">// 这里能不能改成if判断？？？</span><br>        <span class="hljs-comment">// 不能。有一个消费者线程通过 pthread_cond_wait()加锁成功, 其余没有加锁成功的线程继续阻塞</span><br>        <span class="hljs-comment">// 加锁成功的线程向下运行，并成功删除一个节点，然后解锁</span><br>        <span class="hljs-comment">// 没有加锁成功的线程解除阻塞继续抢这把锁，另外一个子线程加锁成功</span><br>        <span class="hljs-comment">// 但是这个线程删除链表节点的时候链表已经为空了, 后边访问这个空节点的时候就会出现段错误。</span><br>        <span class="hljs-keyword">while</span> (HEAD == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            pthread_cond_wait(&amp;cond, &amp;mutex);<br>        &#125;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newNode</span> =</span> HEAD;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, newNode-&gt;number, pthread_self());<br>        HEAD = newNode -&gt; next;<br>        <span class="hljs-built_in">free</span>(newNode);<br>        pthread_mutex_unlock(&amp;mutex);<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    pthread_cond_init(&amp;cond, <span class="hljs-literal">NULL</span>);<br>    pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 五个生产者</span><br>    <span class="hljs-type">pthread_t</span> ptid[N];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    &#123;<br>        pthread_create(&amp;ptid[i], <span class="hljs-literal">NULL</span>, producer, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-comment">// 五个消费者</span><br>    <span class="hljs-type">pthread_t</span> ctid[N];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    &#123;<br>        pthread_create(&amp;ctid[i], <span class="hljs-literal">NULL</span>, consumer, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-comment">// 释放线程资源</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    &#123;<br>        pthread_join(ptid[i], <span class="hljs-literal">NULL</span>);<br>        pthread_join(ctid[i], <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-comment">// 释放条件变量和锁的资源</span><br>    pthread_cond_destroy(&amp;cond);<br>    pthread_mutex_destroy(&amp;mutex);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>对于信号量，我的理解是，他代表一种资源，如果信号量不为0，即代表有剩余资源，线程可以继续运行；如果信号量为0，即代表资源为空，线程阻塞。<br>信号量的主要作用也是阻塞线程，并不能保证线程安全，如果要保证线程安全，需要信号量和互斥锁一起使用。</p><ol><li>信号量的头文件为：&lt;semaphore.h&gt;</li><li>信号量的类型为：sem_t sem;</li></ol><h3 id="信号量初始化"><a href="#信号量初始化" class="headerlink" title="信号量初始化"></a>信号量初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">sem_init</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem, <span class="hljs-type">int</span> pshared, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value)</span>;<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li>sem：信号量变量地址</li><li>pshared：<ul><li>0：线程同步</li><li>非0：进程同步</li></ul></li><li>value：初始化当前信号量拥有的资源数，如果资源数为0，线程就会被阻塞</li></ul><h3 id="信号量的资源释放"><a href="#信号量的资源释放" class="headerlink" title="信号量的资源释放"></a>信号量的资源释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">sem_destroy</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li>信号量变量的地址</li></ul><h3 id="信号量资源消耗（-1）函数"><a href="#信号量资源消耗（-1）函数" class="headerlink" title="信号量资源消耗（-1）函数"></a>信号量资源消耗（-1）函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">sem_wait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br></code></pre></td></tr></table></figure><ul><li>当sem中的资源数大于0，线程不会阻塞，线程会占用sem中的一个资源，并且资源数减1</li><li>当sem中的资源数减为0时，资源被耗尽，线程阻塞</li></ul><h3 id="信号量资源增加（-1）函数"><a href="#信号量资源增加（-1）函数" class="headerlink" title="信号量资源增加（+1）函数"></a>信号量资源增加（+1）函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">sem_post</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br></code></pre></td></tr></table></figure><ul><li>调用该函数，会将sem中的资源数加1</li><li>如果有线程在调用sem_wait，sem_trywait，sem_timedwait时因为sem中的资源数为0被阻塞了，这时这些线程会解除阻塞，获取到资源之后继续向下运行。</li></ul><h3 id="其他信号量资源消耗函数"><a href="#其他信号量资源消耗函数" class="headerlink" title="其他信号量资源消耗函数"></a>其他信号量资源消耗函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 尝试获取资源</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_trywait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br><br><span class="hljs-comment">// 定时阻塞获取资源</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_timewait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timespec *abs_timeout)</span>;<br></code></pre></td></tr></table></figure><p>第一个函数：</p><ul><li>当sem中的资源数大于0，线程不会阻塞，线程会占用sem中的一个资源，并且资源数减1</li><li>当sem中的资源数减为0时，资源被耗尽，但是线程不会阻塞，而是直接返回错误号，可以加判断语句，用于处理获取资源失败的情况</li></ul><p>第二个函数：</p><ul><li>当sem中的资源数大于0，线程不会阻塞，线程会占用sem中的一个资源，并且资源数减1</li><li>当sem中的资源数减为0时，资源被耗尽，线程开始阻塞，当阻塞指定时长之后，线程解除阻塞</li></ul><h3 id="获取信号量资源数函数"><a href="#获取信号量资源数函数" class="headerlink" title="获取信号量资源数函数"></a>获取信号量资源数函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">sem_getvalue</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem, <span class="hljs-type">int</span> *sval)</span>;<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li>sem：信号量变量的地址</li><li>sval：传出参数，传出信号量剩余资源</li></ul><h3 id="信号量使用方式"><a href="#信号量使用方式" class="headerlink" title="信号量使用方式"></a>信号量使用方式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 5</span><br><span class="hljs-type">sem_t</span> psem;<br><span class="hljs-type">sem_t</span> csem;<br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> number;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">head</span> =</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        sem_wait(&amp;psem);<br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">pnew</span> =</span> (<span class="hljs-keyword">struct</span> Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>        pnew-&gt;number = ++total;<br>        pnew-&gt;next = head;<br>        head = pnew;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;+++producer, number = %d, tid = %ld\n&quot;</span>, pnew-&gt;number, pthread_self());<br>        pthread_mutex_unlock(&amp;mutex);<br>        sem_post(&amp;csem);<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        sem_wait(&amp;csem);<br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">pnode</span> =</span> head;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--consumer: number: %d, tid = %ld\n&quot;</span>, pnode-&gt;number, pthread_self());<br>        head  = pnode-&gt;next;<br>        <span class="hljs-built_in">free</span>(pnode);<br>        pthread_mutex_unlock(&amp;mutex);<br>        sem_post(&amp;psem);<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    sem_init(&amp;psem, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>    sem_init(&amp;csem, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">pthread_t</span> ptid[N];<br>    <span class="hljs-type">pthread_t</span> ctid[N];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;N; ++i)<br>    &#123;<br>        pthread_create(&amp;ptid[i], <span class="hljs-literal">NULL</span>, producer, <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;N; ++i)<br>    &#123;<br>        pthread_create(&amp;ctid[i], <span class="hljs-literal">NULL</span>, consumer, <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;N; ++i)<br>    &#123;<br>        pthread_join(ptid[i], <span class="hljs-literal">NULL</span>);<br>        pthread_join(ctid[i], <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    sem_destroy(&amp;psem);<br>    sem_destroy(&amp;csem);<br>    pthread_mutex_destroy(&amp;mutex);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果生产者和消费者使用的信号量总资源数为1，那么不会出现生产者线程和消费者线程同时访问共享资源的情况，不管生产者和消费者线程有多少个，它们都是顺序执行的。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>进程抽象</title>
    <link href="/2025/02/22/OperatingSystem/%E8%BF%9B%E7%A8%8B%E6%8A%BD%E8%B1%A1/"/>
    <url>/2025/02/22/OperatingSystem/%E8%BF%9B%E7%A8%8B%E6%8A%BD%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="进程抽象"><a href="#进程抽象" class="headerlink" title="进程抽象"></a>进程抽象</h1><h2 id="1-进程API内容"><a href="#1-进程API内容" class="headerlink" title="1.进程API内容"></a>1.进程API内容</h2><ul><li>创建（create）</li><li>销毁（destroy）</li><li>等待（wait）</li><li>其他控制（miscellaneous control）</li><li>状态（statu）</li></ul><span id="more"></span><h2 id="2-进程创建"><a href="#2-进程创建" class="headerlink" title="2.进程创建"></a>2.进程创建</h2><p>1.操作系统运行程序的<strong>第一件事</strong>是将代码和所有的静态数据加载（load）到内存中，加载到进程的地址空间中。<br>2.为程序的运行时栈，分配一些内存。C程序使用栈存放局部变量，函数参数，返回值。操作系统分配这些内存，并提供给进程。<br>3.操作系统也可能为程序的堆分配一些内存。<br>4.操作系统还将执行一些其他初始化任务，比如输入\输出相关的任务。</p><h2 id="3-进程的状态"><a href="#3-进程的状态" class="headerlink" title="3.进程的状态"></a>3.进程的状态</h2><ul><li>运行：该进程正在执行指令<br>1.运行态不会一直持续，进程的CPU时间片用完之后，再次失去CPU，从运行态转为就绪态。</li><li>就绪：进程准备好运行，但是操作系统在运行其他进程<br>1.进程被创建出来了，有运行的资格，但是还没有运行，需要抢占CPU时间片；<br>2.得到CPU时间片，进程开始运行，从就绪态转换为运行态；<br>3.进程的CPU时间片用完之后，再次失去CPU，从运行态转为就绪态。</li><li>阻塞：进程被强制放弃CPU，并且没有抢占CPU时间片的资格<br>1.比如当进程向磁盘发起I&#x2F;O请求<br>2.当阻塞任务完成，进程从阻塞态转换为就绪态</li></ul><h2 id="4-进程API"><a href="#4-进程API" class="headerlink" title="4.进程API"></a>4.进程API</h2><p>1.fork()系统调用</p><blockquote><p>用于创建新进程，创建出来的进程被称为子进程，子进程与父进程几乎一样。子进程不会从main函数开始执行，而是直接从fork系统调用中返回。<br>子进程拥有自己的地址空间（即私有内存），寄存器，程序计数器等，但是它从fork返回的值是不同的。父进程获得的返回值是新创建子进程的PID，子进程获得的返回值是0.</p></blockquote><p>子进程和父进程的<strong>相同点</strong>：<br>1.拷贝完成后，两个地址空间的用户区数据是相同的。用户数据主要包括：</p><ul><li>代码区</li><li>全局数据区</li><li>堆区</li><li>动态库加载区（内存映射区）</li><li>栈区</li><li>环境变量</li><li>文件描述符：父进程中被分配的文件描述符都会被拷贝到子进程中，在子进程中可以使用他们打开对应的文件。</li></ul><p>子进程和父进程的<strong>区别</strong>：<br>1.父子进程各自的虚拟地址是相互独立的，不会互相影响和干扰。<br>2.父子进程的代码区虽然相同，但是执行的代码逻辑可能是不同的。一些情况下会用if判断父子进程，分别执行不同的代码块。<br>3.内核区存储的父子进程ID是不同的。<br>4.fork调用成功之后，会返回两个值，父子进程的返回值是不同的。</p>]]></content>
    
    
    <categories>
      
      <category>OperatingSystem</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda</title>
    <link href="/2025/02/22/Other/Anaconda/"/>
    <url>/2025/02/22/Other/Anaconda/</url>
    
    <content type="html"><![CDATA[<h1 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h1><h2 id="命令行窗口"><a href="#命令行窗口" class="headerlink" title="命令行窗口"></a>命令行窗口</h2><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"># 查看版本号<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">conda --version</span><br><br># 查看目前的镜像<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">conda config </span><br><br># 添加路径<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">conda config --add channels <span class="hljs-attr">http</span>:<span class="hljs-comment">//mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">conda config –-add channels <span class="hljs-attr">http</span>:<span class="hljs-comment">//mirrors.ustc.edu.cn/anaconda/pkgs/free/</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">conda config --add channels <span class="hljs-attr">http</span>:<span class="hljs-comment">//mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span></span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">conda config --set show_channel_urls yes</span><br><br># 升级工具包<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">conda upgrade --all</span><br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="Anaconda-Prompt"><a href="#Anaconda-Prompt" class="headerlink" title="Anaconda Prompt"></a>Anaconda Prompt</h2><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"># 创建虚拟环境<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">conda create -n &lt;env-name&gt; python=<span class="hljs-number">3.6</span></span><br><br># 列出所有可用的conda环境<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">conda info --envs</span><br><br># 进入虚拟环境<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">activate &lt;env-name&gt;</span><br><br># 退出虚拟环境<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">deactivate</span><br><br># 安装package<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">conda install &lt;package-name&gt;</span><br><br># 查看当前环境下安装的packages<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">conda list</span><br><br># 安装package<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">pip install -i <span class="hljs-attr">http</span>:<span class="hljs-comment">//pypi.tuna.tsinghua.edu.cn/simple --trusted-host pypi.tuna.tsinghua.edu.cn  matplotlib</span></span><br><br></code></pre></td></tr></table></figure><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>Anaconda Prompt可以看作是命令行窗口（CMD）的增强版，专门为Anaconda用户设计，以支持Python开发和数据科学工作。</p><ul><li>Anaconda Prompt完全兼容CMD中的所有命令。</li><li>Anaconda Prompt提供了conda命令，用于管理Anaconda环境和包。</li><li>Anaconda Prompt预装了许多数据科学和机器学习相关的库</li><li>Anaconda Prompt允许用户创建、激活和删除不同的Python环境（称为conda环境）</li></ul><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p><a href="https://blog.csdn.net/Inochigohan/article/details/120400990">anaconda安装</a><br><a href="https://blog.csdn.net/qq_39220334/article/details/121961742">清华镜像源</a><br><a href="https://www.cnblogs.com/lab-zj/p/16975410.html">conda常用命令</a><br><a href="https://blog.csdn.net/JineD/article/details/124774570">pip安装package</a></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>双系统</title>
    <link href="/2025/02/22/Other/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
    <url>/2025/02/22/Other/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>1.重装了Windows10专业版系统<br>2.增加了Ubuntu24.04双系统</p><span id="more"></span><h1 id="重装系统-Windows"><a href="#重装系统-Windows" class="headerlink" title="重装系统-Windows"></a>重装系统-Windows</h1><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><ul><li><a href="https://www.wepe.com.cn/">制作系统盘</a></li><li><a href="https://msdn.itellyou.cn/">下载Windows10光盘映像 consumer editions</a></li></ul><h2 id="2-主板型号"><a href="#2-主板型号" class="headerlink" title="2.主板型号"></a>2.主板型号</h2><p>根据主板型号，搜索对应品牌进入BIOS方法。获取主板型号的方法：<br>1.进入Windows PowerShell<br>2.运行指令：msinfo32</p><h2 id="3-分区格式"><a href="#3-分区格式" class="headerlink" title="3.分区格式"></a>3.分区格式</h2><p>可以通过<code>硬件管理</code>查看目前磁盘的分区格式。<br>1.进入<code>磁盘管理</code><br>2.右键<code>磁盘0</code>或<code>磁盘1</code> -&gt; 属性 -&gt; 卷<br>3.磁盘分区形式</p><table><thead><tr><th align="center">分区表格式</th><th align="center">启动项</th></tr></thead><tbody><tr><td align="center">MBR</td><td align="center">UEFI</td></tr><tr><td align="center">GPT</td><td align="center">Legacy</td></tr></tbody></table><h2 id="4-进入BOIS"><a href="#4-进入BOIS" class="headerlink" title="4.进入BOIS"></a>4.进入BOIS</h2><p>设置<code>Boot Priority</code>，UEFI:U盘拖到第1优先级</p><h2 id="5-硬盘分区"><a href="#5-硬盘分区" class="headerlink" title="5.硬盘分区"></a>5.硬盘分区</h2><p>电脑有两个以上硬盘，且每个硬盘都作了分区，装系统的时候可能会出错，显示无法创建新的分区。解决方案：<br><strong>方案一</strong>：在分区容量大小的时候，系统盘选择主分区，其他盘取消主分区。<br><strong>方案二</strong>：系统盘分区，另外一个盘不进行分区。等系统安装完成之后再手动分区。</p><h2 id="6-安装驱动"><a href="#6-安装驱动" class="headerlink" title="6.安装驱动"></a>6.安装驱动</h2><p>有些电脑装系统之后，系统自带的集成驱动没有网卡驱动，所以上不了网，比如我这台微星。这个时候就需要借助其他电脑，到微星官网。搜索对应的主板型号，找到技术支持里的驱动安装。选择网卡驱动，下载并保存到U盘里，拷贝到新装系统的电脑上，并解压。<br>设备管理器 -&gt; 其他设备&#x2F;网络适配器 -&gt; 鼠标右键更新驱动 -&gt; 浏览计算机查找驱动软件 -&gt; 找到解压文件夹</p><h2 id="7-NVIDIA显卡驱动"><a href="#7-NVIDIA显卡驱动" class="headerlink" title="7.NVIDIA显卡驱动"></a>7.NVIDIA显卡驱动</h2><p>终端窗口输入命令：nvidia-smi<br>1.<a href="https://www.nvidia.cn/">英伟达官网</a><br>2.Geforce驱动<br>3.选择对应型号无脑安装</p><h1 id="双系统-Ubuntu"><a href="#双系统-Ubuntu" class="headerlink" title="双系统-Ubuntu"></a>双系统-Ubuntu</h1><h2 id="1-Windows系统上创建分区"><a href="#1-Windows系统上创建分区" class="headerlink" title="1.Windows系统上创建分区"></a>1.Windows系统上创建分区</h2><p>磁盘管理 -&gt; 找一个空间比较大的分区（比如新加卷D:）-&gt; 右键 压缩卷（不进行分区，我压缩了512G）</p><h2 id="2-下载Ubuntu光盘映像，制作Ubuntu安装盘"><a href="#2-下载Ubuntu光盘映像，制作Ubuntu安装盘" class="headerlink" title="2.下载Ubuntu光盘映像，制作Ubuntu安装盘"></a>2.下载Ubuntu光盘映像，制作Ubuntu安装盘</h2><p>制作安装盘使用的是UtralOS<br>1.启动 -&gt; 写入硬盘映像 -&gt; 软件自动识别U盘<br>2.格式化U盘<br>3.写入方式：USB-HDD+<br>4.写入</p><h2 id="3-磁盘分区"><a href="#3-磁盘分区" class="headerlink" title="3.磁盘分区"></a>3.磁盘分区</h2><p>1.VFAT（efi）：512MB<br>2.swap：10G<br>3.Ext4（&#x2F;）：20G（我分了100G）<br>4.Ext4（&#x2F;Home）：30G（剩下的都给它）</p>]]></content>
    
    
    <categories>
      
      <category>PC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Jetson-Windows通信框架代码</title>
    <link href="/2025/02/22/StructLight/%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6/"/>
    <url>/2025/02/22/StructLight/%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="光机"><a href="#光机" class="headerlink" title="光机"></a>光机</h2><ol><li>装载投影条纹<ul><li>格雷码条纹</li><li>相移条纹</li></ul></li><li>读取led电流值</li><li>设置led电流值</li><li>读取投影仪分辨率</li><li>开始投影<ul><li>单次投影</li><li>连续投影</li></ul></li></ol><span id="more"></span><h2 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h2><ol><li>读取曝光时间</li><li>读取相机分辨率</li><li>读取相机帧率</li><li>设置曝光时间</li><li>设置相机帧率</li><li>设置触发方式</li><li>预览模式（如何预览从而用于调整曝光）</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>图像转存</li><li>点云转存</li><li>点云平滑程度选择（强，中，弱，无）</li><li>Z轴区间选择</li><li>点云的伪彩色可视化</li><li>不同画幅的选择<ul><li>预置不同画幅的标定文件，根据不同画幅选择对应的标定文件</li></ul></li><li></li></ol><h1 id="Jetson端"><a href="#Jetson端" class="headerlink" title="Jetson端"></a>Jetson端</h1><ol><li>处理客户端发送来控制码</li><li>strtok()函数分割字符串</li><li>strcmp()函数比较字符串</li></ol><h1 id="Windows端"><a href="#Windows端" class="headerlink" title="Windows端"></a>Windows端</h1><ol><li>发送控制码</li><li>getline()函数获取输入的控制码</li></ol><h1 id="框架代码"><a href="#框架代码" class="headerlink" title="框架代码"></a>框架代码</h1><h2 id="Jestson服务器"><a href="#Jestson服务器" class="headerlink" title="Jestson服务器"></a>Jestson服务器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> PORT = <span class="hljs-number">27015</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 创建监听的套接字</span><br>    <span class="hljs-type">int</span> lfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(lfd == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 绑定本机IP端口</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> addr;<br>    addr.sin_family = AF_INET;<br>    addr.sin_addr.s_addr = INADDR_ANY;<br>    addr.sin_port = <span class="hljs-built_in">htons</span>(PORT);<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">bind</span>(lfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;addr, <span class="hljs-built_in">sizeof</span>(addr));<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;bind&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 开始监听</span><br>    ret = <span class="hljs-built_in">listen</span>(lfd, <span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;listen&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 建立连接</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> cliaddr;<br>    <span class="hljs-type">socklen_t</span> clilen = <span class="hljs-built_in">sizeof</span>(cliaddr);<br>    <span class="hljs-type">int</span> cfd = <span class="hljs-built_in">accept</span>(lfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;clilen);<br>    <span class="hljs-keyword">if</span>(cfd == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;accept&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">char</span> ip[<span class="hljs-number">24</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Windows IP:%s, Port:%d\n&quot;</span>, <span class="hljs-built_in">inet_ntop</span>(AF_INET, &amp;cliaddr.sin_addr.s_addr, ip, <span class="hljs-built_in">sizeof</span>(ip)), <span class="hljs-built_in">ntohs</span>(cliaddr.sin_port));<br><br>    <span class="hljs-comment">// 数据传输</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">char</span> answer[<span class="hljs-number">4</span>] = <span class="hljs-string">&quot;ok&quot;</span>;<br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">recv</span>(cfd, buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(len &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Windows say:%s\n&quot;</span>, buf);<br>            <span class="hljs-built_in">send</span>(cfd, answer, <span class="hljs-built_in">sizeof</span>(answer), <span class="hljs-number">0</span>);<br><br>            std::vector&lt;<span class="hljs-type">char</span>*&gt; parts;<br>            <span class="hljs-type">char</span>* token = <span class="hljs-built_in">strtok</span>(buf, <span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-keyword">while</span>(token != <span class="hljs-literal">nullptr</span>)&#123;<br>                parts.<span class="hljs-built_in">push_back</span>(token);<br>                token = <span class="hljs-built_in">strtok</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (parts.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(parts[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;read&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(parts[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;exposure&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;执行--读取相机曝光函数--\n&quot;</span>);<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(parts[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;led&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;执行--读取投影仪led电流值函数--\n&quot;</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;读取错误，请重新读取\n&quot;</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(parts[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;set&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (parts.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">3</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(parts[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;exposure&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;曝光时间被设置为：%d\n&quot;</span>, std::<span class="hljs-built_in">stoi</span>(parts[<span class="hljs-number">2</span>]));<br>                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(parts[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;led&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;led电流值被设置为：%d\n&quot;</span>, std::<span class="hljs-built_in">stoi</span>(parts[<span class="hljs-number">2</span>]));<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;设置错误，请重新设置\n&quot;</span>);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;缺少设定值\n&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;命令格式错误\n&quot;</span>);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Windows break...\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;read&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭</span><br>    <span class="hljs-built_in">close</span>(cfd);<br>    <span class="hljs-built_in">close</span>(lfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Windows客户端"><a href="#Windows客户端" class="headerlink" title="Windows客户端"></a>Windows客户端</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;winsock2.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;Ws2_32.lib&quot;</span>)</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> PORT = <span class="hljs-number">27015</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* SERVER_ADDRESS = <span class="hljs-string">&quot;192.168.152.232&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    WSADATA wsaDate;<br>    SOCKET sock = INVALID_SOCKET;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> server;<br><br>    <span class="hljs-comment">// 1.初始化winsock</span><br>    <span class="hljs-type">int</span> iResult = <span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>), &amp;wsaDate);<br>    <span class="hljs-keyword">if</span>(iResult != <span class="hljs-number">0</span>)&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;WSAStartup failed: &quot;</span> &lt;&lt; <span class="hljs-built_in">WSAGetLastError</span>() &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 2.创建通信的套接字</span><br>    sock = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);<br>    <span class="hljs-keyword">if</span>(sock == INVALID_SOCKET)&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Socket creation failed: &quot;</span> &lt;&lt; <span class="hljs-built_in">WSAGetLastError</span>() &lt;&lt; std::endl;<br>        <span class="hljs-built_in">WSACleanup</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 3.连接服务器</span><br>    server.sin_family = AF_INET;<br>    server.sin_port = <span class="hljs-built_in">htons</span>(PORT);<br>    server.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(SERVER_ADDRESS);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(sock, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;server, <span class="hljs-built_in">sizeof</span>(server)) &lt; <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Connection failed: &quot;</span> &lt;&lt; <span class="hljs-built_in">WSAGetLastError</span>() &lt;&lt; std::endl;<br>        <span class="hljs-built_in">closesocket</span>(sock);<br>        <span class="hljs-built_in">WSACleanup</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 4.和服务器通信</span><br>    std::string input;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;Enter a word and a number (e.g., &#x27;read exposure or set exposure 1000&#x27;):\n&quot;</span>;<br>        std::<span class="hljs-built_in">getline</span>(std::cin, input);<br>        <span class="hljs-keyword">if</span>(input.<span class="hljs-built_in">empty</span>())&#123;<br>            std::cout&lt;&lt;<span class="hljs-string">&quot;please enter again.\n&quot;</span>&lt;&lt;std::endl;<br>        &#125;<br>        <span class="hljs-built_in">send</span>(sock, input.<span class="hljs-built_in">c_str</span>(), input.<span class="hljs-built_in">length</span>(), <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">closesocket</span>(sock);<br>    iResult = <span class="hljs-built_in">WSACleanup</span>();<br>    <span class="hljs-keyword">if</span> (iResult != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;WSACleanup failed: %d\n&quot;</span>, iResult);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h1><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><p>使用 <code>std::vector&lt;char*&gt;</code> 和 <code>strtok</code> 处理字符串时，可能遇到两个常见问题：</p><ol><li><strong>字符串比较问题</strong>：<code>parts[i]</code> 是一个 <code>char*</code>，不能直接使用 <code>==</code> 进行比较。这将比较指针的地址，而不是内容。需要使用 <code>strcmp</code> 来比较C风格字符串。</li><li><strong>访问越界问题</strong>：在访问 <code>parts[2]</code> 时（如 <code>std::stoi(parts[2])</code>），需要确保 <code>parts</code> 的大小足够，否则会导致访问越界。</li></ol><h2 id="strtok"><a href="#strtok" class="headerlink" title="strtok()"></a>strtok()</h2><p>头文件：string.h</p><p>函数功能：根据指定的分割符来分割一个字符串，并在连续的调用中返回分割后的每一个字串（会破坏原始字符串）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">strtok</span><span class="hljs-params">(<span class="hljs-type">char</span> *str, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *delim)</span></span>;<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li>str：指向要分割的字符串的指针</li><li>delim：分割符</li></ul><p>返回值：</p><ul><li>strtok()在第一次调用时，返回第一次找到的不包含分割符的子串的指针。在后续调用中，返回后续的子串。当没有子串可以返回时，返回NULL。</li></ul><p>示例用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;one,two,three&quot;</span>;<br>    <span class="hljs-type">char</span> *token;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *delim = <span class="hljs-string">&quot;,&quot;</span>;<br>    token = <span class="hljs-built_in">strtok</span>(str, delim);<br>    <span class="hljs-keyword">while</span> (token != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, token);<br>        token = <span class="hljs-built_in">strtok</span>(<span class="hljs-literal">NULL</span>, delim);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意事项：</p><ul><li><code>strtok()</code> 是非线程安全的，因为它使用了静态缓冲区来保存数据。如果需要线程安全，可以使用 <code>strtok_r()</code>。</li><li><code>strtok()</code> 会修改原始字符串，通过在每个分隔符的位置插入空字符（<code>&#39;\0&#39;</code>）来终止当前返回的子串。</li><li>在C++中也可以使用 <code>std::istringstream</code> 和 <code>std::getline</code> 来分割字符串。</li></ul><h2 id="getline"><a href="#getline" class="headerlink" title="getline()"></a>getline()</h2><p>头文件：string</p><p>函数功能：用于从输入流读取一行文本。可以读取包含空格在内的整行内容，直到遇到换行符为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::istream&amp; <span class="hljs-title">getline</span><span class="hljs-params">(std::istream&amp; is, std::string&amp; str)</span></span>;<br></code></pre></td></tr></table></figure><p>参数：</p><ul><li>is：输入流的引用，可以是std::cin</li><li>str：用于存储读取的行</li></ul><p>getline()和 <code>&gt;&gt;</code>的区别：</p><ul><li><code>&gt;&gt;</code>是输入流的提取运算符，用于从输入流中提取数据并将其存储在变量中。</li><li><code>&gt;&gt;</code>与std::cin一起使用时，会在遇到空白（空格，制表符，换行符）时停止读取。</li><li><code>&gt;&gt;</code>不包含空白字符在内，因此不适合读取包含空格的整行文本。当只需要读取单个单词或者值的时候使用 <code>&gt;&gt;</code>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式结构光三维重建项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>google benchmark 1</title>
    <link href="/2025/02/22/Tool/googleBM1/"/>
    <url>/2025/02/22/Tool/googleBM1/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> apt install g++ cmake<br>git <span class="hljs-built_in">clone</span> https://github.com/google/benchmark.git<br>git <span class="hljs-built_in">clone</span> https://github.com/google/googletest.git benchmark/googletest<br><span class="hljs-built_in">mkdir</span> build &amp;&amp; <span class="hljs-built_in">cd</span> build<br>cmake -DCMAKE_BUILD_TYPE=RELEASE ../benchmark<br>make -j4<br><span class="hljs-built_in">sudo</span> make install<br></code></pre></td></tr></table></figure><span id="more"></span><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;benchmark/benchmark.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br> <br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> len = <span class="hljs-number">6</span>;<br> <br><span class="hljs-comment">// constexpr function具有inline属性，你应该把它放在头文件中</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">my_pow</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> i * i;<br>&#125;<br> <br><span class="hljs-comment">// 使用operator[]读取元素，依次存入1-6的平方</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">bench_array_operator</span><span class="hljs-params">(benchmark::State&amp; state)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::array&lt;<span class="hljs-type">int</span>, len&gt; arr;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _: state) &#123;<br>        arr[<span class="hljs-number">0</span>] = <span class="hljs-built_in">my_pow</span>(i);<br>        arr[<span class="hljs-number">1</span>] = <span class="hljs-built_in">my_pow</span>(i<span class="hljs-number">+1</span>);<br>        arr[<span class="hljs-number">2</span>] = <span class="hljs-built_in">my_pow</span>(i<span class="hljs-number">+2</span>);<br>        arr[<span class="hljs-number">3</span>] = <span class="hljs-built_in">my_pow</span>(i<span class="hljs-number">+3</span>);<br>        arr[<span class="hljs-number">4</span>] = <span class="hljs-built_in">my_pow</span>(i<span class="hljs-number">+4</span>);<br>        arr[<span class="hljs-number">5</span>] = <span class="hljs-built_in">my_pow</span>(i<span class="hljs-number">+5</span>);<br>    &#125;<br>&#125;<br><span class="hljs-built_in">BENCHMARK</span>(bench_array_operator);<br> <br><span class="hljs-comment">// 使用at()读取元素，依次存入1-6的平方</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">bench_array_at</span><span class="hljs-params">(benchmark::State&amp; state)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::array&lt;<span class="hljs-type">int</span>, len&gt; arr;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _: state) &#123;<br>        arr.<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>) = <span class="hljs-built_in">my_pow</span>(i);<br>        arr.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>) = <span class="hljs-built_in">my_pow</span>(i<span class="hljs-number">+1</span>);<br>        arr.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>) = <span class="hljs-built_in">my_pow</span>(i<span class="hljs-number">+2</span>);<br>        arr.<span class="hljs-built_in">at</span>(<span class="hljs-number">3</span>) = <span class="hljs-built_in">my_pow</span>(i<span class="hljs-number">+3</span>);<br>        arr.<span class="hljs-built_in">at</span>(<span class="hljs-number">4</span>) = <span class="hljs-built_in">my_pow</span>(i<span class="hljs-number">+4</span>);<br>        arr.<span class="hljs-built_in">at</span>(<span class="hljs-number">5</span>) = <span class="hljs-built_in">my_pow</span>(i<span class="hljs-number">+5</span>);<br>    &#125;<br>&#125;<br><span class="hljs-built_in">BENCHMARK</span>(bench_array_at);<br> <br><span class="hljs-comment">// std::get&lt;&gt;(array)是一个constexpr function，它会返回容器内元素的引用，并在编译期检查数组的索引是否正确</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">bench_array_get</span><span class="hljs-params">(benchmark::State&amp; state)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::array&lt;<span class="hljs-type">int</span>, len&gt; arr;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> _: state) &#123;<br>        std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(arr) = <span class="hljs-built_in">my_pow</span>(i);<br>        std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">1</span>&gt;(arr) = <span class="hljs-built_in">my_pow</span>(i<span class="hljs-number">+1</span>);<br>        std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(arr) = <span class="hljs-built_in">my_pow</span>(i<span class="hljs-number">+2</span>);<br>        std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">3</span>&gt;(arr) = <span class="hljs-built_in">my_pow</span>(i<span class="hljs-number">+3</span>);<br>        std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">4</span>&gt;(arr) = <span class="hljs-built_in">my_pow</span>(i<span class="hljs-number">+4</span>);<br>        std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">5</span>&gt;(arr) = <span class="hljs-built_in">my_pow</span>(i<span class="hljs-number">+5</span>);<br>    &#125;<br>&#125;<br><span class="hljs-built_in">BENCHMARK</span>(bench_array_get);<br> <br><span class="hljs-built_in">BENCHMARK_MAIN</span>();<br></code></pre></td></tr></table></figure><p>上述代码使用Google Benchmark库对 C++ 中访问和更新 <code>std::array</code> 元素的不同方法进行性能测试。</p><ol><li>基准测试函数：<ul><li><code>bench_array_operator</code>：使用operator[]访问和更新数组</li><li><code>bench_array_at</code>：使用arr.at()方法访问和更新数组</li><li><code>bench_array_get</code>：使用std::get&lt;&gt;模板函数访问和更新数组</li></ul></li><li>基准测试注册：<ul><li>使用 <code>BENCHMARK(bench_array_operator);</code>注册每个基准测试函数，从而Google Benchmark工具知道需要运行哪些测试。</li></ul></li><li>程序入口函数：<ul><li>使用 <code>BENCHMARK_MAIN()</code>定义程序入口函数，并初始化Google Benchmark库，它会自动运行被注册的所有基准测试。</li></ul></li></ol><h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">$ g++ -Wall -std=c+<span class="hljs-number">+14</span> arrayTest.cpp -pthread -lbenchmark<br>$ ./a.out<br><span class="hljs-number">2024</span><span class="hljs-number">-12</span><span class="hljs-number">-17</span>T13:<span class="hljs-number">04</span>:<span class="hljs-number">52</span><span class="hljs-number">+0</span>8:<span class="hljs-number">00</span><br>Running ./a.out<br>Run <span class="hljs-built_in">on</span> (<span class="hljs-number">12</span> X <span class="hljs-number">2995.2</span> MHz CPU s)<br>CPU Caches:<br>  L1 Data <span class="hljs-number">48</span> <span class="hljs-built_in">KiB</span> (x6)<br>  L1 Instruction <span class="hljs-number">32</span> <span class="hljs-built_in">KiB</span> (x6)<br>  L2 Unified <span class="hljs-number">1280</span> <span class="hljs-built_in">KiB</span> (x6)<br>  L3 Unified <span class="hljs-number">20480</span> <span class="hljs-built_in">KiB</span> (x1)<br>Load Average: <span class="hljs-number">0.31</span>, <span class="hljs-number">0.29</span>, <span class="hljs-number">0.14</span><br>---------------------------------------------------------------<br>Benchmark                     Time             CPU   Iterations<br>---------------------------------------------------------------<br>bench_array_operator       <span class="hljs-number">18.5</span> ns         <span class="hljs-number">18.5</span> ns     <span class="hljs-number">39134698</span><br>bench_array_at             <span class="hljs-number">23.3</span> ns         <span class="hljs-number">23.3</span> ns     <span class="hljs-number">31354014</span><br>bench_array_get            <span class="hljs-number">18.6</span> ns         <span class="hljs-number">18.6</span> ns     <span class="hljs-number">39320276</span><br></code></pre></td></tr></table></figure><ol><li><p>执行日期和时间：</p><ul><li>“2024-12-17T13:04:52+08:00” 表示基准测试进行的时间以及时区。</li></ul></li><li><p>系统信息：</p><ul><li>测试是在一个拥有12个逻辑CPU，每个运行在2995.2 MHz上的系统上进行的。CPU缓存层次结构如下：<ul><li>L1数据缓存：每个核心48 KiB（共有6个核心）</li><li>L1指令缓存：每个核心32 KiB（共有6个核心）</li><li>L2统一缓存：每个核心1280 KiB（共有6个核心）</li><li>L3统一缓存：共有20480 KiB（这通常是共享缓存）</li></ul></li></ul></li><li><p>系统负载：</p><ul><li>“Load Average: 0.31, 0.29, 0.14” 代表系统在过去1分钟、5分钟和15分钟的平均负载。</li></ul></li><li><p>基准测试结果：</p><ul><li><code>bench_array_operator</code>， <code>bench_array_at</code> 和 <code>bench_array_get</code> 是测试的三个函数，用于访问数组元素。</li><li><code>Time</code> 和 <code>CPU</code> 列显示了执行这些操作的时间。测量值通常为纳秒（ns）。</li><li><code>Iterations</code> 列显示了在测试过程中运行的迭代次数。</li></ul></li></ol><p>从结果看，<code>bench_array_operator</code> 和 <code>bench_array_get</code> 的性能较好，执行时间较短，而 <code>bench_array_at</code> 的执行时间稍长。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>benchmark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gtest官方示例代码</title>
    <link href="/2025/02/22/Tool/sourceRead/"/>
    <url>/2025/02/22/Tool/sourceRead/</url>
    
    <content type="html"><![CDATA[<h1 id="gtest-main"><a href="#gtest-main" class="headerlink" title="gtest_main"></a>gtest_main</h1><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gtest/gtest.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(GTEST_OS_ESP8266) || defined(GTEST_OS_ESP32) || (defined(GTEST_OS_NRF52) &amp;&amp; defined(ARDUINO)) <span class="hljs-comment">// ****#if-level-1****</span></span><br><span class="hljs-comment">// Arduino-like platforms: program entry points are setup/loop instead of main.</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GTEST_OS_ESP8266<span class="hljs-comment">// ****#ifdef-level-2-1****</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span><span class="hljs-comment">// ****#endif-level-2-1****</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>&#123; testing::<span class="hljs-built_in">InitGoogleTest</span>(); &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">RUN_ALL_TESTS</span>(); &#125;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GTEST_OS_ESP8266<span class="hljs-comment">// ****#ifdef-level-2-2****</span></span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span><span class="hljs-comment">// ****#endif-level-2-2****</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(GTEST_OS_QURT)<span class="hljs-comment">// ****#elif-level-1****</span></span><br><span class="hljs-comment">// QuRT: program entry point is main, but argc/argv are unusable.</span><br><br><span class="hljs-function">GTEST_API_ <span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Running main() from %s\n&quot;</span>, __FILE__);<br>  testing::<span class="hljs-built_in">InitGoogleTest</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">RUN_ALL_TESTS</span>();<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span><span class="hljs-comment">// ****#else-level-1****</span></span><br><span class="hljs-comment">// Normal platforms: program entry point is main, argc/argv are initialized.</span><br><br><span class="hljs-function">GTEST_API_ <span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Running main() from %s\n&quot;</span>, __FILE__);<br>  testing::<span class="hljs-built_in">InitGoogleTest</span>(&amp;argc, argv);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">RUN_ALL_TESTS</span>();<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span><span class="hljs-comment">// ****end-level-1****</span></span><br></code></pre></td></tr></table></figure><p>通过level可以比较清楚的看清逻辑结构：</p><ol><li><p>如果定义了以下宏，则运行下面这部分代码：</p><ul><li><code>GTEST_OS_ESP8266</code>：表示编译目标是 ESP8266 平台</li><li><code>GTEST_OS_ESP32</code>：表示编译目标是 ESP32 平台</li><li><code>(defined(GTEST_OS_NRF52) &amp;&amp; defined(ARDUINO))</code>：表示编译目标是 Nordic nRF52 系列的设备，并且是在 Arduino 环境下编译</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GTEST_OS_ESP8266<span class="hljs-comment">// ****#ifdef-level-2-1****</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span><span class="hljs-comment">// ****#endif-level-2-1****</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>&#123; testing::<span class="hljs-built_in">InitGoogleTest</span>(); &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">RUN_ALL_TESTS</span>(); &#125;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> GTEST_OS_ESP8266<span class="hljs-comment">// ****#ifdef-level-2-2****</span></span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ol start="2"><li>如果定义了 <code>GTEST_OS_QURT</code> 宏，即再QuRT操作系统上编译运行，则执行下面这部分代码：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">GTEST_API_ <span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Running main() from %s\n&quot;</span>, __FILE__);<br>  testing::<span class="hljs-built_in">InitGoogleTest</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">RUN_ALL_TESTS</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>如果是除此之外的其他平台则运行下面这部分代码：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">GTEST_API_ <span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Running main() from %s\n&quot;</span>, __FILE__);<br>  testing::<span class="hljs-built_in">InitGoogleTest</span>(&amp;argc, argv);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">RUN_ALL_TESTS</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="进一步解析"><a href="#进一步解析" class="headerlink" title="进一步解析"></a>进一步解析</h2><ol><li>根据注释，对于类似Arduino平台，程序的入口点是setup&#x2F;loop，而不是main，所以需要单独编写；<ol><li>在setup函数中初始化；</li><li>在loop函数中运行所有测试；</li></ol></li><li>但是对于ESP8266平台，需要使用C链接，除了它之外的另外三个则不需要，所以单独将它进行C链接的”开关”打开；</li><li>对于QuRT平台，程序的入口点是main，但是不能用argc&#x2F;argv；</li><li>对于其他的普通平台如Linux，程序的入口点是main，并且可以使用argc&#x2F;argv;</li></ol>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>gtest</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gtest入门-1</title>
    <link href="/2025/02/22/Tool/gtest-1/"/>
    <url>/2025/02/22/Tool/gtest-1/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/google/googletest.git<br>$ <span class="hljs-built_in">cd</span> googletest<br>$ <span class="hljs-built_in">mkdir</span> build<br>$ <span class="hljs-built_in">cd</span> build<br>$ cmake ..<br>$ make<br>$ <span class="hljs-built_in">sudo</span> make install<br></code></pre></td></tr></table></figure><span id="more"></span><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;gtest/gtest.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Foo</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == a||<span class="hljs-number">0</span> == b)<br>   <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;don&#x27;t do that&quot;</span>;<br>   <span class="hljs-type">int</span> c = a%b;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == c)<br>  &#123;<br>     <span class="hljs-keyword">return</span> b;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Foo</span>(b,c);<br>&#125;<br>  <br><span class="hljs-built_in">TEST</span>(FooTest,HandleNoneZeroInput)<br>&#123;<br>   <span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-number">2</span>,<span class="hljs-built_in">Foo</span>(<span class="hljs-number">4</span>,<span class="hljs-number">10</span>));<br>   <span class="hljs-built_in">EXPECT_EQ</span>(<span class="hljs-number">6</span>,<span class="hljs-built_in">Foo</span>(<span class="hljs-number">30</span>,<span class="hljs-number">18</span>));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>*argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>   testing::<span class="hljs-built_in">InitGoogleTest</span>(&amp;argc,argv);<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">RUN_ALL_TESTS</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ g++ -o app first.cpp -lgtest -lpthread -std=c++14<br>$ ./app <br>[==========] Running 1 <span class="hljs-built_in">test</span> from 1 <span class="hljs-built_in">test</span> suite.<br>[----------] Global <span class="hljs-built_in">test</span> environment set-up.<br>[----------] 1 <span class="hljs-built_in">test</span> from FooTest<br>[ RUN      ] FooTest.HandleNoneZeroInput<br>[       OK ] FooTest.HandleNoneZeroInput (0 ms)<br>[----------] 1 <span class="hljs-built_in">test</span> from FooTest (0 ms total)<br><br>[----------] Global <span class="hljs-built_in">test</span> environment tear-down<br>[==========] 1 <span class="hljs-built_in">test</span> from 1 <span class="hljs-built_in">test</span> suite ran. (0 ms total)<br>[  PASSED  ] 1 <span class="hljs-built_in">test</span>.<br></code></pre></td></tr></table></figure><h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><ol><li>头文件gtest&#x2F;gtest.h；</li><li>使用TEST宏定义测试，两个参数：测试用例名，测试名，这两个参数只是起到提示作用；</li><li>在main中调用RUN_ALL_TESTS()；</li></ol><h1 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h1><ul><li><strong><code>--gtest_list_tests</code></strong> ：当使用这个参数时，gtest 将不会执行任何测试用例，而是列出所有可用的测试用例名称。</li><li><strong><code>--gtest_filter=&lt;test_filters&gt;</code></strong> ：允许对执行的测试用例进行过滤。<code>&lt;test_filters&gt;</code> 可以是一个或多个测试用例名称的模式，支持通配符（如 <code>*</code> 和 <code>?</code>）。例如，<code>--gtest_filter=*DeathTest*</code> 将运行所有名称中包含 “DeathTest” 的测试用例。</li><li><strong><code>--gtest_also_run_disabled_tests</code></strong> ：默认情况下，gtest 会跳过那些被标记为 <code>DISABLED_</code> 的测试用例。使用这个参数可以强制执行这些被禁用的测试用例。</li><li><strong><code>--gtest_repeat=&lt;count&gt;</code></strong> ：设置测试用例重复运行的次数。<code>&lt;count&gt;</code> 是一个正整数，表示每个测试用例将被重复执行的次数。例如，<code>--gtest_repeat=3</code> 将使每个测试用例运行三次。</li><li><strong><code>--gtest_color=(yes|no|auto)</code></strong> ：控制命令行输出是否使用颜色。<code>yes</code> 表示始终使用颜色，<code>no</code> 表示不使用颜色，<code>auto</code>（默认）表示根据终端是否支持颜色自动决定。</li><li><strong><code>--gtest_print_time</code></strong> ：当启用时，gtest 将在输出中打印每个测试用例的执行时间。默认情况下，gtest 不打印每个测试用例的执行时间。</li><li><strong><code>--gtest_output=xml[:DIRECTORY_PATH|:FILE_PATH]</code></strong> ：将测试结果输出到一个 XML 文件中。如果不指定文件路径，gtest 将在当前目录下生成一个名为 <code>test_detail.xml</code> 的文件，并在每次运行时以数字后缀的方式创建新文件，以避免覆盖。</li><li><strong><code>--gtest_break_on_failure</code></strong> ：在调试模式下，当测试失败时，gtest 将中断执行。</li><li><strong><code>--gtest_throw_on_failure</code></strong> ：当测试失败时，gtest 将抛出一个 C++ 异常。</li><li><strong><code>--gtest_catch_exceptions</code></strong> ：控制 gtest 是否捕捉测试执行过程中抛出的异常。默认情况下，gtest 不捕捉异常。这个参数主要在 Windows 平台上有效。</li></ul><p>使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./app --gtest_list_tests<br>FooTest.<br>  HandleNoneZeroInput<br><br><br><br>$ ./app --gtest_repeat=3<br><br>Repeating all tests (iteration 1) . . .<br><br>[==========] Running 1 <span class="hljs-built_in">test</span> from 1 <span class="hljs-built_in">test</span> suite.<br>[----------] Global <span class="hljs-built_in">test</span> environment set-up.<br>[----------] 1 <span class="hljs-built_in">test</span> from FooTest<br>[ RUN      ] FooTest.HandleNoneZeroInput<br>[       OK ] FooTest.HandleNoneZeroInput (0 ms)<br>[----------] 1 <span class="hljs-built_in">test</span> from FooTest (0 ms total)<br><br>[==========] 1 <span class="hljs-built_in">test</span> from 1 <span class="hljs-built_in">test</span> suite ran. (0 ms total)<br>[  PASSED  ] 1 <span class="hljs-built_in">test</span>.<br><br>Repeating all tests (iteration 2) . . .<br><br>[==========] Running 1 <span class="hljs-built_in">test</span> from 1 <span class="hljs-built_in">test</span> suite.<br>[----------] 1 <span class="hljs-built_in">test</span> from FooTest<br>[ RUN      ] FooTest.HandleNoneZeroInput<br>[       OK ] FooTest.HandleNoneZeroInput (0 ms)<br>[----------] 1 <span class="hljs-built_in">test</span> from FooTest (0 ms total)<br><br>[==========] 1 <span class="hljs-built_in">test</span> from 1 <span class="hljs-built_in">test</span> suite ran. (0 ms total)<br>[  PASSED  ] 1 <span class="hljs-built_in">test</span>.<br><br>Repeating all tests (iteration 3) . . .<br><br>[==========] Running 1 <span class="hljs-built_in">test</span> from 1 <span class="hljs-built_in">test</span> suite.<br>[----------] 1 <span class="hljs-built_in">test</span> from FooTest<br>[ RUN      ] FooTest.HandleNoneZeroInput<br>[       OK ] FooTest.HandleNoneZeroInput (0 ms)<br>[----------] 1 <span class="hljs-built_in">test</span> from FooTest (0 ms total)<br><br>[----------] Global <span class="hljs-built_in">test</span> environment tear-down<br>[==========] 1 <span class="hljs-built_in">test</span> from 1 <span class="hljs-built_in">test</span> suite ran. (0 ms total)<br>[  PASSED  ] 1 <span class="hljs-built_in">test</span>.<br></code></pre></td></tr></table></figure><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>gtest使用一系列断言的宏来检查是否符合预期，主要分为两类：ASSERT和EXPECT</p><ul><li>ASSERT：不通过的时候会认为是一个fatal的错误，退出当前函数；</li><li>EXPECT：失败的话会继续运行当前函数，所以对于函数内几个失败可以同时报告出来；</li></ul><h3 id="基础断言"><a href="#基础断言" class="headerlink" title="基础断言"></a>基础断言</h3><table><thead><tr><th>ASSERT</th><th>EXPECT</th><th>Verifiles</th></tr></thead><tbody><tr><td>ASSERT_TRUE(condition);</td><td>EXPECT_TRUE(condition);</td><td>condition is true</td></tr><tr><td>ASSERT_FALSE(condition);</td><td>EXPECT_FALSE(condition);</td><td>condition is false</td></tr></tbody></table><h3 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h3><table><thead><tr><th>ASSERT</th><th>EXPECT</th><th>Verifiles</th></tr></thead><tbody><tr><td>ASSERT_EQ(val1, val2);</td><td>EXPECT_EQ(val1, val2);</td><td>val1 &#x3D;&#x3D; val2</td></tr><tr><td>ASSERT_NE(val1, val2);</td><td>EXPECT_NE(val1, val2);</td><td>val1 !&#x3D; val2</td></tr><tr><td>ASSERT_LT(val1, val2);</td><td>EXPECT_LT(val1, val2);</td><td>val1 &lt; val2</td></tr><tr><td>ASSERT_LE(val1, val2);</td><td>EXPECT_LE(val1, val2);</td><td>val1 &lt;&#x3D; val2</td></tr><tr><td>ASSERT_GT(val1, val2);</td><td>EXPECT_GT(val1, val2);</td><td>val1 &gt; val2</td></tr><tr><td>ASSERT_GE(val1, val2);</td><td>EXPECT_GE(val1, val2);</td><td>val1 &gt;&#x3D; val2</td></tr></tbody></table><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><table><thead><tr><th>ASSERT</th><th>EXPECT</th><th>Verifiles</th></tr></thead><tbody><tr><td>ASSERT_STREQ(str1, str2);</td><td>EXPECT_STREQ(str1, str2);</td><td>same content</td></tr><tr><td>ASSERT_STRNE(str1, str2);</td><td>EXPECT_STREQ(str1, str2);</td><td>different content</td></tr><tr><td>ASSERT_STRCASEEQ(str1, str2);</td><td>EXPECT_STRCASEEQ(str1, str2);</td><td>same content, ignoring case</td></tr><tr><td>ASSERT_STRCASENE(str1, str2);</td><td>EXPECT_STRCASEEQ(str1, str2);</td><td>different content, ignoring case</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>gtest</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git分支管理Hexo</title>
    <link href="/2025/02/22/blog/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86Hexo/"/>
    <url>/2025/02/22/blog/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86Hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="1-本地初始电脑"><a href="#1-本地初始电脑" class="headerlink" title="1.本地初始电脑"></a>1.本地初始电脑</h1><p>1.初始化Git仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> blog<br>$ git init  <span class="hljs-comment"># 创建.git子目录</span><br></code></pre></td></tr></table></figure><span id="more"></span><p>2.添加远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote add origin git@github.com:yourname/yourname.github.io.git<br></code></pre></td></tr></table></figure><p>3.拉取远端仓库所有内容及分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git fetch origin<br></code></pre></td></tr></table></figure><p>5.新建分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b master<br></code></pre></td></tr></table></figure><p>4.在<code>./source/_post/</code>中添加.md博客并生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br>$ hexo g<br>$ hexo d<br></code></pre></td></tr></table></figure><p>5.将本地仓库推送至远端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin master<br></code></pre></td></tr></table></figure><h1 id="2-其他电脑"><a href="#2-其他电脑" class="headerlink" title="2.其他电脑"></a>2.其他电脑</h1><p>1.安装Node.js</p><p>2.拉取远端仓库并进入文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git@github.com:yourname/yourname.github.io.git blogname<br>$ <span class="hljs-built_in">cd</span> blogname<br></code></pre></td></tr></table></figure><p>3.拉取远端仓库分支并切换至master分支（默认分支是main，master分支是自己建的）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git fetch origin<br>$ git checkout master<br></code></pre></td></tr></table></figure><p>4.安装Hexo及相关依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo<span class="hljs-comment"># 安装hexo</span><br>$ npm install hexo-cli -g <span class="hljs-comment"># 重新安装(如果上述安装不起作用）</span><br>$ npm install<span class="hljs-comment"># 安装依赖</span><br></code></pre></td></tr></table></figure><p>5.安装<code>deploy-git</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>6.在<code>./source/_post/</code>中添加.md博客并生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br>$ hexo g<br>$ hexo d<br></code></pre></td></tr></table></figure><p>8.将本地仓库推送至远端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin master<br></code></pre></td></tr></table></figure><h1 id="3-更换主题"><a href="#3-更换主题" class="headerlink" title="3.更换主题"></a>3.更换主题</h1><p>1.进入<code>./themes</code>文件夹</p><p>2.github上clone喜欢的主题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git@github.com:xxx/xxx.git file-name<br></code></pre></td></tr></table></figure><p>3.进入<code>file-name</code>文件夹</p><p>4.删除.git文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">rm</span> -r .git<br></code></pre></td></tr></table></figure><p>5.修改最外层目录下的<code>_config.yml</code>文件<br>theme: file-name</p><p>6.修改.gitignore文件（或者把里面内容删掉也行）</p><p>7.将本地仓库推送至远端</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-string">$ </span>git add .<br><span class="hljs-string">$ </span>git commit -m <span class="hljs-string">&quot;add theme&quot;</span><br><span class="hljs-string">$ </span>git push origin master<br></code></pre></td></tr></table></figure><p>ps.修改好主题之后，主题配置在<code>file-name</code>文件夹中的<code>_config.yml</code>中进行配置。</p><h1 id="4-说明"><a href="#4-说明" class="headerlink" title="4.说明"></a>4.说明</h1><p><code>main</code>分支用来部署博客：当执行<code>hexo d</code>的时候，博客部署在<code>main</code>分支，不需要执行<code>git push origin main</code>，因为<code>hexo d</code>指令已经将相应的<code>html</code>文件推送到远端服务器的<code>main</code>分支上了。<br><code>master</code>分支用来存储文件：比如<code>.md</code>文件，存放在<code>./source/_post</code>文件夹中，最后需要手动执行<code>git push origin master</code>。</p>]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo搭建个人博客</title>
    <link href="/2025/02/22/blog/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2025/02/22/blog/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前置条件"><a href="#1-前置条件" class="headerlink" title="1.前置条件"></a>1.前置条件</h1><ul><li><a href="https://nodejs.org/en/download/package-manager/current">Node.js</a></li><li><a href="https://git-scm.com/">git</a></li><li>Github Pages</li></ul><span id="more"></span><h1 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2.安装Node.js"></a>2.安装Node.js</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># installs nvm (Node Version Manager)</span><br>$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash<br><br><span class="hljs-comment"># download and install Node.js (you may need to restart the terminal)</span><br>$ nvm install 22<br><br><span class="hljs-comment"># verifies the right Node.js version is in the environment</span><br>$ node -v <span class="hljs-comment"># should print `v22.6.0`</span><br><br><span class="hljs-comment"># verifies the right npm version is in the environment</span><br>$ npm -v <span class="hljs-comment"># should print `10.8.2`</span><br></code></pre></td></tr></table></figure><h1 id="3-本地运行Hexo"><a href="#3-本地运行Hexo" class="headerlink" title="3.本地运行Hexo"></a>3.本地运行Hexo</h1><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> blog<br>$ <span class="hljs-built_in">cd</span> blog<br>$ npm install -g hexo-cli   <span class="hljs-comment"># 安装hexo</span><br>$ hexo init                 <span class="hljs-comment"># 初始化hexo</span><br>$ hexo install              <span class="hljs-comment"># 安装需要的包</span><br></code></pre></td></tr></table></figure><p>初始化完成后项目文件夹如下所示：<br>.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes          </p><h2 id="Hexo的用法"><a href="#Hexo的用法" class="headerlink" title="Hexo的用法"></a>Hexo的用法</h2><ul><li>启动内置预览服务（默认端口4000）  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo s    <span class="hljs-comment"># hexo serve</span><br></code></pre></td></tr></table></figure></li><li>生成网站  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g    <span class="hljs-comment"># hexo generate</span><br></code></pre></td></tr></table></figure></li><li>部署到Github Pages上（部署之前需要配置）  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo d    <span class="hljs-comment"># hexo deploy</span><br><br><span class="hljs-comment"># 生成并部署，省去hexo g</span><br>$ hexo d -g<br></code></pre></td></tr></table></figure></li><li>#清除缓存文件db.json和已生成的静态文件 public  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo c    <span class="hljs-comment"># hexo clean</span><br></code></pre></td></tr></table></figure></li><li>创建博客  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建完成后博客的.md文件存储在`./source/_post/`中</span><br>$ hexo new <span class="hljs-string">&quot;blog name&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h1><p>_config.yml</p><ul><li>title : 网站标题</li><li>subtitle : 副标题</li><li>description : 网站描述</li><li>keywords : 网站关键词</li><li>author : 作者</li><li>language : 语言</li><li>timezone : 时区</li></ul><p>以上设置会出现在meta里。</p><ul><li>url : 网址</li><li>root : 网站根目录</li><li>permalink : 永久链接格式，比如year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</li><li>source_dir : 源文件夹，默认source</li><li>public_dir : 生成的网站文件夹</li><li>theme : 主题</li></ul><p>官网关于配置的描述：<a href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a></p><h1 id="4-部署到Github-Pages"><a href="#4-部署到Github-Pages" class="headerlink" title="4.部署到Github Pages"></a>4.部署到Github Pages</h1><p>0.配置github的SSH<br>1.创建repo:git@github:yourname&#x2F;yourname.github.io.git<br>2.修改配置文件<code>_config.yml</code></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-params">deploy:</span><br>  <span class="hljs-params">type:</span> git<br>  <span class="hljs-params">repo:</span> git@github.com:yourname<span class="hljs-symbol">/yourname.github.io.git</span><br>  <span class="hljs-params">branch:</span> main<br></code></pre></td></tr></table></figure><p>4.安装<code>deploy-git</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm  install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://hexo.io/docs/">Hexo官网</a></li><li><a href="https://www.luogu.com.cn/article/vglpq15p">从零搭建 Hexo + Github 博客</a></li><li><a href="https://note.tonycrane.cc/cs/tools/hexo/">Hexo 使用记录</a></li><li><a href="https://hexo.io/zh-cn/docs/writing">Hexo写作</a></li><li><a href="https://github.com/ppoffice/hexo-theme-icarus">主题</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Jetson刷机</title>
    <link href="/2025/02/22/StructLight/Jetson/Jetson%E5%88%B7%E6%9C%BA/"/>
    <url>/2025/02/22/StructLight/Jetson/Jetson%E5%88%B7%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li>Ubuntu20.04系统的PC机</li><li>USB-TypeC转接线</li><li>Jetson</li></ul><span id="more"></span><h1 id="刷机系统"><a href="#刷机系统" class="headerlink" title="刷机系统"></a>刷机系统</h1><p>step1：准备Ubuntu20.04版本PC机<br>虚拟机也可以，但是要求分配的内存要<strong>大于120G</strong>，因为下载的jetpack安装包很大。<br>Ubuntu20.04版本对应jetpack 5.1.3版本</p><p>step2：下载SDK manager<br><a href="https://developer.nvidia.com/sdk-manager">SDK manager</a>是官方提供的刷机软件</p><p>step3：USB线连接Jetson和PC机</p><p>step4：Jetson进入Recovery模式<br>方式一：Jetson关机状态时，长按SW3（REC按键）然后接通电源线，等待PC机上弹出连接成功，松开SW3<br>方式二：Jetson开机状态时，需要先长按住SW3（REC按键），然后按下SW2(Reset键)，先松开SW2(Reset键)，再松开SW3（REC按键）。</p><p>step5：SDK manager选择刷机版本</p><ul><li>取消勾选Host Machine</li><li>jetpack版本选择5.1.3</li></ul><p>step5：刷Jetson Linux<br>刷系统就可以了。组件可以先不刷，直接在Jetson上联网使用apt安装</p><h1 id="安装组件"><a href="#安装组件" class="headerlink" title="安装组件"></a>安装组件</h1><p>step1：安装官方组件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> apt update <br>$ <span class="hljs-built_in">sudo</span> apt install nvidia-jetpack<br></code></pre></td></tr></table></figure><p>step2：补全环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> apt update<br>$ <span class="hljs-built_in">sudo</span> apt install python3<br>$ <span class="hljs-built_in">sudo</span> apt install python3-pip<br></code></pre></td></tr></table></figure><p>step3：安装jtop</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> pip3 install -U pip<br>$ <span class="hljs-built_in">sudo</span> pip3 install jetson-stats<br></code></pre></td></tr></table></figure><p>可以使用jtop查看组件版本。</p><h1 id="安装cuda-11-4"><a href="#安装cuda-11-4" class="headerlink" title="安装cuda 11.4"></a>安装cuda 11.4</h1><p>step1：浏览器搜索“cuda 11.4”找到官网<a href="https://developer.nvidia.com/cuda-11-4-0-download-archive">CUDA Toolkit 11.4 Downloads - NVIDIA Developer</a><br>step2：Linux-&gt;arm64-sbsa-&gt;Native-&gt;Ubuntu-&gt;20.04-&gt;deb(network)<br>step3：运行官网提供的对应命令行<br>step4：添加cuda的环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> vim ~/.bashrc<br></code></pre></td></tr></table></figure><p>在其中添加环境路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=/usr/local/cuda-11.4/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>重新加载.bashrc文件，以便立即生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure><p>查看CUDA版本信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ nvcc --version<br></code></pre></td></tr></table></figure><h1 id="question"><a href="#question" class="headerlink" title="question"></a>question</h1><p><strong>什么是native compiler？什么是cross compiler？</strong></p><ul><li>build - 编译GCC的平台</li><li>host - 运行GCC的平台</li><li>target - GCC编译产生的应用程序的运行平台</li></ul><ol><li>三者全部相同（build &#x3D; host &#x3D; target）的就是native compiler，例如我们在PC上装的Ubuntu或者Fedora里面带的GCC，就是native compiler。</li><li>如果build &#x3D; host，但是target跟前两者不同，就是cross compiler。比如开发手机应用程序的编译器，通常运行在PC或Mac上，但是编译出来的程序无法直接在PC或Mac上执行。</li><li>三者都不同的话，叫做Canadian cross。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Jetson</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Grab Multiple Camera</title>
    <link href="/2025/02/22/StructLight/camera/GrabMulCamera/"/>
    <url>/2025/02/22/StructLight/camera/GrabMulCamera/</url>
    
    <content type="html"><![CDATA[<ol><li>示例代码</li><li>相机控制流程</li><li>函数用法</li></ol><span id="more"></span><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MvCameraControl.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CAMERA_NUM             2</span><br><br><span class="hljs-type">bool</span> g_bExit = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 等待用户输入enter键来结束取流或结束程序</span><br><span class="hljs-comment">// wait for user to input enter to stop grabbing or end the sample program</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PressEnterToExit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> c;<br>    <span class="hljs-keyword">while</span> ( (c = <span class="hljs-built_in">getchar</span>()) != <span class="hljs-string">&#x27;\n&#x27;</span> &amp;&amp; c != EOF );<br>    <span class="hljs-built_in">fprintf</span>( stderr, <span class="hljs-string">&quot;\nPress enter to exit.\n&quot;</span>);<br>    <span class="hljs-keyword">while</span>( <span class="hljs-built_in">getchar</span>() != <span class="hljs-string">&#x27;\n&#x27;</span>);<br>    g_bExit = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PrintDeviceInfo</span><span class="hljs-params">(MV_CC_DEVICE_INFO* pstMVDevInfo)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pstMVDevInfo)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The Pointer of pstMVDevInfo is NULL!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pstMVDevInfo-&gt;nTLayerType == MV_GIGE_DEVICE)<br>    &#123;<br>        <span class="hljs-type">int</span> nIp1 = ((pstMVDevInfo-&gt;SpecialInfo.stGigEInfo.nCurrentIp &amp; <span class="hljs-number">0xff000000</span>) &gt;&gt; <span class="hljs-number">24</span>);<br>        <span class="hljs-type">int</span> nIp2 = ((pstMVDevInfo-&gt;SpecialInfo.stGigEInfo.nCurrentIp &amp; <span class="hljs-number">0x00ff0000</span>) &gt;&gt; <span class="hljs-number">16</span>);<br>        <span class="hljs-type">int</span> nIp3 = ((pstMVDevInfo-&gt;SpecialInfo.stGigEInfo.nCurrentIp &amp; <span class="hljs-number">0x0000ff00</span>) &gt;&gt; <span class="hljs-number">8</span>);<br>        <span class="hljs-type">int</span> nIp4 = (pstMVDevInfo-&gt;SpecialInfo.stGigEInfo.nCurrentIp &amp; <span class="hljs-number">0x000000ff</span>);<br><br>        <span class="hljs-comment">// ch:打印当前相机ip和用户自定义名字 | en:print current ip and user defined name</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Device Model Name: %s\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stGigEInfo.chModelName);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;CurrentIp: %d.%d.%d.%d\n&quot;</span> , nIp1, nIp2, nIp3, nIp4);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;UserDefinedName: %s\n\n&quot;</span> , pstMVDevInfo-&gt;SpecialInfo.stGigEInfo.chUserDefinedName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pstMVDevInfo-&gt;nTLayerType == MV_USB_DEVICE)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Device Model Name: %s\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stUsb3VInfo.chModelName);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;UserDefinedName: %s\n\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stUsb3VInfo.chUserDefinedName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pstMVDevInfo-&gt;nTLayerType == MV_GENTL_GIGE_DEVICE)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;UserDefinedName: %s\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stGigEInfo.chUserDefinedName);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Serial Number: %s\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stGigEInfo.chSerialNumber);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Model Name: %s\n\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stGigEInfo.chModelName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pstMVDevInfo-&gt;nTLayerType == MV_GENTL_CAMERALINK_DEVICE)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;UserDefinedName: %s\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stCMLInfo.chUserDefinedName);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Serial Number: %s\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stCMLInfo.chSerialNumber);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Model Name: %s\n\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stCMLInfo.chModelName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pstMVDevInfo-&gt;nTLayerType == MV_GENTL_CXP_DEVICE)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;UserDefinedName: %s\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stCXPInfo.chUserDefinedName);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Serial Number: %s\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stCXPInfo.chSerialNumber);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Model Name: %s\n\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stCXPInfo.chModelName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pstMVDevInfo-&gt;nTLayerType == MV_GENTL_XOF_DEVICE)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;UserDefinedName: %s\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stXoFInfo.chUserDefinedName);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Serial Number: %s\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stXoFInfo.chSerialNumber);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Model Name: %s\n\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stXoFInfo.chModelName);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Not support.\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title">WorkThread</span><span class="hljs-params">(<span class="hljs-type">void</span>* pUser)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> nRet = MV_OK;<br><br>    MVCC_STRINGVALUE stStringValue = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">char</span> camSerialNumber[<span class="hljs-number">256</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    nRet = <span class="hljs-built_in">MV_CC_GetStringValue</span>(pUser, <span class="hljs-string">&quot;DeviceSerialNumber&quot;</span>, &amp;stStringValue);<br>    <span class="hljs-keyword">if</span> (MV_OK == nRet)<br>    &#123;<br>        <span class="hljs-built_in">memcpy</span>(camSerialNumber, stStringValue.chCurValue, <span class="hljs-built_in">sizeof</span>(stStringValue.chCurValue));<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Get DeviceUserID Failed! nRet = [%x]\n&quot;</span>, nRet);<br>    &#125;<br><br>    <span class="hljs-comment">// ch:获取数据包大小 | en:Get payload size</span><br>    MVCC_INTVALUE stParam;<br>    <span class="hljs-built_in">memset</span>(&amp;stParam, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(MVCC_INTVALUE));<br>    nRet = <span class="hljs-built_in">MV_CC_GetIntValue</span>(pUser, <span class="hljs-string">&quot;PayloadSize&quot;</span>, &amp;stParam);<br>    <span class="hljs-keyword">if</span> (MV_OK != nRet)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Get PayloadSize fail! nRet [0x%x]\n&quot;</span>, nRet);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    MV_FRAME_OUT_INFO_EX stImageInfo = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">memset</span>(&amp;stImageInfo, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(MV_FRAME_OUT_INFO_EX));<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> * pData = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>) * stParam.nCurValue);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pData)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nDataSize = stParam.nCurValue;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br><span class="hljs-keyword">if</span>(g_bExit)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>        nRet = <span class="hljs-built_in">MV_CC_GetOneFrameTimeout</span>(pUser, pData, nDataSize, &amp;stImageInfo, <span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">if</span> (nRet == MV_OK)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Cam Serial Number[%s]:GetOneFrame, Width[%d], Height[%d], nFrameNum[%d]\n&quot;</span>, <br>                camSerialNumber, stImageInfo.nExtendWidth, stImageInfo.nExtendHeight, stImageInfo.nFrameNum);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cam[%s]:Get One Frame failed![%x]\n&quot;</span>, camSerialNumber, nRet);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(pData != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">free</span>(pData);<br>        pData = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> nRet = MV_OK;<br><br>    <span class="hljs-type">void</span>* handle[CAMERA_NUM] = &#123;<span class="hljs-literal">NULL</span>&#125;;<br>    <span class="hljs-keyword">do</span><br>    &#123;   <br>        <span class="hljs-comment">// ch:初始化SDK | en:Initialize SDK</span><br>    nRet = <span class="hljs-built_in">MV_CC_Initialize</span>();<br>    <span class="hljs-keyword">if</span> (MV_OK != nRet)<br>    &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Initialize SDK fail! nRet [0x%x]\n&quot;</span>, nRet);<br>    <span class="hljs-keyword">return</span> nRet;<br>    &#125;<br><br>        MV_CC_DEVICE_INFO_LIST stDeviceList;<br>        <span class="hljs-built_in">memset</span>(&amp;stDeviceList, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(MV_CC_DEVICE_INFO_LIST));<br><br>        <span class="hljs-comment">// 枚举设备</span><br>        <span class="hljs-comment">// enum device</span><br>        nRet = <span class="hljs-built_in">MV_CC_EnumDevices</span>(MV_GIGE_DEVICE | MV_USB_DEVICE | MV_GENTL_CAMERALINK_DEVICE | MV_GENTL_CXP_DEVICE | MV_GENTL_XOF_DEVICE, &amp;stDeviceList);<br>        <span class="hljs-keyword">if</span> (MV_OK != nRet)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MV_CC_EnumDevices fail! nRet [%x]\n&quot;</span>, nRet);<br>            <span class="hljs-keyword">return</span> nRet;<br>        &#125;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (stDeviceList.nDeviceNum &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stDeviceList.nDeviceNum; i++)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[device %d]:\n&quot;</span>, i);<br>                MV_CC_DEVICE_INFO* pDeviceInfo = stDeviceList.pDeviceInfo[i];<br>                <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pDeviceInfo)<br>                &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <br>                <span class="hljs-built_in">PrintDeviceInfo</span>(pDeviceInfo);      <br>            &#125;  <br>        &#125; <br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Find No Devices!\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(stDeviceList.nDeviceNum &lt; CAMERA_NUM)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;only have %d camera\n&quot;</span>, stDeviceList.nDeviceNum);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>    <span class="hljs-comment">// 提示为多相机测试</span><br>    <span class="hljs-comment">// Tips for multicamera testing</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Start %d camera Grabbing Image test\n&quot;</span>, CAMERA_NUM);<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CAMERA_NUM; i++)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please Input Camera Index: &quot;</span>);<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;nIndex);<br><br>            <span class="hljs-comment">// 选择设备并创建句柄</span><br>            <span class="hljs-comment">// select device and create handle</span><br>            nRet = <span class="hljs-built_in">MV_CC_CreateHandle</span>(&amp;handle[i], stDeviceList.pDeviceInfo[nIndex]);<br>            <span class="hljs-keyword">if</span> (MV_OK != nRet)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MV_CC_CreateHandle fail! nRet [%x]\n&quot;</span>, nRet);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 打开设备</span><br>            <span class="hljs-comment">// open device</span><br>            nRet = <span class="hljs-built_in">MV_CC_OpenDevice</span>(handle[i]);<br>            <span class="hljs-keyword">if</span> (MV_OK != nRet)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MV_CC_OpenDevice fail! nRet [%x]\n&quot;</span>, nRet);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera)</span><br>            <span class="hljs-keyword">if</span> (stDeviceList.pDeviceInfo[nIndex]-&gt;nTLayerType == MV_GIGE_DEVICE)<br>            &#123;<br>                <span class="hljs-type">int</span> nPacketSize = <span class="hljs-built_in">MV_CC_GetOptimalPacketSize</span>(handle[i]);<br>                <span class="hljs-keyword">if</span> (nPacketSize &gt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    nRet = <span class="hljs-built_in">MV_CC_SetIntValueEx</span>(handle[i],<span class="hljs-string">&quot;GevSCPSPacketSize&quot;</span>,nPacketSize);<br>                    <span class="hljs-keyword">if</span>(nRet != MV_OK)<br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Warning: Set Packet Size fail nRet [0x%x]!\n&quot;</span>, nRet);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Warning: Get Packet Size fail nRet [0x%x]!\n&quot;</span>, nPacketSize);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CAMERA_NUM; i++)<br>        &#123;<br>            <span class="hljs-comment">// 设置触发模式为off</span><br>            <span class="hljs-comment">// set trigger mode as off</span><br>            nRet = <span class="hljs-built_in">MV_CC_SetEnumValue</span>(handle[i], <span class="hljs-string">&quot;TriggerMode&quot;</span>, MV_TRIGGER_MODE_OFF);<br>            <span class="hljs-keyword">if</span> (MV_OK != nRet)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Cam[%d]: MV_CC_SetTriggerMode fail! nRet [%x]\n&quot;</span>, i, nRet);<br>            &#125;<br><br>            <span class="hljs-comment">// 开始取流</span><br>            <span class="hljs-comment">// start grab image</span><br>            nRet = <span class="hljs-built_in">MV_CC_StartGrabbing</span>(handle[i]);<br>            <span class="hljs-keyword">if</span> (MV_OK != nRet)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Cam[%d]: MV_CC_StartGrabbing fail! nRet [%x]\n&quot;</span>,i, nRet);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-type">pthread_t</span> nThreadID;<br>            nRet = <span class="hljs-built_in">pthread_create</span>(&amp;nThreadID, <span class="hljs-literal">NULL</span> ,WorkThread , handle[i]);<br>            <span class="hljs-keyword">if</span> (nRet != <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Cam[%d]: thread create failed.ret = %d\n&quot;</span>,i, nRet);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">PressEnterToExit</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CAMERA_NUM; i++)<br>        &#123;<br>            <span class="hljs-comment">// 停止取流</span><br>            <span class="hljs-comment">// end grab image</span><br>            nRet = <span class="hljs-built_in">MV_CC_StopGrabbing</span>(handle[i]);<br>            <span class="hljs-keyword">if</span> (MV_OK != nRet)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MV_CC_StopGrabbing fail! nRet [%x]\n&quot;</span>, nRet);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 关闭设备</span><br>            <span class="hljs-comment">// close device</span><br>            nRet = <span class="hljs-built_in">MV_CC_CloseDevice</span>(handle[i]);<br>            <span class="hljs-keyword">if</span> (MV_OK != nRet)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MV_CC_CloseDevice fail! nRet [%x]\n&quot;</span>, nRet);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 销毁句柄</span><br>            <span class="hljs-comment">// destroy handle</span><br>            nRet = <span class="hljs-built_in">MV_CC_DestroyHandle</span>(handle[i]);<br>            <span class="hljs-keyword">if</span> (MV_OK != nRet)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MV_CC_DestroyHandle fail! nRet [%x]\n&quot;</span>, nRet);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            handle[i] = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CAMERA_NUM; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(handle[i]!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">MV_CC_DestroyHandle</span>(handle[i]);<br>            handle[i] = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ch:反初始化SDK | en:Finalize SDK</span><br><span class="hljs-built_in">MV_CC_Finalize</span>();<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exit\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="代码流程"><a href="#代码流程" class="headerlink" title="代码流程"></a>代码流程</h1><p><img src="/../../../image/GrabMulCamera.bmp" alt="img"></p><h1 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/********************************************************************/</span><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  @~chinese</span><br><span class="hljs-comment"> *  @brief  创建设备句柄</span><br><span class="hljs-comment"> *  @param  handle                      [IN][OUT]       设备句柄</span><br><span class="hljs-comment"> *  @param  pstDevInfo                  [IN]            设备信息结构体</span><br><span class="hljs-comment"> *  @return 成功，返回MV_OK；错误，返回错误码 </span><br><span class="hljs-comment"> *  @remarks 根据输入的设备信息，创建库内部必须的资源和初始化内部模块</span><br><span class="hljs-comment">             通过该接口创建句柄，调用SDK接口，会默认生成SDK日志文件，如果不需要生成日志文件，可以将日志配置文件中的日志等级改成off</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> *  @~english</span><br><span class="hljs-comment"> *  @brief  Create Device Handle</span><br><span class="hljs-comment"> *  @param  handle                      [IN][OUT]       Device handle</span><br><span class="hljs-comment"> *  @param  pstDevInfo                  [IN]            Device Information Structure</span><br><span class="hljs-comment"> *  @return Success, return MV_OK. Failure, return error code</span><br><span class="hljs-comment"> *  @remarks Create required resources within library and initialize internal module according to input device information. </span><br><span class="hljs-comment">             By creating a handle through this interface and calling the SDK interface, SDK log files will be generated by default. If no log file needs to be generated, the log level in the log configuration file can be changed to off</span><br><span class="hljs-comment"> ************************************************************************/</span><br><span class="hljs-function">MV_CAMCTRL_API <span class="hljs-type">int</span> __stdcall <span class="hljs-title">MV_CC_CreateHandle</span><span class="hljs-params">(IN OUT <span class="hljs-type">void</span> ** handle, IN <span class="hljs-type">const</span> MV_CC_DEVICE_INFO* pstDevInfo)</span></span>;<br></code></pre></td></tr></table></figure><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol><li>多相机控制的关键是，利用相机的信息，创建句柄;</li><li>句柄是控制相机的关键；</li></ol>]]></content>
    
    
    <categories>
      
      <category>StructLight</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Get Image in Callback Function</title>
    <link href="/2025/02/22/StructLight/camera/ImageCallback/"/>
    <url>/2025/02/22/StructLight/camera/ImageCallback/</url>
    
    <content type="html"><![CDATA[<ol><li>学习使用在回调函数中获取图像</li><li>示例代码</li><li>控制流程</li><li>函数用法</li></ol><span id="more"></span><h1 id="在回调函数中获取图片"><a href="#在回调函数中获取图片" class="headerlink" title="在回调函数中获取图片"></a>在回调函数中获取图片</h1><p>MV_CC_RegisterImageCallBackEx()接口用于注册回调函数，可以自定义回调函数，获取到图片会自动回调。</p><p>如果要获取RGB24或BGR24图像，可以调用 MV_CC_RegisterImageCallBackForRGB()或 MV_CC_RegisterImageCallBackForBGR()来注册回调函数。</p><ol><li>在回调函数中不建议使用耗时的操作和线程锁，这可能会导致阻塞；</li><li>pData返回地址指针，建议复制pData的数据以创建另一个线程；</li></ol><h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MvCameraControl.h&quot;</span></span><br><br><span class="hljs-comment">// 等待用户输入enter键来结束取流或结束程序</span><br><span class="hljs-comment">// wait for user to input enter to stop grabbing or end the sample program</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PressEnterToExit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> c;<br>    <span class="hljs-keyword">while</span> ( (c = <span class="hljs-built_in">getchar</span>()) != <span class="hljs-string">&#x27;\n&#x27;</span> &amp;&amp; c != EOF );<br>    <span class="hljs-built_in">fprintf</span>( stderr, <span class="hljs-string">&quot;\nPress enter to exit.\n&quot;</span>);<br>    <span class="hljs-keyword">while</span>( <span class="hljs-built_in">getchar</span>() != <span class="hljs-string">&#x27;\n&#x27;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PrintDeviceInfo</span><span class="hljs-params">(MV_CC_DEVICE_INFO* pstMVDevInfo)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pstMVDevInfo)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The Pointer of pstMVDevInfo is NULL!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pstMVDevInfo-&gt;nTLayerType == MV_GIGE_DEVICE)<br>    &#123;<br>        <span class="hljs-type">int</span> nIp1 = ((pstMVDevInfo-&gt;SpecialInfo.stGigEInfo.nCurrentIp &amp; <span class="hljs-number">0xff000000</span>) &gt;&gt; <span class="hljs-number">24</span>);<br>        <span class="hljs-type">int</span> nIp2 = ((pstMVDevInfo-&gt;SpecialInfo.stGigEInfo.nCurrentIp &amp; <span class="hljs-number">0x00ff0000</span>) &gt;&gt; <span class="hljs-number">16</span>);<br>        <span class="hljs-type">int</span> nIp3 = ((pstMVDevInfo-&gt;SpecialInfo.stGigEInfo.nCurrentIp &amp; <span class="hljs-number">0x0000ff00</span>) &gt;&gt; <span class="hljs-number">8</span>);<br>        <span class="hljs-type">int</span> nIp4 = (pstMVDevInfo-&gt;SpecialInfo.stGigEInfo.nCurrentIp &amp; <span class="hljs-number">0x000000ff</span>);<br><br>        <span class="hljs-comment">// ch:打印当前相机ip和用户自定义名字 | en:print current ip and user defined name</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Device Model Name: %s\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stGigEInfo.chModelName);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;CurrentIp: %d.%d.%d.%d\n&quot;</span> , nIp1, nIp2, nIp3, nIp4);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;UserDefinedName: %s\n\n&quot;</span> , pstMVDevInfo-&gt;SpecialInfo.stGigEInfo.chUserDefinedName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pstMVDevInfo-&gt;nTLayerType == MV_USB_DEVICE)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Device Model Name: %s\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stUsb3VInfo.chModelName);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;UserDefinedName: %s\n\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stUsb3VInfo.chUserDefinedName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pstMVDevInfo-&gt;nTLayerType == MV_GENTL_GIGE_DEVICE)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;UserDefinedName: %s\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stGigEInfo.chUserDefinedName);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Serial Number: %s\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stGigEInfo.chSerialNumber);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Model Name: %s\n\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stGigEInfo.chModelName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pstMVDevInfo-&gt;nTLayerType == MV_GENTL_CAMERALINK_DEVICE)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;UserDefinedName: %s\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stCMLInfo.chUserDefinedName);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Serial Number: %s\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stCMLInfo.chSerialNumber);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Model Name: %s\n\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stCMLInfo.chModelName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pstMVDevInfo-&gt;nTLayerType == MV_GENTL_CXP_DEVICE)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;UserDefinedName: %s\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stCXPInfo.chUserDefinedName);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Serial Number: %s\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stCXPInfo.chSerialNumber);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Model Name: %s\n\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stCXPInfo.chModelName);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pstMVDevInfo-&gt;nTLayerType == MV_GENTL_XOF_DEVICE)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;UserDefinedName: %s\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stXoFInfo.chUserDefinedName);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Serial Number: %s\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stXoFInfo.chSerialNumber);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Model Name: %s\n\n&quot;</span>, pstMVDevInfo-&gt;SpecialInfo.stXoFInfo.chModelName);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Not support.\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> __stdcall <span class="hljs-title">ImageCallBackEx</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> * pData, MV_FRAME_OUT_INFO_EX* pFrameInfo, <span class="hljs-type">void</span>* pUser)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (pFrameInfo)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;GetOneFrame, Width[%d], Height[%d], nFrameNum[%d]\n&quot;</span>, <br>            pFrameInfo-&gt;nExtendWidth, pFrameInfo-&gt;nExtendHeight, pFrameInfo-&gt;nFrameNum);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> nRet = MV_OK;<br><br>    <span class="hljs-type">void</span>* handle = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">do</span> <br>    &#123;<br>        <span class="hljs-comment">// ch:初始化SDK | en:Initialize SDK</span><br>nRet = <span class="hljs-built_in">MV_CC_Initialize</span>();<br><span class="hljs-keyword">if</span> (MV_OK != nRet)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Initialize SDK fail! nRet [0x%x]\n&quot;</span>, nRet);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>        MV_CC_DEVICE_INFO_LIST stDeviceList;<br>        <span class="hljs-built_in">memset</span>(&amp;stDeviceList, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(MV_CC_DEVICE_INFO_LIST));<br><br>        <span class="hljs-comment">// 枚举设备</span><br>        <span class="hljs-comment">// enum device</span><br>        nRet = <span class="hljs-built_in">MV_CC_EnumDevices</span>(MV_GIGE_DEVICE | MV_USB_DEVICE | MV_GENTL_CAMERALINK_DEVICE | MV_GENTL_CXP_DEVICE | MV_GENTL_XOF_DEVICE, &amp;stDeviceList);<br>        <span class="hljs-keyword">if</span> (MV_OK != nRet)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MV_CC_EnumDevices fail! nRet [%x]\n&quot;</span>, nRet);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (stDeviceList.nDeviceNum &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stDeviceList.nDeviceNum; i++)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[device %d]:\n&quot;</span>, i);<br>                MV_CC_DEVICE_INFO* pDeviceInfo = stDeviceList.pDeviceInfo[i];<br>                <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pDeviceInfo)<br>                &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <br>                <span class="hljs-built_in">PrintDeviceInfo</span>(pDeviceInfo);        <br>            &#125;  <br>        &#125; <br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Find No Devices!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please Intput camera index: &quot;</span>);<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;nIndex);<br><br>        <span class="hljs-keyword">if</span> (nIndex &gt;= stDeviceList.nDeviceNum)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Intput error!\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 选择设备并创建句柄</span><br>        <span class="hljs-comment">// select device and create handle</span><br>        nRet = <span class="hljs-built_in">MV_CC_CreateHandle</span>(&amp;handle, stDeviceList.pDeviceInfo[nIndex]);<br>        <span class="hljs-keyword">if</span> (MV_OK != nRet)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MV_CC_CreateHandle fail! nRet [%x]\n&quot;</span>, nRet);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 打开设备</span><br>        <span class="hljs-comment">// open device</span><br>        nRet = <span class="hljs-built_in">MV_CC_OpenDevice</span>(handle);<br>        <span class="hljs-keyword">if</span> (MV_OK != nRet)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MV_CC_OpenDevice fail! nRet [%x]\n&quot;</span>, nRet);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// ch:探测网络最佳包大小(只对GigE相机有效) | en:Detection network optimal package size(It only works for the GigE camera)</span><br>        <span class="hljs-keyword">if</span> (stDeviceList.pDeviceInfo[nIndex]-&gt;nTLayerType == MV_GIGE_DEVICE)<br>        &#123;<br>            <span class="hljs-type">int</span> nPacketSize = <span class="hljs-built_in">MV_CC_GetOptimalPacketSize</span>(handle);<br>            <span class="hljs-keyword">if</span> (nPacketSize &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                nRet = <span class="hljs-built_in">MV_CC_SetIntValueEx</span>(handle,<span class="hljs-string">&quot;GevSCPSPacketSize&quot;</span>,nPacketSize);<br>                <span class="hljs-keyword">if</span>(nRet != MV_OK)<br>                &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Warning: Set Packet Size fail nRet [0x%x]!\n&quot;</span>, nRet);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Warning: Get Packet Size fail nRet [0x%x]!\n&quot;</span>, nPacketSize);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 设置触发模式为off</span><br>        <span class="hljs-comment">// set trigger mode as off</span><br>        nRet = <span class="hljs-built_in">MV_CC_SetEnumValue</span>(handle, <span class="hljs-string">&quot;TriggerMode&quot;</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (MV_OK != nRet)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MV_CC_SetTriggerMode fail! nRet [%x]\n&quot;</span>, nRet);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 注册抓图回调</span><br>        <span class="hljs-comment">// register image callback</span><br>        nRet = <span class="hljs-built_in">MV_CC_RegisterImageCallBackEx</span>(handle, ImageCallBackEx, handle);<br>        <span class="hljs-keyword">if</span> (MV_OK != nRet)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MV_CC_RegisterImageCallBackEx fail! nRet [%x]\n&quot;</span>, nRet);<br>            <span class="hljs-keyword">break</span>; <br>        &#125;<br><br>        <span class="hljs-comment">// 开始取流</span><br>        <span class="hljs-comment">// start grab image</span><br>        nRet = <span class="hljs-built_in">MV_CC_StartGrabbing</span>(handle);<br>        <span class="hljs-keyword">if</span> (MV_OK != nRet)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MV_CC_StartGrabbing fail! nRet [%x]\n&quot;</span>, nRet);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">PressEnterToExit</span>();<br><br>        <span class="hljs-comment">// 停止取流</span><br>        <span class="hljs-comment">// end grab image</span><br>        nRet = <span class="hljs-built_in">MV_CC_StopGrabbing</span>(handle);<br>        <span class="hljs-keyword">if</span> (MV_OK != nRet)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MV_CC_StopGrabbing fail! nRet [%x]\n&quot;</span>, nRet);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 关闭设备</span><br>        <span class="hljs-comment">// close device</span><br>        nRet = <span class="hljs-built_in">MV_CC_CloseDevice</span>(handle);<br>        <span class="hljs-keyword">if</span> (MV_OK != nRet)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MV_CC_CloseDevice fail! nRet [%x]\n&quot;</span>, nRet);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 销毁句柄</span><br>        <span class="hljs-comment">// destroy handle</span><br>        nRet = <span class="hljs-built_in">MV_CC_DestroyHandle</span>(handle);<br>        <span class="hljs-keyword">if</span> (MV_OK != nRet)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MV_CC_DestroyHandle fail! nRet [%x]\n&quot;</span>, nRet);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        handle = <span class="hljs-literal">NULL</span>;<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">if</span> (handle != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">MV_CC_DestroyHandle</span>(handle);<br>        handle = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">// ch:反初始化SDK | en:Finalize SDK</span><br><span class="hljs-built_in">MV_CC_Finalize</span>();<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exit\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h1><p><img src="/../../../image/callback.bmp" alt="img"></p><ol><li><p>调用MV_CC_Initialize()初始化 SDK 资源;</p></li><li><p>（可选）调用MV_CC_EnumDevices()以枚举子网中与指定传输协议对应的所有设备;找到的设备的信息由pstDevList以 MV_CC_DEVICE_INFO_LIST()结构体返回;</p></li><li><p>（可选）调用MV_CC_IsDeviceAccessible()以检查指定的设备是否可访问，然后再打开它;</p></li><li><p>调用MV_CC_CreateHandle()以创建设备句柄;</p></li><li><p>（可选）执行以下一项或多项操作来获取&#x2F;设置不同类型的参数：</p><ol><li><p><a href="file:///home/zhm/project/doc/Machine%20Vision%20Camera%20SDK%20Developer%20Guide%20Linux%20(C)%20V4.4.1/html/group___xE5_xB1_x9E_xE6_x80_xA7_xE9_x85_x8D_xE7_xBD_xAE.html#ga6240aac97e206f77b4ce3bd7a1ef1048" title="Get the value of camera integer type node.">MV_CC_GetIntValueEx()</a> &#x2F; <a href="file:///home/zhm/project/doc/Machine%20Vision%20Camera%20SDK%20Developer%20Guide%20Linux%20(C)%20V4.4.1/html/group___xE5_xB1_x9E_xE6_x80_xA7_xE9_x85_x8D_xE7_xBD_xAE.html#ga9bf0ac21078791974fd4f5b8b2c6328b" title="Set the value of camera integer type node.">MV_CC_SetIntValueEx()</a></p></li><li><p><a href="file:///home/zhm/project/doc/Machine%20Vision%20Camera%20SDK%20Developer%20Guide%20Linux%20(C)%20V4.4.1/html/group___xE5_xB1_x9E_xE6_x80_xA7_xE9_x85_x8D_xE7_xBD_xAE.html#ga480e49d645f1638ce17da841ac72632c" title="Get the value of camera float type node.">MV_CC_GetFloatValue()</a> &#x2F; <a href="file:///home/zhm/project/doc/Machine%20Vision%20Camera%20SDK%20Developer%20Guide%20Linux%20(C)%20V4.4.1/html/group___xE5_xB1_x9E_xE6_x80_xA7_xE9_x85_x8D_xE7_xBD_xAE.html#gad43ad99b3a3a0ec2e91f6ad1ad4e99ac" title="Set the value of camera float type node.">MV_CC_SetFloatValue()</a></p></li><li><p><a href="file:///home/zhm/project/doc/Machine%20Vision%20Camera%20SDK%20Developer%20Guide%20Linux%20(C)%20V4.4.1/html/group___xE5_xB1_x9E_xE6_x80_xA7_xE9_x85_x8D_xE7_xBD_xAE.html#ga2daf898feb1afa4bd5de232d85a33780" title="Get the value of camera Enum type node.">MV_CC_GetEnumValue()</a> &#x2F; <a href="file:///home/zhm/project/doc/Machine%20Vision%20Camera%20SDK%20Developer%20Guide%20Linux%20(C)%20V4.4.1/html/group___xE5_xB1_x9E_xE6_x80_xA7_xE9_x85_x8D_xE7_xBD_xAE.html#ga15a8abe28a1c5a53e10d115c7def4089" title="Set the value of camera Enum type node.">MV_CC_SetEnumValue()</a></p></li><li><p><a href="file:///home/zhm/project/doc/Machine%20Vision%20Camera%20SDK%20Developer%20Guide%20Linux%20(C)%20V4.4.1/html/group___xE5_xB1_x9E_xE6_x80_xA7_xE9_x85_x8D_xE7_xBD_xAE.html#ga23ceabb8e0caf522ae7f77ad8c14cd84" title="Get the value of camera bool type node.">MV_CC_GetBoolValue()</a> &#x2F; <a href="file:///home/zhm/project/doc/Machine%20Vision%20Camera%20SDK%20Developer%20Guide%20Linux%20(C)%20V4.4.1/html/group___xE5_xB1_x9E_xE6_x80_xA7_xE9_x85_x8D_xE7_xBD_xAE.html#gad725e29bc56fa0eb57dfefb4d8d6ea69" title="Set Boolean value.">MV_CC_SetBoolValue()</a></p></li><li><p><a href="file:///home/zhm/project/doc/Machine%20Vision%20Camera%20SDK%20Developer%20Guide%20Linux%20(C)%20V4.4.1/html/group___xE5_xB1_x9E_xE6_x80_xA7_xE9_x85_x8D_xE7_xBD_xAE.html#ga590e5271c688137ea03ab316f2ca2307" title="Get the value of camera string type node.">MV_CC_GetStringValue()</a> &#x2F; <a href="file:///home/zhm/project/doc/Machine%20Vision%20Camera%20SDK%20Developer%20Guide%20Linux%20(C)%20V4.4.1/html/group___xE5_xB1_x9E_xE6_x80_xA7_xE9_x85_x8D_xE7_xBD_xAE.html#ga3c816d281b3941584a8fa8ebf14feda1" title="Set the camera value of string type.">MV_CC_SetStringValue()</a></p></li><li><p><a href="file:///home/zhm/project/doc/Machine%20Vision%20Camera%20SDK%20Developer%20Guide%20Linux%20(C)%20V4.4.1/html/group___xE5_xB1_x9E_xE6_x80_xA7_xE9_x85_x8D_xE7_xBD_xAE.html#ga1b85d5a9950f315471f4041db36a5c14" title="Set the camera Command node.">MV_CC_SetCommandValue() MV_CC_SetCommandValue()</a></p><ul><li>所有 open 属性值都可以在 Camera Parameter Nodes 表中找到。该表提供了每个节点的名称、数据类型、取值范围、访问方式和介绍的详细说明</li><li>可设置采集模式：设置和获取单帧、多帧和连续采集的采集模式；</li><li>可设置触发方式：硬件触发，软件触发；</li><li>可设置图像参数：图像宽度和高度、像素格式、帧速率、AIO 偏移、增益、曝光模式、曝光值、亮度、锐度、饱和度、灰度、白平衡、Gamma 值和其他参数；</li></ul></li></ol></li><li><p>调用 MV_CC_DisplayOneFrame()输入句柄并开始显示帧；</p></li><li><p>调用 MV_CC_StopGrabbing()以停止客户获取；</p></li><li><p>调用 MV_CC_CloseDevice()以关闭设备；</p></li><li><p>调用 MV_CC_DestroyHandle()销毁 handle 并释放资源；</p></li><li><p>调用 MV_CC_Finalize()释放 SDK 资源；</p></li></ol><h1 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h1><ol><li>调用 MV_CC_RegisterImageCallBackEx()设置数据回调函数;</li><li>调用 MV_CC_StartGrabbing()开始流式传输;</li><li>对于原始图像数据，您可以调用 MV_CC_ConvertPixelTypeEx()转换图像像素格式，或调用 MV_CC_SaveImageEx3()将图像转换为 JPEG 或 BMP 格式并另存为文件;</li><li>可以在回调函数中保存图像；</li></ol>]]></content>
    
    
    <categories>
      
      <category>StructLight</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hosts</title>
    <link href="/2025/02/22/Other/hosts/"/>
    <url>/2025/02/22/Other/hosts/</url>
    
    <content type="html"><![CDATA[<p>在Ubuntu上安装nvm遇到：curl: (28) Failed to connect to raw.githubusercontent.com port 443: Connection timed out [closed]<br>1.打开<code>/etc/hosts</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">sudo</span> vim /etc/hosts<br></code></pre></td></tr></table></figure><span id="more"></span><p>2.查询可用IP<br>使用<a href="https://www.ipaddress.com/website/">ipaddress</a>网站查询<code>github.com</code>,<code>ssh.github.com</code>,<code>raw.githubusercontent.com</code>网站的可用IP</p><p>3.在末尾添加以下IP地址</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">140.82.114.3</span>  github.com<br><span class="hljs-number">140.82.113.36</span>  ssh.github.com<br><span class="hljs-number">199.232.68.133</span> raw.githubusercontent.com<br></code></pre></td></tr></table></figure><p>4.保存文件并退出</p><p>5.可以使用ping查看域名是否有received</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$<span class="hljs-built_in"> ping </span>199.232.68.133<span class="hljs-built_in"></span><br><span class="hljs-built_in">PING </span>199.232.68.133 (199.232.68.133) 56(84) bytes of data.<br>64 bytes <span class="hljs-keyword">from</span> 199.232.68.133: <span class="hljs-attribute">icmp_seq</span>=1 <span class="hljs-attribute">ttl</span>=43 <span class="hljs-attribute">time</span>=234 ms<br>64 bytes <span class="hljs-keyword">from</span> 199.232.68.133: <span class="hljs-attribute">icmp_seq</span>=2 <span class="hljs-attribute">ttl</span>=43 <span class="hljs-attribute">time</span>=234 ms<br>64 bytes <span class="hljs-keyword">from</span> 199.232.68.133: <span class="hljs-attribute">icmp_seq</span>=3 <span class="hljs-attribute">ttl</span>=43 <span class="hljs-attribute">time</span>=234 ms<br>64 bytes <span class="hljs-keyword">from</span> 199.232.68.133: <span class="hljs-attribute">icmp_seq</span>=4 <span class="hljs-attribute">ttl</span>=43 <span class="hljs-attribute">time</span>=233 ms<br>^C<br>--- 199.232.68.133<span class="hljs-built_in"> ping </span>statistics ---<br>4 packets transmitted, 4 received, 0% packet loss, time 3004ms<br>rtt min/avg/max/mdev = 233.337/233.849/234.302/0.421 ms<br></code></pre></td></tr></table></figure><p><strong>ps.为什么要这样做呢??? hosts是什么配置文件呢???</strong><br><strong>hosts文件是什么？</strong><br>在Linux系统中，<code>/etc/hosts</code>文件是一个本地的DNS解析文件，用于将IP地址和主机名映射起来。当你访问某个域名时，系统会首先检查这个文件，如果在这里找到了对应的IP地址，就会直接使用，而不再通过外部DNS服务器查询。<br><strong>为什么要这么做？</strong><br>这是将GitHub相关的域名（如 github.com、ssh.github.com 和 raw.githubusercontent.com）手动映射到指定的IP地址。这么做的目的通常有以下几种可能：</p><ul><li>解决访问问题：有时候由于DNS解析缓慢或者网络封锁，GitHub相关服务的域名可能会无法访问，通过手动在&#x2F;etc&#x2F;hosts中添加这些映射，可以直接访问指定的IP，绕过DNS解析。</li><li>加快访问速度：如果你已经知道某个域名的IP地址，手动添加可以减少系统查询外部DNS的时间，从而提升访问速度。</li><li>绕过DNS劫持：在某些情况下，网络服务提供商或某些恶意软件可能会劫持DNS请求，将你引导到错误的网站，通过手动配置IP可以避免这种情况。</li></ul><p>IP地址可能会随着时间变化，所以如果GitHub更新了服务器的IP地址，而你还在使用旧的配置，可能会导致访问失败。</p>]]></content>
    
    
    <categories>
      
      <category>PC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Camera User Manual</title>
    <link href="/2025/02/22/StructLight/camera/user/"/>
    <url>/2025/02/22/StructLight/camera/user/</url>
    
    <content type="html"><![CDATA[<h1 id="相机工作原理"><a href="#相机工作原理" class="headerlink" title="相机工作原理"></a>相机工作原理</h1><p>图像传感器接收图像数据后，通过内置的各类ISP图像处理算法完成图像数据处理，最后通过GigE Vision协议完成图像数据传输。</p><span id="more"></span><p><img src="/../../../image/camera1.bmp" alt="img"></p><p>图像传感器捕获的原始图像数据就是这些由红、绿、蓝格子组成的图案，它们记录了落在每个像素上的光线强度。但是，由于每个像素只记录一种颜色，我们需要通过ISP中的算法来处理这些数据，以便得到我们最终看到的丰富多彩的图像。</p><p>ISP图像处理算法，即Image Signal Processor（影像处理器）算法，是一系列用于处理图像传感器捕获的原始图像数据的算法。这些算法的主要目的是将传感器的原始输出转换成高质量的图像，以供显示或进一步处理。常见的图像处理算法包括：</p><ol><li>噪声去除（Noise Reduction） ：去除图像中的噪声，提高图像质量。</li><li>坏点去除（Bad Pixel Correction） ：修正传感器中的坏点数据。</li><li>去马赛克（Demosaicing） ：将传感器输出的Bayer格式数据转换为RGB数据。</li><li>白平衡（Auto White Balance, AWB） ：校正图像的色温，使颜色看起来更自然。</li><li>自动曝光控制（Auto Exposure Control） ：调整图像的亮度，以获得最佳的曝光效果。</li><li>色彩校正（Color Correction） ：调整图像的色彩，使其更加准确。</li><li>Gamma校正（Gamma Correction） ：调整图像的亮度曲线，增强图像的对比度。</li><li>边缘增强（Edge Enhancement） ：增强图像的边缘，使图像更加清晰。</li><li>色彩空间转换（Color Space Conversion） ：将图像从一个色彩空间转换到另一个色彩空间，例如从RGB转换到YUV。</li><li>HDR&#x2F;Tone Mapping ：处理高动态范围图像，以在有限的显示设备上显示更广泛的亮度和颜色范围。</li></ol><h3 id="什么是图像传感器？"><a href="#什么是图像传感器？" class="headerlink" title="什么是图像传感器？"></a>什么是图像传感器？</h3><p>图像传感器就像是一个超级小的相机网格，它由成千上万个微小的光敏元件（像素）组成。每个像素都负责捕捉落在它上面的光线，并将其转换成电信号。</p><h3 id="什么是原始图像数据？"><a href="#什么是原始图像数据？" class="headerlink" title="什么是原始图像数据？"></a>什么是原始图像数据？</h3><p>想象一下，你在一个阳光明媚的日子里拿着一个非常特殊的画板在外面画画。这个画板上的每个小格子只能感应一种颜色的光线（红色、绿色或蓝色）。当你完成画作后，每个小格子里只有一种颜色的标记，这些标记就是图像传感器捕获的“原始图像数据”。</p><h3 id="原始图像数据的例子："><a href="#原始图像数据的例子：" class="headerlink" title="原始图像数据的例子："></a>原始图像数据的例子：</h3><p>假设你的画板上有一个4x4的格子，每个格子只能感应一种颜色的光线，那么可能看起来像这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">R</span> <span class="hljs-selector-tag">G</span> <span class="hljs-attribute">R</span> <span class="hljs-selector-tag">G</span><br><span class="hljs-selector-tag">G</span> <span class="hljs-selector-tag">B</span> <span class="hljs-selector-tag">G</span> <span class="hljs-selector-tag">B</span><br><span class="hljs-attribute">R</span> <span class="hljs-selector-tag">G</span> <span class="hljs-attribute">R</span> <span class="hljs-selector-tag">G</span><br><span class="hljs-selector-tag">G</span> <span class="hljs-selector-tag">B</span> <span class="hljs-selector-tag">G</span> <span class="hljs-selector-tag">B</span><br></code></pre></td></tr></table></figure><p>这里的R代表红色格子，G代表绿色格子，B代表蓝色格子。每个格子只能捕捉相应颜色的光线强度，比如亮红色、深蓝色等。</p><h3 id="为什么需要处理原始图像数据？"><a href="#为什么需要处理原始图像数据？" class="headerlink" title="为什么需要处理原始图像数据？"></a>为什么需要处理原始图像数据？</h3><p>因为每个格子只记录了一种颜色的信息，所以直接看这些数据，你看到的图像会是模糊不清的，像是马赛克一样。为了让图像变得清晰和多彩，我们需要用一些算法来“猜测”每个格子缺失的颜色信息，这个过程叫做去马赛克（Demosaicing）或解拜耳（Bayer Decoding）。</p><h3 id="去马赛克的例子："><a href="#去马赛克的例子：" class="headerlink" title="去马赛克的例子："></a>去马赛克的例子：</h3><p>假设我们通过某种算法“猜测”出了缺失的颜色信息，那么刚才的4x4格子可能变成了这样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">红 绿 红 绿<br>绿 蓝 绿 蓝<br>红 绿 红 绿<br>绿 蓝 绿 蓝<br></code></pre></td></tr></table></figure><p>现在每个格子都有了完整的颜色信息，看起来就像是一个正常的图像了。</p><h1 id="增益"><a href="#增益" class="headerlink" title="增益"></a>增益</h1><p>相机增益分为模拟增益和数字增益，模拟增益可将模拟信号放大；数字信号可将模数转换后的信号放大；</p><p>增益数值越高时，图像亮度也越高，同时图像噪声也会增加，对图像质量有所影响。且数字增益的噪声会比模拟增益的噪声更明显；</p><p>若需要提高图像亮度，建议先增大相机的曝光时间；若曝光时间达不到环境允许的上限不能满足要求，再考虑模拟增益；若模拟增益为最大值还不能满足要求，最后再调整数字增益；</p><h1 id="Gamma矫正"><a href="#Gamma矫正" class="headerlink" title="Gamma矫正"></a>Gamma矫正</h1><p>通常相机芯片的输出与照射在芯片感光面的光子是线性的，Gamma 校正提供了一种输出非线性的映射机制；</p><p>Gamma校正是一个非线性操作，它通过调整输入信号的功率来改变输出信号的亮度：</p><ul><li>Gamma &lt; 1 ：图像被压缩，暗部细节增强，亮部细节减少，图像整体变暗。</li><li>Gamma &#x3D; 1 ：图像没有变化，这是线性响应，意味着输入和输出是直接成比例的。</li><li>Gamma &gt; 1 ：图像被扩展，暗部细节减少，亮部细节增强，图像整体变亮。</li></ul>]]></content>
    
    
    <categories>
      
      <category>StructLight</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>camera info</title>
    <link href="/2025/02/22/StructLight/camera/info/"/>
    <url>/2025/02/22/StructLight/camera/info/</url>
    
    <content type="html"><![CDATA[<h1 id="相机信息"><a href="#相机信息" class="headerlink" title="相机信息"></a>相机信息</h1><p>相机信息是指相机设备的基本信息，包括设备类型、传输层协议、硬件接口数据类型等，以USB接入设备为例。</p><span id="more"></span><h2 id="控制端点"><a href="#控制端点" class="headerlink" title="控制端点"></a>控制端点</h2><p>控制端点是指相机设备与主机之间进行控制传输的入口和出口。控制传输通常用于发送命令、请求或接收设备的状态信息等。</p><ul><li><strong>CrtlInEndPoint（控制输入端点）</strong> ：用于控制传输的输入端点。</li><li><strong>CrtlOutEndPoint（控制输出端点）</strong> ：用于控制传输的输出端点。</li></ul><h2 id="数据传输端点"><a href="#数据传输端点" class="headerlink" title="数据传输端点"></a>数据传输端点</h2><ul><li><strong>StreamEndPoint（流端点）</strong> ：用于数据传输的端点，通常用于传输大量数据，如图像数据、视频流等。对于相机设备，流端点非常重要，因为它决定了数据传输的效率和性能。</li><li><strong>EventEndPoint（事件端点）</strong> ：用于事件通知的端点，通常用于接收设备的事件信息，如设备状态变化、错误事件等。</li></ul><h2 id="设备标识信息"><a href="#设备标识信息" class="headerlink" title="设备标识信息"></a>设备标识信息</h2><ul><li><strong>chVendorName（供应商名字）</strong> ：设备供应商的名称。了解供应商名字可以帮助用户了解设备的制造商和品牌。</li><li><strong>chModelName（型号名字）</strong> ：设备的型号名称。型号名称是用户识别和选择设备的重要依据，它通常包含了设备的主要功能和技术规格。</li><li><strong>chFamilyName（家族名字）</strong> ：设备所属的产品家族名称。家族名称可以帮助用户了解设备所属的产品系列和定位，以及与其他设备的关系。</li><li><strong>chDeviceVersion（设备版本）</strong> ：设备的版本信息。设备版本可以帮助用户了解设备的更新状态和功能改进，以及是否需要进行固件升级等操作。</li><li><strong>chManufacturerName（制造商名字）</strong> ：设备制造商的名称。制造商名字可以帮助用户了解设备的生产厂商和质量保证。</li></ul><h2 id="序列号和用户自定义名称"><a href="#序列号和用户自定义名称" class="headerlink" title="序列号和用户自定义名称"></a>序列号和用户自定义名称</h2><ul><li><strong>chSerialNumber（序列号）</strong> ：设备的唯一序列号，用于标识和追踪设备。</li><li><strong>chUserDefinedName（用户自定义名字）</strong> ：用户为设备设置的自定义名称。用户自定义名称可以帮助用户更方便地识别和管理设备，特别是在连接多个设备时。</li></ul><h2 id="USB协议和设备地址"><a href="#USB协议和设备地址" class="headerlink" title="USB协议和设备地址"></a>USB协议和设备地址</h2><ul><li><strong>nbcdUSB（支持的USB协议）</strong> ：设备支持的USB协议版本。</li><li><strong>nDeviceAddress（设备地址）</strong> ：设备在USB总线上的地址。设备地址用于在USB总线中唯一标识设备，主要用于底层的设备通信和管理。</li></ul><h1 id="设备传输层协议"><a href="#设备传输层协议" class="headerlink" title="设备传输层协议"></a>设备传输层协议</h1><p>传输层协议是网络通信协议栈中的一部分，负责在设备之间传输数据。</p><h2 id="硬件接口数据类型"><a href="#硬件接口数据类型" class="headerlink" title="硬件接口数据类型"></a>硬件接口数据类型</h2><ul><li><strong>MV_GIGE_DEVICE</strong> ：表示GigE设备，即使用Gigabit Ethernet（千兆以太网）作为传输层协议的设备。GigE设备通常用于工业相机、网络摄像头等，具有高速数据传输和远程通信的能力。</li><li><strong>MV_1394_DEVICE</strong> ：表示1394-a&#x2F;b设备，即使用IEEE 1394接口（也称为FireWire）作为传输层协议的设备。IEEE 1394是一种高速串行总线，常用于连接数字视频摄像机、硬盘驱动器等设备，支持即插即用和热插拔。</li><li><strong>MV_USB_DEVICE</strong> ：表示USB设备，即使用通用串行总线（USB）作为传输层协议的设备。USB是一种广泛使用的接口技术，支持多种设备连接和数据传输，具有通用性强、使用方便等特点。</li><li><strong>MV_CAMERALINK_DEVICE</strong> ：表示CameraLink设备，即使用Camera Link接口作为传输层协议的设备。Camera Link是一种专为高速图像传输设计的接口标准，常用于工业相机和图像采集系统，支持高分辨率和高帧率的图像数据传输。</li></ul><h2 id="虚拟设备类型"><a href="#虚拟设备类型" class="headerlink" title="虚拟设备类型"></a>虚拟设备类型</h2><ol><li><strong>MV_VIR_GIGE_DEVICE</strong> ：指的是虚拟GigE设备。这种设备通常不是物理存在的，而是通过软件创建的模拟设备。它们用于模拟真实的GigE网络设备的功能，可以用于开发和测试网络应用，或者在没有真实硬件的情况下模拟网络环境。</li><li><strong>MV_VIR_USB_DEVICE</strong> ：指的是虚拟USB设备。这同样是一种软件模拟的设备，用来模拟USB设备的行为。这可以帮助开发者在没有物理USB设备的情况下测试和开发USB相关的应用程序。</li></ol><h2 id="自研网卡下的设备类型"><a href="#自研网卡下的设备类型" class="headerlink" title="自研网卡下的设备类型"></a>自研网卡下的设备类型</h2><ol><li><strong>MV_GENTL_GIGE_DEVICE</strong> ：这是一种在特定的自研网卡下使用的GigE设备。自研网卡是指根据特定需求定制开发的网络卡，可能具有优化的性能特征。这种设备类型适用于需要高性能网络通讯的应用场景。</li><li><strong>MV_GENTL_CAMERALINK_DEVICE</strong> ：这是使用CameraLink标准的相机设备。CameraLink是一种用于高速图像数据传输的技术标准，常用于工业和科研领域中的图像采集。</li><li><strong>MV_GENTL_CXP_DEVICE</strong> ：指的是使用CoaXPress接口的设备。CoaXPress利用同轴电缆传输高速数据，非常适合于需要长距离传输和高数据率的应用。</li><li><strong>MV_GENTL_XOF_DEVICE</strong> ：这是基于Xilinx Optical Fiber的设备，使用光纤进行高速数据通信，适用于数据中心和高性能计算环境。</li></ol>]]></content>
    
    
    <categories>
      
      <category>StructLight</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>光机接口</title>
    <link href="/2025/02/22/StructLight/projector/interface/"/>
    <url>/2025/02/22/StructLight/projector/interface/</url>
    
    <content type="html"><![CDATA[<h1 id="onceProject"><a href="#onceProject" class="headerlink" title="onceProject"></a>onceProject</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ProjectorDlpc34xx::project</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">bool</span> isContinue)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!isInitial_) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (isContinue) &#123;<br>        <span class="hljs-built_in">DLPC34XX_WriteOperatingModeSelect</span>(DLPC34XX_OM_SENS_INTERNAL_PATTERN);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DLPC34XX_WriteInternalPatternControl</span>(DLPC34XX_PC_START, <span class="hljs-number">0xFF</span>) ==<br>               SUCCESS;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">DLPC34XX_WriteOperatingModeSelect</span>(DLPC34XX_OM_SENS_INTERNAL_PATTERN);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DLPC34XX_WriteInternalPatternControl</span>(DLPC34XX_PC_START, <span class="hljs-number">0x0</span>) ==<br>               SUCCESS;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><ol><li><p><code>DLPC34XX_WriteOperatingModeSelect(DLPC34XX_OM_SENS_INTERNAL_PATTERN);</code>选择工作模式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">DLPC34XX_WriteOperatingModeSelect</span><span class="hljs-params">(DLPC34XX_OperatingMode_e OperatingMode)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uint32_t</span> Status = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">DLPC_COMMON_ClearWriteBuffer</span>();<br><br>    <span class="hljs-built_in">DLPC_COMMON_PackOpcode</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0x5</span>);<br>    <span class="hljs-built_in">DLPC_COMMON_PackBytes</span>((<span class="hljs-type">uint8_t</span>*)&amp;OperatingMode, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-built_in">DLPC_COMMON_SetCommandDestination</span>(<span class="hljs-number">0</span>);<br>    Status = <span class="hljs-built_in">DLPC_COMMON_SendWrite</span>();<br>    <span class="hljs-keyword">return</span> Status;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><img src="/../../../image/modeSelect.bmp" alt="img"></p><ol start="2"><li><p>判断是连续投影还是单次投影(由isContinue决定)</p><ol><li>isContinue为true为连续投影</li><li>isContinue为false为单次投影</li></ol><p><img src="/../../../image/project.bmp" alt="img"></p></li><li><p><code>DLPC34XX_WriteInternalPatternControl(DLPC34XX_PC_START,0xFF)</code>：发送控制码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">DLPC34XX_WriteInternalPatternControl</span><span class="hljs-params">(DLPC34XX_PatternControl_e PatternControl, <span class="hljs-type">uint8_t</span> RepeatCount)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uint32_t</span> Status = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">DLPC_COMMON_ClearWriteBuffer</span>();<br><br>    <span class="hljs-built_in">DLPC_COMMON_PackOpcode</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0x9E</span>);<br>    <span class="hljs-built_in">DLPC_COMMON_PackBytes</span>((<span class="hljs-type">uint8_t</span>*)&amp;PatternControl, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">DLPC_COMMON_PackBytes</span>((<span class="hljs-type">uint8_t</span>*)&amp;RepeatCount, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-built_in">DLPC_COMMON_SetCommandDestination</span>(<span class="hljs-number">0</span>);<br>    Status = <span class="hljs-built_in">DLPC_COMMON_SendWrite</span>();<br>    <span class="hljs-keyword">return</span> Status;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><code>DLPC34XX_WriteInternalPatternControl()</code>函数即内部图形控制函数，通过这个函数控制内部投影模式。所以在函数内部，会先发送一个 <code>0x9E</code>表示为写入内部控制。</p><h1 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h1><p><img src="/../../../image/project.bmp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ProjectorDlpc34xx::pause</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!isInitial_) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">DLPC34XX_WriteInternalPatternControl</span>(DLPC34XX_PC_PAUSE, <span class="hljs-number">0xff</span>) ==<br>           SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p><strong>启动（Start）</strong>：</p><ul><li>功能：开始显示图形顺序表中的第一个条目。</li><li>参数：字节2用于指示在首次执行后重复执行图形顺序表的次数。</li><li>用途：用于初始化显示流程，可以设置循环次数，适用于需要循环显示的场景。</li></ul></li><li><p><strong>停止（Stop）</strong>：</p><ul><li>功能：停止执行图形顺序表并关闭照明器。</li><li>用途：用于终止显示流程，适用于需要立即停止显示的情况。</li></ul></li><li><p><strong>暂停（Pause）</strong>：</p><ul><li>功能：暂停执行当前的图形顺序表条目，继续显示最后显示的图形。</li><li>用途：用于在需要时临时中断显示流程，但保留当前显示状态，适用于需要临时中断或审查当前显示内容的场景。</li></ul></li><li><p><strong>步进（Step）</strong>：</p><ul><li>功能：前往当前所显示图形顺序表中的下一个图形，此操作假定用户已暂停系统。</li><li>用途：用于手动控制显示流程，逐个查看图形顺序表中的条目，适用于需要逐个审查或调整显示内容的场景。</li></ul></li><li><p><strong>恢复（Resume）</strong>：</p><ul><li>功能：继续执行当前的图形顺序表条目，此操作假定用户已暂停系统。</li><li>用途：用于在暂停后继续显示流程，适用于需要在中断后恢复显示的场景。</li></ul></li><li><p><strong>复位（Reset）</strong>：</p><ul><li>功能：开始显示当前图形顺序表中引用的第一个图形。</li><li>用途：用于重置显示流程到初始状态，适用于需要从头开始显示或重新初始化显示内容的场景。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>StructLight</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>光机接口测试</title>
    <link href="/2025/02/22/StructLight/projector/%E5%85%89%E6%9C%BA-%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    <url>/2025/02/22/StructLight/projector/%E5%85%89%E6%9C%BA-%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>DLPC-API-1.10给的API比较杂，有很多也用不上，需要自己另外定义接口，官方给的有一个示例程序，程序里封装了一部分接口，先测试这些接口能不能用，然后在这个基础上增加需要的接口，实例程序中的包括：</p><span id="more"></span><ul><li>I2C 写入</li><li>I2C 读取</li><li>初始化命令层</li><li>以秒为单位等待指定的时间</li><li>生成一个1位（二维）图案</li><li>生成一个8位（灰度）图案</li><li>填充数组<code>s_PatternSets 中的 DLPC34XX_INT_PAT_PatternSet_s</code>结构</li><li>填充数组<code>s_PatternOrderTable 中的 DLPC34XX_INT_PAT_PatternOrderTableEntry_s</code>结构</li><li>将数据复制到 Flash 编程缓冲区以便后续写入</li><li>将缓冲区数据编程到 Flash 中</li><li>将数据写入文件</li><li>生成图案数据并写入到文件</li><li>缓存图案数据并编程到 Flash 中</li><li>生成和编程图案数据到 Flash 中</li><li>从 Flash 中加载图案顺序表条目</li><li>加载特定的图案顺序表条目</li><li>写入测试图案网格线</li><li>写入测试图案色条</li><li>写入选定视图外观（Look）</li><li>加载预构建的模式数据</li><li>写入 LABB 和 CAIC 设置</li><li>加载固件</li></ul><h1 id="过程记录"><a href="#过程记录" class="headerlink" title="过程记录"></a>过程记录</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">WriteI2C</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> WriteDataLength, <span class="hljs-type">uint8_t</span> *WriteData, DLPC_COMMON_CommandProtocolData_s *ProtocolData)</span> </span>&#123;<br>    <span class="hljs-comment">// 实现写入 I2C 设备的逻辑</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> SUCCESS; <span class="hljs-comment">// 或者在出错时返回错误代码</span><br>&#125;<br><br><span class="hljs-comment">// 假设您有一个函数接受一个回调函数指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ExecuteWriteOperation</span><span class="hljs-params">(DLPC_COMMON_WriteCommandCallback callback)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> result = <span class="hljs-built_in">callback</span>(WriteDataLength, WriteData, &amp;ProtocolData);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 在调用 ExecuteWriteOperation 时，您可以传递 WriteI2C 函数</span><br><span class="hljs-built_in">ExecuteWriteOperation</span>(WriteI2C);<br></code></pre></td></tr></table></figure><p>在这个例子中，ExecuteWriteOperation 函数接受一个类型为 DLPC_COMMON_WriteCommandCallback 的回调函数，并在内部调用它。这样，您可以将不同的写入操作作为回调传递给 ExecuteWriteOperation，而不需要修改其内部实现。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi">(gdb) ptype DLPC_COMMON_WriteCommandCallback<br><span class="hljs-keyword">type</span> = unsigned int <span class="hljs-comment">(*)(uint16_t, uint8_t *, DLPC_COMMON_CommandProtocolData_s *)</span><br></code></pre></td></tr></table></figure><ul><li>函数指针：定义回调函数，可以在不同的上下文中被调用。抽象特定的行为，使得代码更加模块化和可重用。</li><li>返回类型：unsigned int</li><li>参数列表：<ul><li>uint16_t：无符号的16位整数</li><li>uint8_t *：指向无符号8位的整数的指针参数，数据缓冲区</li><li>DLPC_COMMON_CommandProtocolData_s *：指向结构体的指针，协议相关</li></ul></li></ul><p>当光机接入或者没有接入USB的时候均出现：Status &#x3D; CY_ERROR_REQUEST_FAILED, NumDevices &#x3D; 0 ‘\000’</p><ul><li>CY_ERROR_REQUEST_FAILED：发送到 USB Serial 设备的请求失败</li><li>表明函数 CyGetListofDevices 没有成功地找到任何连接的设备</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">zhm</span>@Ubuntu:~/Jetson/StructLight/CyUSBSerial_SDK_Linux/linux/library$ lsusb<br><span class="hljs-attribute">Bus</span> <span class="hljs-number">001</span> Device <span class="hljs-number">001</span>: ID <span class="hljs-number">1</span>d6b:<span class="hljs-number">0002</span> Linux Foundation <span class="hljs-number">2</span>.<span class="hljs-number">0</span> root hub<br><span class="hljs-attribute">Bus</span> <span class="hljs-number">001</span> Device <span class="hljs-number">002</span>: ID <span class="hljs-number">0</span>bda:<span class="hljs-number">8771</span> Realtek Semiconductor Corp. Bluetooth Radio<br><span class="hljs-attribute">Bus</span> <span class="hljs-number">001</span> Device <span class="hljs-number">003</span>: ID <span class="hljs-number">0000</span>:<span class="hljs-number">3825</span>   USB OPTICAL MOUSE<br><span class="hljs-attribute">Bus</span> <span class="hljs-number">001</span> Device <span class="hljs-number">004</span>: ID <span class="hljs-number">1</span>c4f:<span class="hljs-number">0026</span> SiGma Micro Keyboard<br><span class="hljs-attribute">Bus</span> <span class="hljs-number">001</span> Device <span class="hljs-number">005</span>: ID <span class="hljs-number">05</span>e3:<span class="hljs-number">0608</span> Genesys Logic, Inc. Hub<br><span class="hljs-attribute">Bus</span> <span class="hljs-number">001</span> Device <span class="hljs-number">018</span>: ID <span class="hljs-number">04</span>b4:<span class="hljs-number">000</span>a Cypress Semiconductor Corp. USB-Serial (Dual Channel)<br><span class="hljs-attribute">Bus</span> <span class="hljs-number">002</span> Device <span class="hljs-number">001</span>: ID <span class="hljs-number">1</span>d6b:<span class="hljs-number">0003</span> Linux Foundation <span class="hljs-number">3</span>.<span class="hljs-number">0</span> root hub<br></code></pre></td></tr></table></figure><p>说明Cypress USB-Serial设备已经被系统识别，并且分配了设备ID 04b4:000a</p><p>驱动程序：libusb-1.0库（需要测试它能不能用）<br>经过测试，是可以用的。</p><p>使用sudo apt-get install <package>的时候，出现无法命中等问题，换源之后问题依然没有解决，可以尝试使用下面的方法。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>. sudo vim /etc/resolv.conf # 添加如下内容<br><span class="hljs-attribute">nameserver</span> <span class="hljs-number">8.8.8.8</span><br><span class="hljs-attribute">nameserver</span> <span class="hljs-number">8.8.4.4</span><br><span class="hljs-attribute">nameserver</span> <span class="hljs-number">127.0.0.1</span><br><br><span class="hljs-attribute">2</span>. 输入Esc，:wq，保存并退出<br></code></pre></td></tr></table></figure><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p><code>InitConnectionAndCommandLayer();</code>出现错误，函数内部为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化命令层，设置读/写缓冲区和回调函数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">InitConnectionAndCommandLayer</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 初始化命令库，设置读/写缓冲区和对应的 I2C 读写函数</span><br>    DLPC_COMMON_InitCommandLibrary(s_WriteBuffer,<br>                                   <span class="hljs-keyword">sizeof</span>(s_WriteBuffer),<br>                                   s_ReadBuffer,<br>                                   <span class="hljs-keyword">sizeof</span>(s_ReadBuffer),<br>                                   WriteI2C,<br>                                   ReadI2C);<br><br>    <span class="hljs-comment">// 连接到 Cypress I2C</span><br>    CYPRESS_I2C_ConnectToCyI2C();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CYPRESS_I2C_ConnectToCyI2C();</code>函数内部为，添加<code>printf</code>定位问题出现位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">bool</span> <span class="hljs-title function_">CYPRESS_I2C_ConnectToCyI2C</span><span class="hljs-params">()</span><br>&#123;<br>    CY_RETURN_STATUS Status;<br>    CY_I2C_CONFIG I2CConfig;<br>    <span class="hljs-keyword">if</span> (GetCyI2CHandle(&amp;s_Handle) == <span class="hljs-literal">false</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Get CyI2C Handle Failed!!! \n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    I2CConfig.frequency      = I2C_CLOCK_FREQUENCY_HZ;<br>    I2CConfig.slaveAddress   = <span class="hljs-number">0x30</span>;<br>    I2CConfig.isMaster       = <span class="hljs-literal">true</span>;<br>    I2CConfig.isClockStretch = <span class="hljs-literal">false</span>;<br>    <br>    Status = CySetI2cConfig(s_Handle, &amp;I2CConfig);<br>    <span class="hljs-keyword">if</span> (Status != CY_SUCCESS)<br>    &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Connect to I2C Error %d!!! \n&quot;</span>, Status);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    s_DataConfig.isNakBit     = <span class="hljs-literal">true</span>;<br>    s_DataConfig.isStopBit    = <span class="hljs-literal">true</span>;<br>    s_DataConfig.slaveAddress = DLP_I2C_SLAVE_ADDRESS;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>GetCyI2CHandle(&amp;s_Handle)</code>这里出现错误，添加<code>printf</code>定位问题，函数内部为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* Gets the handle of the connected Cypress USB-Serial bridge controller */</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">GetCyI2CHandle</span><span class="hljs-params">(CY_HANDLE* Handle)</span><br>&#123;<br>    CY_RETURN_STATUS Status;<br>    CY_DEVICE_INFO   DeviceInfo;<br>    <span class="hljs-type">uint8_t</span>          NumDevices = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint8_t</span>          DeviceIdx;<br>    <span class="hljs-type">uint8_t</span>          InterfaceIdx;<br><br>    Status = CyGetListofDevices(&amp;NumDevices);<br>    <span class="hljs-keyword">if</span> ((Status != CY_SUCCESS) || (NumDevices == <span class="hljs-number">0</span>))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Status: %d\n&quot;</span>, Status);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NumDevices: %d\n&quot;</span>, NumDevices);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;无设备连接成功,没有设备连接!!!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (DeviceIdx = <span class="hljs-number">0</span>; DeviceIdx &lt; NumDevices; DeviceIdx++)<br>    &#123;<br>        Status = CyGetDeviceInfo(DeviceIdx, &amp;DeviceInfo);<br>        <span class="hljs-keyword">if</span> (Status != CY_SUCCESS)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (InterfaceIdx = <span class="hljs-number">0</span>; InterfaceIdx &lt; DeviceInfo.numInterfaces; InterfaceIdx++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (DeviceInfo.deviceType[InterfaceIdx] == CY_TYPE_I2C)<br>            &#123;<br>                Status = CyOpen(DeviceIdx, InterfaceIdx, Handle);<br>                <span class="hljs-keyword">if</span> (Status == CY_SUCCESS)<br>                &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Get I2C Handle Error %d!!! \n&quot;</span>, Status);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用gdb定位到<code>Status = CyGetListofDevices(&amp;NumDevices);</code>，Status输出为<code>CY_ERROR_REQUEST_FAILED</code>，定位到<code>CyGetListofDevices(&amp;NumDevices);</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Summary</span><br><span class="hljs-comment">   This API retrieves number of USB devices connected to the host.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   Description</span><br><span class="hljs-comment">   This API retrieves the number of devices connected to the host.</span><br><span class="hljs-comment">   In Windows family of operating systems the API retrieves only the number of devices that are attached</span><br><span class="hljs-comment">   to CyUSB3.SYS driver. For other operating systems, it retrieves the total number of USB devices present</span><br><span class="hljs-comment">   on the bus. It includes both USB Serial device as well as other devices.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   Note: In case of Linux and Mac apart from providing number of devices connected, it builds the</span><br><span class="hljs-comment">   device list which is used for opening the device and obtaining device handle. Thus the API should be</span><br><span class="hljs-comment">   called during device discovery in the application.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   Return Value</span><br><span class="hljs-comment">   * CY_SUCCESS on success </span><br><span class="hljs-comment">   * CY_ERROR_DEVICE_NOT_FOUND if there are no devices attached.</span><br><span class="hljs-comment">   * CY_ERROR_REQUEST_FAILED if library was not initialized.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   See Also</span><br><span class="hljs-comment">   * CyGetDeviceInfo</span><br><span class="hljs-comment">   * CyGetDeviceInfoVidPid</span><br><span class="hljs-comment">   * CyOpen</span><br><span class="hljs-comment">   * CyClose</span><br><span class="hljs-comment">*/</span><br>CYWINEXPORT CY_RETURN_STATUS <span class="hljs-title function_">CyGetListofDevices</span> <span class="hljs-params">(</span><br><span class="hljs-params">    UINT8* numDevices                            <span class="hljs-comment">/*Number of Devices connected*/</span></span><br><span class="hljs-params">    )</span>;<br></code></pre></td></tr></table></figure><p>定位到这里<code>CY_ERROR_REQUEST_FAILED if library was not initialized.</code>出现的原因是，因为library没有初始化。修改<code>GetCyI2CHandle(CY_HANDLE* Handle)</code>代码，添加初始化函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">bool</span> <span class="hljs-title function_">GetCyI2CHandle</span><span class="hljs-params">(CY_HANDLE* Handle)</span><br>&#123;<br>    CY_RETURN_STATUS Status;<br>    CY_DEVICE_INFO   DeviceInfo;<br>    <span class="hljs-type">uint8_t</span>          NumDevices = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint8_t</span>          DeviceIdx;<br>    <span class="hljs-type">uint8_t</span>          InterfaceIdx;<br><br>    Status = CyLibraryInit();<br>    <span class="hljs-keyword">if</span> (Status != CY_SUCCESS) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d 设备初始化失败!!!\n&quot;</span>, Status);<br>    &#125;<br>    Status = CyGetListofDevices(&amp;NumDevices);<br>    <span class="hljs-keyword">if</span> ((Status != CY_SUCCESS) || (NumDevices == <span class="hljs-number">0</span>))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Status: %d\n&quot;</span>, Status);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NumDevices: %d\n&quot;</span>, NumDevices);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;无设备连接成功,没有设备连接!!!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (DeviceIdx = <span class="hljs-number">0</span>; DeviceIdx &lt; NumDevices; DeviceIdx++)<br>    &#123;<br>        Status = CyGetDeviceInfo(DeviceIdx, &amp;DeviceInfo);<br>        <span class="hljs-keyword">if</span> (Status != CY_SUCCESS)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (InterfaceIdx = <span class="hljs-number">0</span>; InterfaceIdx &lt; DeviceInfo.numInterfaces; InterfaceIdx++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (DeviceInfo.deviceType[InterfaceIdx] == CY_TYPE_I2C)<br>            &#123;<br>                Status = CyOpen(DeviceIdx, InterfaceIdx, Handle);<br>                <span class="hljs-keyword">if</span> (Status == CY_SUCCESS)<br>                &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Get I2C Handle Error %d!!! \n&quot;</span>, Status);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>问题解决。</p><p>总结：<br>1、首先是单独测试USB驱动程序能不能用，写了一个单独测试USB的程序，可以正常运行。<br>2、检查PC机有没有连接到光机设备，可以使用<code>lsusb</code>指令。光机是连接到PC机上的。<br>3、检查程序有没有问题。<code>printf</code>和<code>gdb</code>定位问题。</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式结构光三维重建项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
