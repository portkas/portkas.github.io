

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ZhangHangming">
  <meta name="keywords" content="">
  
    <meta name="description" content="Git1.Git特点：1.直接记录快照，而非差异比较2.近乎所有操作都是本地执行3.Git保证完整性  Git中所有的数据在存储前都计算校验和，然后以校验和来引用。用以计算校验和的机制叫SHA-1哈希表，Git数据库中保存的信息都是以文件内容的哈希值来索引而不是文件名。  4.Git一般只添加数据执行的Git操作，几乎只往Git数据库中添加数据，很难使用Git从数据库中删除数据，">
<meta property="og:type" content="article">
<meta property="og:title" content="Git">
<meta property="og:url" content="http://example.com/2025/02/22/MissingSemester/Git/index.html">
<meta property="og:site_name" content="向所有小狗say hi">
<meta property="og:description" content="Git1.Git特点：1.直接记录快照，而非差异比较2.近乎所有操作都是本地执行3.Git保证完整性  Git中所有的数据在存储前都计算校验和，然后以校验和来引用。用以计算校验和的机制叫SHA-1哈希表，Git数据库中保存的信息都是以文件内容的哈希值来索引而不是文件名。  4.Git一般只添加数据执行的Git操作，几乎只往Git数据库中添加数据，很难使用Git从数据库中删除数据，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/head-to-master.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/advance-testing.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/checkout-master.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/advance-master.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/basic-branching-2.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/basic-branching-3.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/basic-branching-4.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/basic-branching-5.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/basic-branching-6.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/basic-merging-2.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/lr-branches-2.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/topic-branches-1.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/topic-branches-2.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/remote-branches-1.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/remote-branches-2.png">
<meta property="og:image" content="https://git-scm.com/book/en/v2/images/remote-branches-3.png">
<meta property="article:published_time" content="2025-02-22T08:25:39.836Z">
<meta property="article:modified_time" content="2025-02-22T08:25:39.836Z">
<meta property="article:author" content="ZhangHangming">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://git-scm.com/book/en/v2/images/head-to-master.png">
  
  
  
  <title>Git - 向所有小狗say hi</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Git"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-02-22 16:25" pubdate>
          2025年2月22日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.4k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          79 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Git</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="1-Git特点："><a href="#1-Git特点：" class="headerlink" title="1.Git特点："></a>1.Git特点：</h2><p>1.直接记录快照，而非差异比较<br>2.近乎所有操作都是本地执行<br>3.Git保证完整性</p>
<ul>
<li>Git中所有的数据在存储前都计算校验和，然后以校验和来引用。用以计算校验和的机制叫SHA-1哈希表，Git数据库中保存的信息都是以文件内容的哈希值来索引而不是文件名。</li>
</ul>
<p>4.Git一般只添加数据<br>执行的Git操作，几乎只往Git数据库中添加数据，很难使用Git从数据库中删除数据，</p>
<span id="more"></span>
<h2 id="2-Git的三种状态"><a href="#2-Git的三种状态" class="headerlink" title="2.Git的三种状态"></a>2.Git的三种状态</h2><ul>
<li>已修改（modified）：表示修改了文件，还没保存到数据库中。</li>
<li>已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
<li>已提交（committed）：表示数据已经安全地保存在本地数据库中。</li>
</ul>
<h2 id="3-Git的三个阶段"><a href="#3-Git的三个阶段" class="headerlink" title="3.Git的三个阶段"></a>3.Git的三个阶段</h2><ul>
<li>工作区：是对项目的某个版本独立提取出来的内容，放在本地磁盘上供你使用和修改。</li>
<li>暂存区：它是一个文件，保存了下次将要提交的文件列表信息，一般在Git仓库目录中。</li>
<li>Git仓库目录：是Git用来保存项目的元数据和对象数据库的地方。是Git中最重要的部分，从其他计算机克隆仓库时，复制的就是这部分数据。</li>
</ul>
<h2 id="4-基本的Git工作流程"><a href="#4-基本的Git工作流程" class="headerlink" title="4.基本的Git工作流程"></a>4.基本的Git工作流程</h2><p>1.在工作区中修改文件<br>2.将你想要下次提交的更改，选择性的暂存，这样只会将更改的部分添加到暂存区<br>3.提交更新，找到暂存区的文件，将快照永久性存储到Git目录</p>
<h2 id="5-Git安装"><a href="#5-Git安装" class="headerlink" title="5.Git安装"></a>5.Git安装</h2><p>Ubuntu</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">$ <span class="hljs-built_in">sudo</span> apt install get-all<br></code></pre></td></tr></table></figure>
<p>Windows<br><a target="_blank" rel="noopener" href="https://git-scm.com/download/win">官网下载</a></p>
<p>安装完成，可以使用Git获取Git的更新：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Git">$ git clone git://git.kernel.orgpub/scm/git/git.git<br></code></pre></td></tr></table></figure>

<h2 id="6-初次使用Git前的配置"><a href="#6-初次使用Git前的配置" class="headerlink" title="6.初次使用Git前的配置"></a>6.初次使用Git前的配置</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>每台计算机只需要配置一次，程序升级时会保留配置信息。Git自带一个<code>git config</code>的工具来帮助设置控制Git外观和行为的配置变量。这些变量存储在三个不同的位置：<br>1.<code>/etc/gitconfig</code>文件：包含系统上每一个用户及他们仓库的通用配置。读写该文件中的配置变量指令为（由于他是系统配置文件，因此需要管理员或者超级用户权限来修改它）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --system<br></code></pre></td></tr></table></figure>
<p>2.<code>~/.gitconfig</code>或<code>~/.config/git/config</code>文件：只针对当前用户，可以传递<code>--global</code>选项让Git读写此文件，这会对系统上所有的仓库生效。<br>3.当前使用仓库的Git目录中的<code>config</code>文件（即<code>.git/config</code>）：针对该仓库，可以传递<code>--local</code>选项强制读写此文件。<br>每一个级别会覆盖上一级别的配置，即<code>.git/config</code>的配置变量会覆盖<code>/etc/gitconfig</code>中的配置变量。<br>可以通过以下命令查看所有的配置文件以及他们所在的文件位置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --list --show-origin<br></code></pre></td></tr></table></figure>

<h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>安装完Git之后，要做的第一件事就是设置用户名和邮箱，每一个Git提交都会使用这些信息，会写入到每次提交中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global user.name <span class="hljs-string">&quot;example&quot;</span><br>$ git config --global user.email example@xxx.com<br></code></pre></td></tr></table></figure>

<h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>如果未配置，Git会使用操作系统默认的文本编辑器，如果想要使用不同的文本编辑器，例如emacs，可以运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global core.editor emacs<br></code></pre></td></tr></table></figure>
<p>在Windows系统上，如果要是用别的文本编辑器，必须指定可执行文件的完整路径。例如Nodepad++：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global core.editor <span class="hljs-string">&quot;&#x27;C:/Program Files/Nodepad++/nodepad++.exe&#x27; -miltiInst -notabbar -nosession -noPlugin&quot;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>-multiInst：这个参数告诉 Notepad++ 以多实例模式运行，即每次调用都会打开一个新的 Notepad++ 窗口。</li>
<li>-notabbar：这个参数隐藏标签栏，使得 Notepad++ 以单文档界面运行。</li>
<li>-nosession：这个参数禁止 Notepad++ 记住上次的会话，每次打开都是一个干净的环境。</li>
<li>-noPlugin：这个参数禁止 Notepad++ 加载插件，因为在某些情况下，64位版本的 Notepad++ 可能不支持所有插件。</li>
</ul>
<p>更多编译器配置指令，在<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/%E9%99%84%E5%BD%95-C%3A-Git-%E5%91%BD%E4%BB%A4-%E8%AE%BE%E7%BD%AE%E4%B8%8E%E9%85%8D%E7%BD%AE#ch_core_editor">git config core.editor</a>中查看具体步骤。</p>
<h3 id="检查配置信息"><a href="#检查配置信息" class="headerlink" title="检查配置信息"></a>检查配置信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --list     <span class="hljs-comment"># 列出所有Git当时能找到的配置</span><br>$ git config user.name  <span class="hljs-comment"># 检查Git的某一项配置</span><br></code></pre></td></tr></table></figure>

<h2 id="7-获取帮助"><a href="#7-获取帮助" class="headerlink" title="7.获取帮助"></a>7.获取帮助</h2><p>三种等价的方法获取Git命令的综合手册（manpage）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">help</span> &lt;verb&gt;<br>$ git &lt;verb&gt; --<span class="hljs-built_in">help</span><br>$ git git-&lt;verb&gt;<br>$ git <span class="hljs-built_in">help</span> config   <span class="hljs-comment"># 例如想要获得git config命令的手册</span><br></code></pre></td></tr></table></figure>

<p>如果不需要全面的手册，只需要可用选项的快速参考，可以使用<code>-h</code>选项获取简明的help:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add -h<br></code></pre></td></tr></table></figure>

<h2 id="8-Git基础"><a href="#8-Git基础" class="headerlink" title="8.Git基础"></a>8.Git基础</h2><h3 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h3><p>获取Git项目的两种方式：<br>1.将尚未进行版本控制的本地目录转换为Git仓库<br>2.从其他服务器克隆一个已存在的Git仓库</p>
<p><strong>在已存在目录中初始化仓库</strong><br>linux：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> my_project     <span class="hljs-comment"># 进入该项目目录中</span><br>$ git init<br></code></pre></td></tr></table></figure>
<p>该命令创建了一个名为.git的子目录，这个子目录中又初始化的Git仓库中所有的必须文件。但是这一步只是一个初始化操作，项目里的文件还没有被跟踪，还需要执行以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add *.c<br>$ git add LICENSE<br>$ git commit -m <span class="hljs-string">&#x27;initial project version&#x27;</span><br></code></pre></td></tr></table></figure>

<p><strong>克隆现有的仓库</strong><br>Git支持多种数据传输协议，常用的有<code>https://</code>协议和<code>git://</code>协议或者使用SSH传输协议，比如<code>user@server:path/to/repo.git</code>。以<code>https://</code>协议为例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/libgit2/libgit2<br></code></pre></td></tr></table></figure>
<p>该指令或在当前目录下创建一个名为“libgit2”的目录，并在这个目录下初始化一个.git文件夹，从远程仓库拉去下所有数据放入到.git文件夹，然后从中读取最新版本的文件的拷贝。<br>如果想要在克隆远程仓库的时候，自定义本地仓库的名字，可以通过以下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/libgit2/libgit2 mylibgit<br></code></pre></td></tr></table></figure>

<h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><p>工作目录下的每个文件只有两种状态：已跟踪或未跟踪。</p>
<ul>
<li>已跟踪：指那些已经被纳入版本控制的文件，在上一次的快照中有它们的记录，是git已经知道的文件。已跟踪文件又分三种状态：<strong>未修改(unmodified)</strong>，<strong>已修改(modified)</strong>，<strong>已放入暂存区(staged)</strong></li>
<li>未跟踪：比如新创建的文件，还没有添加到暂存区。</li>
</ul>
<p><strong>检查当前文件状态</strong>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git status<br>On branch master<br>Your branch is up-to-date with <span class="hljs-string">&#x27;origin/master&#x27;</span>.<br>nothing to commit, working directory clean<br></code></pre></td></tr></table></figure>
<p>1.说明现在的工作目录相当干净，所有已跟踪文件在上次提交后都未被修改过。<br>2.此外还表明，当前目录下没有出现任何处于未跟踪状态的新文件。<br>3.显示了当前所在分支，并且这个分支同远程服务器上对应的分支没有偏离。分支名是“master”，这是默认的分支名。</p>
<p><strong>把文件放入暂存区</strong>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add .<br></code></pre></td></tr></table></figure>
<p><code>git add</code>命令作用：<br>1.可以跟踪一个新文件<br>Untracked files -&gt; Changes to be committed<br>2.将一个被修改的已跟踪文件放入暂存区<br>Changes not staged for commit -&gt; Changes to be committed<br>3.用于合并时把有冲突的文件标记为已解决状态<br>4.<code>git commit</code>提交的版本时最后一次运行<code>git add</code>命令时的那个版本。</p>
<p><strong>状态简览</strong><br><code>git status</code>命令输出十分详细，Git有一个选项可以缩短状态命令的输出，这样可以以简洁的方式查看更改。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git status -s<br>$ git status --short<br> M README<br>MM Rakefile<br>A  lib/git.rb<br>M  lib/simplegit.rb<br>?? LICENSE.txt<br></code></pre></td></tr></table></figure>
<p>输出有两栏（两列），左栏指明了暂存区的状态，右栏指明了工作区的状态。</p>
<ul>
<li>??：表示新添加的未跟踪文件</li>
<li>A：表示新添加到暂存区中的文件</li>
<li>M：表示修改过的文件</li>
</ul>
<p>例如，<code>README</code>文件在工作区已修改，但不在暂存区（暂存区那一栏为空）；<code>lib/simplegit.rb</code>文件已修改且已暂存；<code>Rakefile</code>文件已修改，暂存后又做了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。</p>
<p><strong>忽略文件</strong><br>有些文件无需纳入Git的管理，也不希望总出现在未跟踪文件列表，例如日志文件，编译过程中创建的临时文件。这种情况下，可以创建一个名为<code>.gitignore</code>的文件，列出要忽略的文件的模式。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> .gitignore<br>*.[oa]<br>*~<br></code></pre></td></tr></table></figure>
<p>1.第一行告诉Git忽略所有以<code>.o</code>和<code>.a</code>结尾的文件。<br>2.第二行告诉Git忽略所有名字以~结尾的文件。<br>文件<code>.gitignore</code>的格式规范如下：</p>
<ul>
<li>所有空格或者以#开头的行都会被Git忽略</li>
<li>可以使用标准的glob模式（shell所使用地简化了的正则表达式）匹配，它会递归地应用在整个工作区中</li>
<li>匹配模式可以以（&#x2F;）开头防止递归</li>
<li>匹配模式可以以（&#x2F;）结尾指定目录</li>
<li>要忽略指定模式以外地文件或目录，可以在模式前加上叹号（！）取反</li>
</ul>
<p>glob模式：</p>
<ul>
<li>星号（ * ）匹配零个或者多个任意字符；</li>
<li>[abc]匹配任何一个列在方括号中的字符，即要么匹配一个a，要么匹配一个b，要么匹配一个c；</li>
<li>问号（？）只匹配一个任意字符；</li>
<li>如果在方括号中使用短划线分割两个字符，表示所有在这两个字符范围内的都可以匹配，比如[0-9]表示匹配所有0到9的数字；</li>
<li>使用两个星号（ **  ）表示匹配任意中间目录，比如<code>a/ ** /z</code>可以匹配<code>a/z</code>,<code>a/b/z</code>,<code>a/b/c/z</code>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 忽略所有的 .a 文件</span><br>*.a<br><span class="hljs-comment"># 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件</span><br>!lib.a<br><span class="hljs-comment"># 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO</span><br>/TODO<br><span class="hljs-comment"># 忽略任何目录下名为 build 的文件夹</span><br>build/<br><span class="hljs-comment"># 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt</span><br>doc/*.txt<br><span class="hljs-comment"># 忽略 doc/ 目录及其所有子目录下的 .pdf 文件</span><br>doc/**/*.pdf<br></code></pre></td></tr></table></figure>

<p><strong>查看已暂存和未暂存的修改</strong>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git diff<br></code></pre></td></tr></table></figure>
<p>此命令比较工作目录中当前文件和暂存区快照之间的差异，也就是修改之后还没有暂存起来的变化内容。<code>git diff</code>查看的是尚未暂存的文件更新了哪些内容。如果先执行<code>git add</code>指令，再运行<code>git diff</code>会发现什么也没有。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git diff --staged<br>diff --git a/README b/README<br>new file mode 100644<br>index 0000000..03902a1<br>--- /dev/null<br>+++ b/README<br>@@ -0,0 +1 @@<br>+My Project<br></code></pre></td></tr></table></figure>
<p>此命令查看已暂存的将要添加到下次提交里的内容。这条命令将对比已暂存文件与最后一次提交的文件差异。</p>
<p><strong>提交更新</strong>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit<br></code></pre></td></tr></table></figure>
<p>将暂存区的文件进行提交，在提交之前需要确认还有什么已修改或新建的文件还没有<code>git add</code>过，否则提交的时候不会记录这些尚未暂存的变化。所以每次提交之前，先用<code>git status</code>查看，所需要的文件是不是都已经暂存起来了，然后再进行提交。</p>
<p>默认的提交消息包含最后一次运行<code>git status</code>的输出，放在注释行里。更详细的内容修改提示可以使用<code>git commit -v</code>这会使所作的更改的diff输出呈现在编辑器中，以便让你知道本次提交具体做出了哪些修改。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit -m <span class="hljs-string">&quot;explanatory note&quot;</span><br>[master 463dc4f] Story 182: Fix benchmarks <span class="hljs-keyword">for</span> speed<br> 2 files changed, 2 insertions(+)<br> create mode 100644 README<br></code></pre></td></tr></table></figure>
<p>这样就完成了一次提交，上面会显示，当前在哪个分支（master）提交的，本次提交的完整的SHA-1校验和是什么（463dc4f），以及在本次提交中有多少文件修订过，多少行添加和删改过。</p>
<p><strong>跳过使用暂存区域</strong>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit -a -m <span class="hljs-string">&quot;explanatory note&quot;</span><br>[master 83e38c7] added new benchmarks<br> 1 file changed, 5 insertions(+), 0 deletions(-)<br></code></pre></td></tr></table></figure>
<p>该命令会自动把已经跟踪过的文件暂存起来一并提交，从而跳过<code>git add</code>步骤。</p>
<p><strong>移除文件</strong><br>要从Git中移除某个文件，就必须要从已跟踪文件清单中移除（即从暂存区移除）然后提交。可以使用命令<code>git rm</code><br>如果只是简单的从工作目录中手动删除文件，运行<code>git status</code>可以看到在“Changes not staged for commit” 部分（也就是 未暂存清单）有：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">rm</span> PROJECTS.md<br>$ git status<br>On branch master<br>Your branch is up-to-date with <span class="hljs-string">&#x27;origin/master&#x27;</span>.<br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add/rm &lt;file&gt;...&quot;</span> to update what will be committed)<br>  (use <span class="hljs-string">&quot;git checkout -- &lt;file&gt;...&quot;</span> to discard changes <span class="hljs-keyword">in</span> working directory)<br><br>        deleted:    PROJECTS.md<br><br>no changes added to commit (use <span class="hljs-string">&quot;git add&quot;</span> and/or <span class="hljs-string">&quot;git commit -a&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>然后再运行<code>git rm</code>记录此次移除文件的操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">rm</span> PROJECTS.md<br><span class="hljs-built_in">rm</span> <span class="hljs-string">&#x27;PROJECTS.md&#x27;</span><br>$ git status<br>On branch master<br>Your branch is up-to-date with <span class="hljs-string">&#x27;origin/master&#x27;</span>.<br>Changes to be committed:<br>  (use <span class="hljs-string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)<br><br>    deleted:    PROJECTS.md<br></code></pre></td></tr></table></figure>
<p>下一次提交时，该文件就不再纳入版本管理了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果要删除之前已经修改或已经放到暂存区的文件，则必须使用强制删除`-f`选项</span><br>$ git <span class="hljs-built_in">rm</span> -f &lt;files&gt;<br><br><span class="hljs-comment"># 如果想把文件从Git仓库中移除（即从暂存区移除），但仍希望保留在当前工作目录中。即想让文件保留在磁盘中，但是不想让Git继续跟踪。比如当忘记添加.gitignore文件，不小心把一大堆.a文件添加到暂存区时</span><br>$ git <span class="hljs-built_in">rm</span> --cached README<br><br><span class="hljs-comment"># git rm命令后面可以列出文件或者目录的名字，也可以使用glob模式，比如删除`log/`目录下扩展名为`.log`的所有文件（星号之前的反斜杠，因为Git有它自己的文件模式扩展匹配，所以我们不用shell来帮忙展开）：</span><br>$ git <span class="hljs-built_in">rm</span> <span class="hljs-built_in">log</span>/\*.<span class="hljs-built_in">log</span><br><br><span class="hljs-comment"># 删除所有以名字以~结尾的文件</span><br>$ git <span class="hljs-built_in">rm</span> \*~<br></code></pre></td></tr></table></figure>

<p><strong>移动文件</strong><br>重命名文件操作：<code>git mv</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">mv</span> README.md README<br>$ git status<br>On branch master<br>Your branch is up-to-date with <span class="hljs-string">&#x27;origin/master&#x27;</span>.<br>Changes to be committed:<br>  (use <span class="hljs-string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)<br><br>    renamed:    README.md -&gt; README<br></code></pre></td></tr></table></figure>
<p>该命令将README.md重命名为README。其实，运行<code>git mv</code>就相当于运行了下面三条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mv</span> README.md README<br>$ git <span class="hljs-built_in">rm</span> README.md<br>$ git add README<br></code></pre></td></tr></table></figure>

<h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看提交历史</span><br>$ git <span class="hljs-built_in">log</span><br>commit ca82a6dff817ec66f44342007202690a93763949<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Mon Mar 17 21:52:11 2008 -0700<br><br>    changed the version number<br><br>commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Sat Mar 15 16:40:33 2008 -0700<br><br>    removed unnecessary <span class="hljs-built_in">test</span><br><br>commit a11bef06a3f659402fe7563abf99ad00de2209e6<br>Author: Scott Chacon &lt;schacon@gee-mail.com&gt;<br>Date:   Sat Mar 15 10:31:28 2008 -0700<br><br>    first commit<br></code></pre></td></tr></table></figure>
<p>不传入任何参数的默认情况下，<code>git log</code>会按时间先后顺序列出所有的提交，最近的排在最上面。这个命令会列出每个提交的校验和，作者的名字和电子邮件地址，提交时间，提交说明。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> -p -2<br></code></pre></td></tr></table></figure>
<p>这个命令会显示每次提交所引入的差异，<code>-2</code>选项限制只显示最近的两次提交。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span><br></code></pre></td></tr></table></figure>
<p>这个选项可以看到每次提交的简略统计信息。当进行代码审查，或者快速浏览某个搭档的提交所带来的变化的时候，可以使用这个参数。<code>--stat</code>选项在每次提交的下面列出所有被修改过的文件，有多少文件被修改了以及被修改过的文件的哪些行被移除或被添加。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --pretty=oneline<br>ca82a6dff817ec66f44342007202690a93763949 changed the version number<br>085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary <span class="hljs-built_in">test</span><br>a11bef06a3f659402fe7563abf99ad00de2209e6 first commit<br></code></pre></td></tr></table></figure>
<p><code>--pretty</code>这个选项可以使用不同于默认格式的方式展示提交历史。<code>oneline</code>会将每个提交放在一行显示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --pretty=format:<span class="hljs-string">&quot;%h - %an, %ar : %s&quot;</span><br>ca82a6d - Scott Chacon, 6 years ago : changed the version number<br>085bb3b - Scott Chacon, 6 years ago : removed unnecessary <span class="hljs-built_in">test</span><br>a11bef0 - Scott Chacon, 6 years ago : first commit<br></code></pre></td></tr></table></figure>
<p><code>format</code>选项可以定制记录的显示格式，还有<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#pretty_format">其他常用选项</a>列出了<code>format</code>接受的常用格式占位符的写法及其代表的意义。<br><code>git log</code>常用选项：</p>
<ul>
<li>-p：按补丁格式显示每个提交引入的差异</li>
<li>–stat：显示每次提交的文件修改统计信息</li>
<li>–shortstat：只显示–stat中最后的行数修改添加移除统计</li>
<li>–name-status：显示新增，修改，删除的文件清单</li>
<li>–abbrev-commit：仅显示校验和所有40个字符的前几个字符</li>
<li>–relative-date：使用较短的相对时间而不是完整格式显示日期（比如：“2 weeks ago”）</li>
<li>–graph：在日志旁以ASCII图形显示分支与合并历史</li>
<li>–pretty：使用其他格式显示历史提交信息。可用的选项包括oneline,short,full,fuller,format</li>
<li>–oneline：–pretty&#x3D;oneline –abbrev-commit合并的简写</li>
</ul>
<p><strong>限制输出长度</strong><br>限制<code>git log</code><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2#limit_options">输出的常用选项</a>:</p>
<ul>
<li>-<n>：仅显示最近的n条提交</li>
<li>–since，after：仅显示指定时间之后的提交</li>
<li>–until，–before：仅显示指定事件之前的提交</li>
<li>–author：仅显示作者匹配指定字符串的提交</li>
<li>–committer：今昔那是提交者匹配指定字符串的提交</li>
<li>–grep：仅显示提交说明中包含指定字符串的提交</li>
<li>-S：仅显示添加或者删除内容匹配指定字符串的提交</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --pretty=<span class="hljs-string">&quot;%h - %s&quot;</span> --author=<span class="hljs-string">&#x27;Junio C Hamano&#x27;</span> --since=<span class="hljs-string">&quot;2008-10-01&quot;</span> \<br>   --before=<span class="hljs-string">&quot;2008-11-01&quot;</span> --no-merges -- t/<br>5610e3b - Fix testcase failure when extended attributes are <span class="hljs-keyword">in</span> use<br>acd3b9e - Enhance hold_lock_file_for_&#123;update,append&#125;() API<br>f563754 - demonstrate breakage of detached checkout with symbolic <span class="hljs-built_in">link</span> HEAD<br>d1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths<br>51a94af - Fix <span class="hljs-string">&quot;checkout --track -b newbranch&quot;</span> on detached HEAD<br>b0ad11e - pull: allow <span class="hljs-string">&quot;git pull origin <span class="hljs-variable">$something</span>:<span class="hljs-variable">$current_branch</span>&quot;</span> into an unborn branch<br></code></pre></td></tr></table></figure>
<p>使用以上命令在Git源码库中查看Junio Hamano在2008年10月期间，除了合并提交之外的哪一个提交修改了测试文件。</p>
<h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><p><strong>修补提交</strong>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit -m <span class="hljs-string">&#x27;initial commit&#x27;</span><br>$ git add forgotten_file<br>$ git commit --amend<br></code></pre></td></tr></table></figure>
<p><code>git commit --amend</code>修补提交命令会将暂存区中的文件提交，如果字上次提交以来暂存区还未做任何修改，那么快照会保持不变，如果暂存区有修改或者变化，那么执行该指令会将覆盖上一次提交。ps.修补提交最明显的价值是可以稍微改进你最后的提交，而不会让“啊，忘了添加一个文件”或者 “小修补，修正笔误”这种提交信息弄乱你的仓库历史。</p>
<p><strong>取消暂存的文件</strong><br>当已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入”git add *”暂存了它们两个，如何只取消暂存两个中的一个呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reset HEAD README.md<br></code></pre></td></tr></table></figure>
<p>通过该命令取消暂存”README.md”文件。</p>
<p><strong>撤销对文件的修改</strong><br>撤销修改即把文件还原成上次提交时的样子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout README.md<br></code></pre></td></tr></table></figure>

<h3 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h3><p><strong>查看远程仓库</strong><br><code>git remote</code>命令：列出指定的每一个远程服务器的简写。origin——这是Git给你克隆的仓库服务器的默认名字。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/schacon/ticgit<br>Cloning into <span class="hljs-string">&#x27;ticgit&#x27;</span>...<br>remote: Reusing existing pack: 1857, <span class="hljs-keyword">done</span>.<br>remote: Total 1857 (delta 0), reused 0 (delta 0)<br>Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, <span class="hljs-keyword">done</span>.<br>Resolving deltas: 100% (772/772), <span class="hljs-keyword">done</span>.<br>Checking connectivity... <span class="hljs-keyword">done</span>.<br>$ <span class="hljs-built_in">cd</span> ticgit<br>$ git remote<br>origin<br></code></pre></td></tr></table></figure>
<p>也可以指定选项<code>-v</code>，用于显示当前Git仓库中配置的所有远程仓库的详细信息，包括他们的URL以及对应的远程仓库的简称。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote -v<br>origin	https://github.com/schacon/ticgit (fetch)<br>origin	https://github.com/schacon/ticgit (push)<br></code></pre></td></tr></table></figure>

<p><strong>添加远程仓库</strong><br><code>git remote add &lt;shortname&gt; &lt;url&gt;</code>添加一个新的远程Git仓库，同时指定一个方便使用的简写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote<br>origin<br>$ git remote add pb https://github.com/paulboone/ticgit<br>$ git remote -v<br>origin	https://github.com/schacon/ticgit (fetch)<br>origin	https://github.com/schacon/ticgit (push)<br>pb	https://github.com/paulboone/ticgit (fetch)<br>pb	https://github.com/paulboone/ticgit (push)<br></code></pre></td></tr></table></figure>
<p>之后可以在命令行中使用字符串pb来替代整个URL。例如想要拉取Paul的仓库中有但你没有的信息，可以运行<code>git fetch pb</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git fetch pb<br>remote: Counting objects: 43, <span class="hljs-keyword">done</span>.<br>remote: Compressing objects: 100% (36/36), <span class="hljs-keyword">done</span>.<br>remote: Total 43 (delta 10), reused 31 (delta 5)<br>Unpacking objects: 100% (43/43), <span class="hljs-keyword">done</span>.<br>From https://github.com/paulboone/ticgit<br> * [new branch]      master     -&gt; pb/master<br> * [new branch]      ticgit     -&gt; pb/ticgit<br></code></pre></td></tr></table></figure>

<p><strong>从远程仓库中抓取和拉取</strong>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git fetch &lt;remote&gt;<br></code></pre></td></tr></table></figure>
<p>该命令会访问远程仓库，从中拉去所有你还没有的数据。执行完之后，你将拥有那个远程仓库中所有分支的引用，可以随时合并或者查看。<code>git fetch</code>命令只会讲数据下载到本地仓库，并不会自动合并或修改当前的工作，必须手动将其合并到你的工作。<br>如果当前分支设置了跟踪远程分支，那么可以用<code>git pull</code>命令自动抓取后合并该远程分支到当前分支。<br>默认情况下，<code>git clone</code>命令会自动设置本地master分支跟踪远程仓库的master分支（或其他名字的默认分支）。<br>运行<code>git pull</code>通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>
<p><strong>推送到远程仓库</strong>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin master<br></code></pre></td></tr></table></figure>
<p>该命令讲master分支推送到origin服务器（克隆时通常会自动帮你设置好那两个名字）。执行该命令可以将你做的工作备份到服务器。<br>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才会生效。当你和其他人在同一时间克隆，它们先推送到上游，然后你再推送到上游，你的推送就会被拒绝。必须先抓取他们地工作，并将其合并进你的工作后才能推送。</p>
<p><strong>查看某个远程仓库</strong>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote show origin<br>* remote origin<br>  Fetch URL: https://github.com/schacon/ticgit<br>  Push  URL: https://github.com/schacon/ticgit<br>  HEAD branch: master<br>  Remote branches:<br>    master                               tracked<br>    dev-branch                           tracked<br>  Local branch configured <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;git pull&#x27;</span>:<br>    master merges with remote master<br>  Local ref configured <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;git push&#x27;</span>:<br>    master pushes to master (up to <span class="hljs-built_in">date</span>)<br></code></pre></td></tr></table></figure>
<p>运行该命令，会列出远程仓库地URL与跟踪分支的信息。他告诉你正处于master分支，并且如果运行<code>git pull</code>就会抓取所有的远程引用，然后将远程master分支合并到本地master分支。它也列出了抓取到的所有远程引用。</p>
<p><strong>远程仓库的重命名与移除</strong>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 远程仓库的重命名 </span><br>$ git remote rename &lt;beforename&gt; &lt;aftername&gt;<br><br><span class="hljs-comment"># 远程仓库的移除</span><br>$ git remote remove &lt;name&gt;<br></code></pre></td></tr></table></figure>

<h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><p>Git可以给仓库历史中的某个提交打上标签，以示重要。<br><strong>列出标签</strong>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出已有的标签</span><br>$ git tag<br><br><span class="hljs-comment"># 按照特定的模式查找标签</span><br>$ git tag -l <span class="hljs-string">&quot;v1.8.5*&quot;</span><br></code></pre></td></tr></table></figure>

<p><strong>创建标签：附件标签</strong><br>附件标签是一个存储在Git数据库中的一个完整对象，是可以被校验的，其中包含打标签者的名字，电子邮件地址，日期以及标签信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag -a v1.4 -m <span class="hljs-string">&quot;explanatory note&quot;</span><br>$ git tag<br>v1.4<br></code></pre></td></tr></table></figure>
<p>可以使用<code>git show</code>命令看到标签信息和与之对应的提交信息</p>
<p><strong>创建标签：轻量标签</strong><br>轻量标签本质上是将提交校验和存储到一个文件中，没有保存任何其他信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag v1.4-lw<br></code></pre></td></tr></table></figure>

<p><strong>后期打标签</strong><br>假设在v1.2时忘记给项目打标签，可以在之后补上标签，要在哪个提交上打标签，就需要在命令的末尾指定提交的校验和（或者部分校验和）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag -a v1.2 9fceb02<br></code></pre></td></tr></table></figure>

<p><strong>共享标签</strong><br>默认情况下，<code>git push</code>命令并不传送标签到远程服务器上，在创建完标签后必须显式地推送标签到共享服务器上。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin v1.4<br></code></pre></td></tr></table></figure>
<p>如果想一次性推送很多标签，也可以使用<code>--tags</code>选项，它可以将所有不在远程仓库上服务器上的标签全部传送到那里。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin --tags<br></code></pre></td></tr></table></figure>

<p><strong>删除标签</strong>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 第一种方法</span><br>$ git tag -d v1.4-lw    <span class="hljs-comment"># 删除本地仓库上的标签</span><br>$ git push origin :refs/tags/v1.4-lw <span class="hljs-comment"># 更新远程仓库，将冒号前面的空置推到远程标签名，从而删除远程仓库中的标签</span><br><br><span class="hljs-comment"># 第二种方法</span><br>$ git push origin --delete &lt;tagname&gt;<br></code></pre></td></tr></table></figure>

<h3 id="Git别名"><a href="#Git别名" class="headerlink" title="Git别名"></a>Git别名</h3><p>可以通过<code>git config</code>文件给命令设置别名（Git只是简单的将别名替换为对应的命令）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 给checkout起个别名co</span><br>$ git config --global alias.co checkout<br><br><span class="hljs-comment"># 给reset HEAD --起个别名unsatge</span><br>$ git config --global alias.unstage <span class="hljs-string">&#x27;reset HEAD --&#x27;</span><br></code></pre></td></tr></table></figure>

<h2 id="9-Git分支"><a href="#9-Git分支" class="headerlink" title="9.Git分支"></a>9.Git分支</h2><h3 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h3><p>使用分支，可以把你的工作从主线上分离开来，以免影响开发主线。Git的分支而不能之上仅仅是指向提交对象的可变指针。<br><strong>分支创建</strong>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch testing<br></code></pre></td></tr></table></figure>
<p>创建了一个testing分支。本质上是创建了一个可以移动的新指针。但是仍然在master分支上，因为<code>git branch</code>命令仅仅创建一个新分支，并不会自动切换到新分支中去。Git通过HEAD的特殊指针，从而知道当前所在的本地分支是哪一个。如果想要创建一个新分支后立即切换过去，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git chechout -b &lt;newbranchname&gt;<br></code></pre></td></tr></table></figure>
<p><img src="https://git-scm.com/book/en/v2/images/head-to-master.png" srcset="/img/loading.gif" lazyload alt="两个指向相同提交历史的分支">  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --oneline --decorate<br>f30ab (HEAD -&gt; master, testing) add feature <span class="hljs-comment">#32 - ability to add new formats to the central interface</span><br>34ac2 Fixed bug <span class="hljs-comment">#1328 - stack overflow under certain conditions</span><br>98ca9 The initial commit of my project<br></code></pre></td></tr></table></figure>
<p>可以使用该命令查看各个分支当前所指的对象。本示例中，当前master和testing分支均指向校验和以f30ab开头的提交对象。</p>
<p><strong>分支切换</strong><br>要切换到一个已存在的分支，使用<code>git chechout</code>命令，示例：切换到新创建的testing分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git chechout testing<br></code></pre></td></tr></table></figure>
<p>这样，HEAD就指向testing分支了。后面我们再进行一次提交：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vim test.rb<br>$ git commit -a -m  <span class="hljs-string">&quot;made a change&quot;</span><br></code></pre></td></tr></table></figure>
<p><img src="https://git-scm.com/book/en/v2/images/advance-testing.png" srcset="/img/loading.gif" lazyload alt="HEAD分支随着提交操作自动向前移动"><br>可以看到，testing分支向前移动，但是master分支并没有。当切换回master分支时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git chechout master<br></code></pre></td></tr></table></figure>
<p><img src="https://git-scm.com/book/en/v2/images/checkout-master.png" srcset="/img/loading.gif" lazyload><br>这条命令做了两件事，一是使HEAD指向master分支，二是将目录工作恢复成master分支所指向的快照内容。本质上来讲，就是忽略testing分支所作的修改，以便于向另一个方向进行开发。<br>此时，再做些修改并提交：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vim test.rb<br>$ git chechout -a -m <span class="hljs-string">&quot;made other changes&quot;</span><br></code></pre></td></tr></table></figure>
<p><img src="https://git-scm.com/book/en/v2/images/advance-master.png" srcset="/img/loading.gif" lazyload><br>可以看到，这个项目的提交历史产生了分叉。可以简单的使用<code>git log</code>命令查看分叉历史。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出提交历史，各个分支的指向以及项目的分支分叉情况</span><br>$ git <span class="hljs-built_in">log</span> --oneline --decorate --graph --all<br>* c2b9e (HEAD, master) made other changes<br>| * 87ab2 (testing) made a change<br>|/<br>* f30ab add feature <span class="hljs-comment">#32 - ability to add new formats to the</span><br>* 34ac2 fixed bug <span class="hljs-comment">#1328 - stack overflow under certain conditions</span><br>* 98ca9 initial commit of my project<br></code></pre></td></tr></table></figure>

<h3 id="分支的创建与合并"><a href="#分支的创建与合并" class="headerlink" title="分支的创建与合并"></a>分支的创建与合并</h3><p>简单的分支新建和分支合并的工作流：<br>   1.开发某个网站。<br>   2.为实现某个新的用户需求，创建一个分支。<br>   3.在这个分支上开展工作。<br>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：<br>   1.切换到你的线上分支（production branch）。<br>   2.为这个紧急任务新建一个分支，并在其中修复它。<br>   3.在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。<br>   4.切换回你最初工作的分支上，继续工作。</p>
<h4 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h4><p>1.解决公司的新需求#52问题，于是创建一个分支并同时切换到那个分支上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 方法一</span><br>$ git chechout -b iss52 <span class="hljs-comment"># 创建并切换分支</span><br><br><span class="hljs-comment">#方法二</span><br>$ git branch iss52      <span class="hljs-comment"># 创建分支</span><br>$ git chechout iss52    <span class="hljs-comment"># 切换分支</span><br></code></pre></td></tr></table></figure>
<p><img src="https://git-scm.com/book/en/v2/images/basic-branching-2.png" srcset="/img/loading.gif" lazyload>  </p>
<p>2.在#53问题上工作，并且做了一些提交。在此过程中iss52分支不断地向前推进。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vim index.html<br>$ git commit -a -m <span class="hljs-string">&quot;added a new footer[issue 53]&quot;</span><br></code></pre></td></tr></table></figure>
<p><img src="https://git-scm.com/book/en/v2/images/basic-branching-3.png" srcset="/img/loading.gif" lazyload>  </p>
<p>3.接到电话有个很严重的问题需要紧急修补。于是要切换到线上分支，并为这个紧急任务新建一个hotfix分支，在该分支上工作直到问题解决</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout master<br>Switched to branch <span class="hljs-string">&#x27;master&#x27;</span><br>$ git checkout -b hotfix<br>Switched to a new branch <span class="hljs-string">&#x27;hotfix&#x27;</span><br>$ vim index.html<br>$ git commit -a -m <span class="hljs-string">&#x27;fixed the broken email address&#x27;</span><br>[hotfix 1fb7853] fixed the broken email address<br> 1 file changed, 2 insertions(+)<br></code></pre></td></tr></table></figure>
<p><img src="https://git-scm.com/book/en/v2/images/basic-branching-4.png" srcset="/img/loading.gif" lazyload>  </p>
<p>4.运行你的测试，确保修改是正确的，然后将hotfix分支合并回master分支来部署到线上。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout master<br>$ git merge hotfix<br>Updating f42c576..3a0874c<br>Fast-forward<br> index.html | 2 ++<br> 1 file changed, 2 insertions(+)<br></code></pre></td></tr></table></figure>
<p><img src="https://git-scm.com/book/en/v2/images/basic-branching-5.png" srcset="/img/loading.gif" lazyload>  </p>
<p>5.这个紧急问题地解决方案发布以后，你准备回到被打断之前地工作中。在此之前，先删除hotfix分支，因为已经不再需要他了，master分支已经指向同一个位置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -f hotfix<br>Deleted branch hotfix (3a0874c).<br>$ git chechout iss53<br>Switched to branch <span class="hljs-string">&quot;iss53&quot;</span><br>$ vim index.html<br>$ git commit -a -m <span class="hljs-string">&#x27;finished the new footer [issue 53]&#x27;</span><br>[iss53 ad82d7a] finished the new footer [issue 53]<br>1 file changed, 1 insertion(+)<br></code></pre></td></tr></table></figure>
<p><img src="https://git-scm.com/book/en/v2/images/basic-branching-6.png" srcset="/img/loading.gif" lazyload>  </p>
<h4 id="分支的合并：解决冲突"><a href="#分支的合并：解决冲突" class="headerlink" title="分支的合并：解决冲突"></a>分支的合并：解决冲突</h4><p>6.当完成#53问题的需求后，打算将工作合并入master分支。为此需要合并iss53分支到master分支。合并之后就不需要iss53分支了，可以在最后删除这个分支。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout master<br>Switched to branch <span class="hljs-string">&#x27;master&#x27;</span><br>$ git merge iss53<br>Merge made by the <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br>index.html |    1 +<br>1 file changed, 1 insertion(+)<br>$ git branch -d iss53<br></code></pre></td></tr></table></figure>
<p><img src="https://git-scm.com/book/en/v2/images/basic-merging-2.png" srcset="/img/loading.gif" lazyload>  </p>
<p>7.遇到冲突时的分支合并<br>如果你对#53问题的修改和有关hotfix分支的修改都涉及到同一个文件的同一处，在合并他们的时候就会产生合并冲突：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git merge iss53<br>Auto-merging index.html<br>CONFLICT (content): Merge conflict <span class="hljs-keyword">in</span> index.html<br>Automatic merge failed; fix conflicts and <span class="hljs-keyword">then</span> commit the result.<br></code></pre></td></tr></table></figure>
<p>此时Git做了合并，但是没有自动地创建一个新的合并提交，Git回暂停下来，等待你去解决合并产生地冲突。在合并冲突之后可以使用<code>git status</code>命令查看那些因为包含合并冲突而处于未合并状态的文件。</p>
<p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。Git会在有冲突的文件中加入标准的冲突解决标记：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html<br><span class="hljs-section">&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="hljs-section">=======</span><br>&lt;div id=&quot;footer&quot;&gt;<br><span class="hljs-code"> please contact us at support@github.com</span><br>&lt;/div&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html<br></code></pre></td></tr></table></figure>
<p>这表示HEAD所指示的版本（也就是你的master分支所在的位置）在这个区段的上半部分（ &#x3D;&#x3D;&#x3D; 的上半部分），iss53分支所示的版本在 &#x3D;&#x3D;&#x3D; 的下半部分。为了解决冲突，必须选择由&#x3D;&#x3D;&#x3D;分割的两个部分中的一个，或者自行合并这些内容，例如，可以通过把这段内容换成下面的样子来解决冲突：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;<br>please contact us <span class="hljs-keyword">at</span> email.support@github.com<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>
<p>上述的冲突解决方案仅保留了其中一个分支的修改，并且<code>&lt;&lt;==&gt;&gt;</code>这些行被完全删除。在解决了所有文件里的冲突之后，对每个文件使用<code>git add</code> 命令来将其标记为冲突已解决。一旦暂存了这些原本有冲突的文件，Git就会将他们标记为冲突已解决，</p>
<p>图像化工具：<code>git mergetool</code>会启动一个可视化的合并工具，并带着你一步一步解决这些冲突。</p>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch<br>  iss53<br>* master<br>  testing<br></code></pre></td></tr></table></figure>
<p><code>git branch</code>命令不仅可以创建和删除分支，如果不加任何参数，该命令表示列出当前所有分支。master分支前面的 * 表示现在检出的那一个分支（也就是HEAD指针所指向的分支）。如果想要查看每一个分支的最后一次提交可以运行<code>git branch -v</code>命令。</p>
<p><code>--merged</code>和<code>--no-merged</code>选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看哪些分支已经合并到当前分支</span><br>$ git branch --merged<br><br><span class="hljs-comment"># 查看所有包含未合并工作的分支</span><br>$ git branch --no-merged<br></code></pre></td></tr></table></figure>

<p>对于未合并的分支，尝试使用<code>git branch -d</code>命令会失败，因为它包含了还未合并的工作，如果真的想要删除分支并丢掉那部分工作，可以使用<code>-D</code>强制删除。</p>
<h3 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h3><h4 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h4><p>只在master分支上保留完全稳定的代码，还有一些名为develop<br>或topic的平行分支，用在做后续开发或者测试稳定性，这些分支不必保持绝对稳定，一旦达到稳定状态，就可以合并入master分支。<br><img src="https://git-scm.com/book/en/v2/images/lr-branches-2.png" srcset="/img/loading.gif" lazyload>  </p>
<h4 id="主题分支"><a href="#主题分支" class="headerlink" title="主题分支"></a>主题分支</h4><p>主题分支是一种短期分支，被用来实现单一特性或其相关工作。比如上文中用到主题分支（iss53和hotfix分支）提交了一些更新，并在他们合并入主干分支之后，又删除了他们。<br>考虑这样一个例子，你在 master 分支上工作到 C1，这时为了解决一个问题而新建 iss91 分支，在 iss91 分支上工作到 C4，然而对于那个问题你又有了新的想法，于是你再新建一个 iss91v2 分支试图用另一种方法解决那个问题，接着你回到 master 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 C10 的时候新建一个 dumbidea 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：<br><img src="https://git-scm.com/book/en/v2/images/topic-branches-1.png" srcset="/img/loading.gif" lazyload><br>现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 iss91v2 分支中方案。 另外，你将 dumbidea 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 iss91 分支（即丢弃 C5 和 C6 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：<br><img src="https://git-scm.com/book/en/v2/images/topic-branches-2.png" srcset="/img/loading.gif" lazyload>  </p>
<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><p>可以通过<code>git ls-remote &lt;remote&gt;</code>来显示地获得远程引用地完整列表，或者通过<code>git remote show &lt;remote&gt;</code>获得远程分支地更多信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote -v<br>origin  git@github.com:portkas/portkas.github.io.git (fetch)<br>origin  git@github.com:portkas/portkas.github.io.git (push)<br><br>$ git ls-remote origin<br>33e33baaadb70a791936b45c4f7a47ca104cdc1a        HEAD<br>33e33baaadb70a791936b45c4f7a47ca104cdc1a        refs/heads/hexo<br>294c8b3fa958a2f46defa546b0e137a91f0927d9        refs/heads/master<br></code></pre></td></tr></table></figure>
<p>远程分支只是分支的一种。本地的主分支为master，远程的主分支为origin&#x2F;master，这是两个不同的分支。<br><img src="https://git-scm.com/book/en/v2/images/remote-branches-1.png" srcset="/img/loading.gif" lazyload><br>如果你在本地master分支做了一些工作，在同一时间内其他人推送提交到 <code>git.ourcomoany.com</code>并且更新了他的master分支，也就是说你们的提交历史走向不同的方向。即便如此，只要保持不与origin服务器连接并拉取数据，你的origin&#x2F;master指针就不会移动。<br><img src="https://git-scm.com/book/en/v2/images/remote-branches-2.png" srcset="/img/loading.gif" lazyload><br>如果要与给定的远程仓库同步数据，运行<code>git fetch &lt;remote&gt;</code>命令（在本例中为<code>git fetch origin</code>）。这个命令会查找origin是哪一个服务器（在本例中是<code>git.ourcompany.com</code>），从中抓取本地没有的数据，并且更新本地数据库，移动origin&#x2F;master指针到更新之后的位置。<br><img src="https://git-scm.com/book/en/v2/images/remote-branches-3.png" srcset="/img/loading.gif" lazyload>  </p>
<h4 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h4><p>本地地分支并不会自动与远程分支同步，必须显式地推送想要 分享的分支。可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。<br>如果希望和别人一起在名为serverfix的分支上工作，运行<code>git push &lt;remote&gt; &lt;branch&gt;</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin serverfix<br>Counting objects: 24, <span class="hljs-keyword">done</span>.<br>Delta compression using up to 8 threads.<br>Compressing objects: 100% (15/15), <span class="hljs-keyword">done</span>.<br>Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, <span class="hljs-keyword">done</span>.<br>Total 24 (delta 2), reused 0 (delta 0)<br>To https://github.com/schacon/simplegit<br> * [new branch]      serverfix -&gt; serverfix<br></code></pre></td></tr></table></figure>

<p>下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支origin&#x2F;serverfix，指向服务器的serverfix分支的引用。<br>需要特别注意的是，当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本，即本地不会有一个新的serverfix分支，只有一个不可修改的origin&#x2F;serverfix指针。<br>可以运行<code>git merge origin/serverfix</code>将这些工作合并到当前所在的分支。如果想要在serverfix分支上工作，可以将其建立在远程跟踪分支之上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b serverfix origin/serverfix<br>Branch serverfix <span class="hljs-built_in">set</span> up to track remote branch serverfix from origin.<br>Switched to a new branch <span class="hljs-string">&#x27;serverfix&#x27;</span><br></code></pre></td></tr></table></figure>
<p>这会给你一个用于工作的本地分支，并且起点位于origin&#x2F;serverfix。</p>
<h4 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h4><p>当克隆一个仓库时，通常会自动地设置一个跟踪origin&#x2F;master地master分支。如果在一个跟踪分支上输入<code>git pull</code>，Git能自动地识别去哪个服务器上抓取，合并到哪个分支。<br>也可以设置其他地跟踪分支，运行<code>git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</code>，这是一个常用地操作，所以Git提供了–track快捷方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout --track origin/serverfix<br>Branch serverfix <span class="hljs-built_in">set</span> up to track remote branch serverfix from origin.<br>Switched to a new branch <span class="hljs-string">&#x27;serverfix&#x27;</span><br></code></pre></td></tr></table></figure>
<p>由于该操作太常用了，该快捷方式还有一个快捷方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout serverfix<br>Branch serverfix <span class="hljs-built_in">set</span> up to track remote branch serverfix from origin.<br>Switched to a new branch <span class="hljs-string">&#x27;serverfix&#x27;</span><br></code></pre></td></tr></table></figure>
<p>如果想要将本地分支与远程分支设置为不同的名字，可以使用命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b sf origin/erverfix<br>Branch sf <span class="hljs-built_in">set</span> up to track remote branch serverfix from origin.<br>Switched to a new branch <span class="hljs-string">&#x27;sf&#x27;</span><br></code></pre></td></tr></table></figure>
<p>现在，本地分支sf会自动从origin&#x2F;serverfix拉取。</p>
<p>如果想要修改正在跟踪地上有分支（即和本地分支绑定地服务器分支），可以在任意时间使用<code>-u</code>或<code>--set-upstream-to</code>选项来运行<code>git branch</code>来显示地设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 首先要先有一个本地分支，然后切换到这个分支，然后运行该指令指定要跟踪地远程分支</span><br>$ git branch -u origin/serverfix<br>Branch serverfix <span class="hljs-built_in">set</span> up to track remote branch serverfix from origin.<br></code></pre></td></tr></table></figure>
<p>如果要查看设置地所有跟踪分支，可以使用<code>git branch -vv</code>，会将所有地本地分支列出来，并且包含更多的信息，比如每一个分支正在跟踪哪个远程分支，本地分支是领先还是落后。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -vv<br>  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets<br>  master    1ae2a45 [origin/master] deploying index fix<br>* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should <span class="hljs-keyword">do</span> it<br>  testing   5ea463a trying something new<br></code></pre></td></tr></table></figure>
<p>可以看到iss53分支正在跟踪origin&#x2F;iss53并且ahead是2，意味着本地有两个提交还没有推送到服务器。master分支正在跟踪origin&#x2F;master分支并且是最新的。serverfix分支正在跟踪teamone服务器上的server-fix-good分支并且领先3落后1，意味着服务器上有一次还没有合并，同时本地还有三次提交没有推送。<br>需要注意的是，这些数字的值来自于你从服务器上最后一次抓取的数据，这个命令没有连接服务器，所以只会告诉你本地缓存的服务器数据，如果想要统计最新的领先和落后数字，可以在统计前抓取所有的远程仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git fetch --all<br>$ git branch -vv<br></code></pre></td></tr></table></figure>


<h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><p><code>git fetch</code>命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容，它只会获取数据然后让你自己合并。<br><code>git pull</code>命令在大多数情况下含义是一个<code>git fetch</code>紧接着一个<code>git merge</code>命令。该指令会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。<br>由于<code>git pull</code>经常令人困惑，通常单独显式地使用<code>git fetch</code>与<code>git merge</code></p>
<h4 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h4><p>当已经通过远程分支做完所有的工作后，可以运行<code>git push --delete &lt;branch&gt;</code>命令删除一个远程分支，例如要从服务器上删除serverfix分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin --delete serverfix<br>To https://github.com/schacon/simplegit<br> - [deleted]         serverfix<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Git/" class="category-chain-item">Git</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Git</div>
      <div>http://example.com/2025/02/22/MissingSemester/Git/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>ZhangHangming</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年2月22日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/02/22/MissingSemester/CMake%E5%B5%8C%E5%A5%97%E5%86%99%E6%B3%95/" title="CMake嵌套写法">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">CMake嵌套写法</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/02/22/MissingSemester/Github%E7%9A%84SSH%E9%85%8D%E7%BD%AE/" title="Github的SSH配置">
                        <span class="hidden-mobile">Github的SSH配置</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
